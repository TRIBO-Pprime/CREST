var tipuesearch = {"pages":[{"title":" CREST ","text":"CREST Table of Contents Brief description Building CREST Dependencies Third party components Typical use Full description License Brief description CREST - C omputational R esource for E roded S urface T opology - is designed to generate numerical rough surfaces that respect: size: $n \\times m$ regular grid statistical moments: Skewness $Ssk$ and Kurtosis $Sku$ principal correlation lengths: $\\tau_1$ and $\\tau_2$ asperity orientation: $\\alpha$ angle periodicity: with/without The programs are written in recent Fortran (2003+) top Building CREST Make sure that the dependencies described below are built. Debug mode: make debug Normal mode: make Dependencies CREST needs some components that are available through the following packages: TOOLIB Some general tools like FFT, file handling, minimization, sorting, etc. TPGLIB Some more specific programs like filtering, anisotropy analysis, derivation, etc. As a consequence the three packages have to be downloaded. top Third party components TOOLIB also uses external codes such as: FFTW3.3 , Fastest Fourier Transform in the West GNU General Public License Pikaia_oop , Modern Fortran Edition of the Pikaia Genetic Algorithm BSD like GNUFOR , Gnuplot Fortran GNU General Public License Bspline-fortran , Multidimensional B-Spline Interpolation of Data on a Regular Grid BSD like Typical use top Full description License CeCILL-C license ↩ GNU GPL ↩ New BSD-3 ↩ HSL software is strictly intended for Personal academic use on the download page ↩ Developer Info Arthur Francisco","tags":"home","loc":"index.html"},{"title":"param_crest – CREST ","text":"type, public :: param_crest Inherits type~~param_crest~~InheritsGraph type~param_crest param_crest MOMENT_STAT MOMENT_STAT type~param_crest->MOMENT_STAT m_end, m_inp, m_stt pikaia_class pikaia_class type~param_crest->pikaia_class pik_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=R8), public, allocatable, dimension(:) :: vect_h vector used to store the heights that meet the stat moments real(kind=R8), public, allocatable, dimension(:,:) :: surf surface array real(kind=R8), public, allocatable, dimension(:,:) :: imp_acf imposed autocorrelation real(kind=R8), public, allocatable, dimension(:,:) :: fhi digital filter real(kind=R8), public, allocatable, dimension(:,:) :: acf_surf calculated autocorrelation integer(kind=I4), public, allocatable, dimension(:) :: order vector that stores heights order type(MOMENT_STAT), public :: m_end final stat moments type(MOMENT_STAT), public :: m_inp input stat moments for genetic algo optimizer type(MOMENT_STAT), public :: m_stt starting stat moments type(pikaia_class), public :: pik_class PIKAIA class instanciation integer(kind=I4), public :: func_gen mathematical function used to generate the heights integer(kind=I4), public :: nparam number of parameters for the mathematical function integer(kind=I4), public :: nb_threads number of concurrent threads integer(kind=I4), public :: width surface nb points along x integer(kind=I4), public :: height surface nb points along y integer(kind=I4), public :: npts surface nb points integer(kind=I4), public :: sub_width subsurface nb points along x integer(kind=I4), public :: sub_height subsurface nb points along y integer(kind=I4), public :: sub_npts subsurface nb points logical(kind=I4), public :: reajust_skku if Ssk 2 +1 > Sku, modify Sku logical(kind=I4), public :: periodic is the surface periodic? logical(kind=I4), public :: apod apodize imposed acf? real(kind=R8), public :: l_acf1 correlation principal length at z=acf__z real(kind=R8), public :: l_acf2 correlation secondary length at z=acf__z real(kind=R8), public :: acf__z acf cutting plane z, for correlation lengths determination real(kind=R8), public :: a_acf roughness orientation real(kind=R8), public :: cutoff Gaussian filter cutoff real(kind=R8), public :: surf_width surface width (m) real(kind=R8), public :: surf_height surface height (m) real(kind=R8), public :: sub_surf_width subsurface width (m) real(kind=R8), public :: sub_surf_height subsurface height (m) real(kind=R8), public :: surf_dx surface increment along x (m) real(kind=R8), public :: surf_dy surface increment along y (m) real(kind=R8), public :: crt_acf acf criterion: mean absolute difference between imposed and calculated acf allowed real(kind=R8), public :: res_acf store mean absolute difference between imposed and calculated acf Source Code type param_crest real ( kind = R8 ), allocatable , dimension (:) :: vect_h !! *vector used to store the heights that meet the stat moments* real ( kind = R8 ), allocatable , dimension (:,:) :: surf !! *surface array* real ( kind = R8 ), allocatable , dimension (:,:) :: imp_acf !! *imposed autocorrelation* real ( kind = R8 ), allocatable , dimension (:,:) :: fhi !! *digital filter* real ( kind = R8 ), allocatable , dimension (:,:) :: acf_surf !! *calculated autocorrelation* integer ( kind = I4 ), allocatable , dimension (:) :: order !! *vector that stores heights order* type ( MOMENT_STAT ) :: m_end !! *final stat moments* type ( MOMENT_STAT ) :: m_inp !! *input stat moments for genetic algo optimizer* type ( MOMENT_STAT ) :: m_stt !! *starting stat moments* type ( pikaia_class ) :: pik_class !! **PIKAIA** *class instanciation* integer ( kind = I4 ) :: func_gen !! *mathematical function used to generate the heights* integer ( kind = I4 ) :: nparam !! *number of parameters for the mathematical function* integer ( kind = I4 ) :: nb_threads !! *number of concurrent threads* integer ( kind = I4 ) :: width !! *surface nb points along x* integer ( kind = I4 ) :: height !! *surface nb points along y* integer ( kind = I4 ) :: npts !! *surface nb points* integer ( kind = I4 ) :: sub_width !! *subsurface nb points along x* integer ( kind = I4 ) :: sub_height !! *subsurface nb points along y* integer ( kind = I4 ) :: sub_npts !! *subsurface nb points* logical ( kind = I4 ) :: reajust_skku !! *if Ssk**2 +1 > Sku, modify Sku* logical ( kind = I4 ) :: periodic !! *is the surface periodic?* logical ( kind = I4 ) :: apod !! *apodize imposed acf?* real ( kind = R8 ) :: l_acf1 !! *correlation principal length at z=acf__z* real ( kind = R8 ) :: l_acf2 !! *correlation secondary length at z=acf__z* real ( kind = R8 ) :: acf__z !! *acf cutting plane z, for correlation lengths determination* real ( kind = R8 ) :: a_acf !! *roughness orientation* real ( kind = R8 ) :: cutoff !! *Gaussian filter cutoff* real ( kind = R8 ) :: surf_width !! *surface width (m)* real ( kind = R8 ) :: surf_height !! *surface height (m)* real ( kind = R8 ) :: sub_surf_width !! *subsurface width (m)* real ( kind = R8 ) :: sub_surf_height !! *subsurface height (m)* real ( kind = R8 ) :: surf_dx !! *surface increment along x (m)* real ( kind = R8 ) :: surf_dy !! *surface increment along y (m)* real ( kind = R8 ) :: crt_acf !! *acf criterion: mean absolute difference between imposed and calculated acf allowed* real ( kind = R8 ) :: res_acf !! *store mean absolute difference between imposed and calculated acf* endtype param_crest","tags":"","loc":"type/param_crest.html"},{"title":"prg_surf – CREST","text":"subroutine prg_surf() Note Main function… retrieve script (job) file read script run specific functions associated to a script keyword Arguments None Calls proc~~prg_surf~~CallsGraph proc~prg_surf prg_surf proc~read_job read_job proc~prg_surf->proc~read_job get_unit get_unit proc~read_job->get_unit proc~acf_theo acf_theo proc~read_job->proc~acf_theo proc~calc_acf calc_acf proc~read_job->proc~calc_acf proc~calc_ffh calc_ffh proc~read_job->proc~calc_ffh proc~calc_ord calc_ord proc~read_job->proc~calc_ord proc~calc_z_f calc_z_f proc~read_job->proc~calc_z_f proc~calc_z_i calc_z_i proc~read_job->proc~calc_z_i proc~def_size def_size proc~read_job->proc~def_size proc~digi_fil digi_fil proc~read_job->proc~digi_fil proc~end_loop end_loop proc~read_job->proc~end_loop proc~end_scri end_scri proc~read_job->proc~end_scri proc~nb_procs nb_procs proc~read_job->proc~nb_procs proc~plt__acf plt__acf proc~read_job->proc~plt__acf proc~save_img save_img proc~read_job->proc~save_img proc~smooth__ smooth__ proc~read_job->proc~smooth__ proc~sta_loop sta_loop proc~read_job->proc~sta_loop proc~sta_scri sta_scri proc~read_job->proc~sta_scri proc~sta_theo sta_theo proc~read_job->proc~sta_theo proc~sub_surf sub_surf proc~read_job->proc~sub_surf selectcase selectcase proc~read_job->selectcase str_remove_chars str_remove_chars proc~read_job->str_remove_chars ellipse_acf ellipse_acf proc~acf_theo->ellipse_acf proc~calc_imp_acf calc_imp_acf proc~acf_theo->proc~calc_imp_acf proc~acf_wiener acf_wiener proc~calc_acf->proc~acf_wiener calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_ffh->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_ffh->calc_fftw3_real_fwd calc_moments calc_moments proc~calc_ffh->calc_moments init_order init_order proc~calc_ord->init_order sort_array2 sort_array2 proc~calc_ord->sort_array2 proc~calc_z_f->calc_moments proc~build_heights build_heights proc~calc_z_f->proc~build_heights proc~calc_z_i->calc_moments proc~calc_z_i->proc~build_heights scramble scramble proc~calc_z_i->scramble proc~digi_fil->calc_fftw3_real_bwd proc~digi_fil->calc_fftw3_real_fwd proc~digi_fil->calc_moments end_fftw3 end_fftw3 proc~end_scri->end_fftw3 omp_get_num_procs omp_get_num_procs proc~nb_procs->omp_get_num_procs proc~plt__acf->get_unit proc~plt__acf->ellipse_acf init_scal init_scal proc~save_img->init_scal write_surf write_surf proc~save_img->write_surf proc~smooth__->calc_moments fft_filter fft_filter proc~smooth__->fft_filter random_init random_init proc~sta_scri->random_init proc~sub_surf->calc_moments proc~sub_surf->end_fftw3 fftw_plan_with_nthreads fftw_plan_with_nthreads proc~sub_surf->fftw_plan_with_nthreads proc~sub_surf->init_order omp_get_max_threads omp_get_max_threads proc~sub_surf->omp_get_max_threads proc~sub_surf->proc~acf_wiener proc~sub_surf->proc~build_heights proc~sub_surf->proc~calc_imp_acf proc~calc_res_acf calc_res_acf proc~sub_surf->proc~calc_res_acf progress_bar_terminal progress_bar_terminal proc~sub_surf->progress_bar_terminal proc~sub_surf->sort_array2 tab_end_fftw3_real tab_end_fftw3_real proc~sub_surf->tab_end_fftw3_real tab_init_fftw3_real tab_init_fftw3_real proc~sub_surf->tab_init_fftw3_real proc~acf_wiener->calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center proc~build_heights->calc_moments proc~build_heights->sort_array2 proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d proc~apod2 apod2 proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo init init proc~pikaia_skku_solver->init solve solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~prg_surf~~CalledByGraph proc~prg_surf prg_surf program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine prg_surf () !================================================================================================ !<@note Main function... ! ! - retrieve script (job) file ! - read script ! - run specific functions associated to a script keyword ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 128 ) :: arg_prg character ( len = 512 ) :: job_file character ( len = 008 ) :: chara_d character ( len = 010 ) :: chara_t integer ( kind = I4 ) :: var_i ! String initialisation arg_prg = repeat ( ' ' , len ( arg_prg )) JOB_FILE = repeat ( ' ' , len ( JOB_FILE )) var_i = 1 call get_command_argument ( var_i , arg_prg ) ! argument one: argument string if ( len_trim ( arg_prg ) == 0 ) then ! if there is no job file, stop write ( TER , * ) 'no job file, stop' stop else job_file = trim ( arg_prg ) endif call read_job ( job_file ) ! the program executes 'prg_repeat' times write ( TER , * ) 'Program completed' return endsubroutine prg_surf","tags":"","loc":"proc/prg_surf.html"},{"title":"fitness_skku_anal – CREST","text":"private  function fitness_skku_anal(n, x) Note Generic cost function: difference between the imposed statistical moments and those\n obtained. The optimization problem must be turned into a maximization problem (as often\n in the optimization routines). The closer cost to 100 the better series. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n number of unknowns real(kind=R8), intent(in), dimension(1:n) :: x vector of unknowns Return Value real(kind=r8) Calls proc~~fitness_skku_anal~~CallsGraph proc~fitness_skku_anal fitness_skku_anal proc~calculs_skku_exp calculs_skku_exp proc~fitness_skku_anal->proc~calculs_skku_exp proc~calculs_skku_tan calculs_skku_tan proc~fitness_skku_anal->proc~calculs_skku_tan proc~add_expo add_expo proc~calculs_skku_exp->proc~add_expo proc~add_tang add_tang proc~calculs_skku_tan->proc~add_tang proc~tang tang proc~calculs_skku_tan->proc~tang proc~expo expo proc~add_expo->proc~expo proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fitness_skku_anal~~CalledByGraph proc~fitness_skku_anal fitness_skku_anal proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/fitness_skku_anal.html"},{"title":"add_tang – CREST","text":"private  function add_tang(n, deb, fin, alp, bet, mu, si) Note Function that adds to the series mean the border integrals as explained in the docs Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku integer(kind=I4), intent(in) :: deb first integration point integer(kind=I4), intent(in) :: fin last integration point real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) Calls proc~~add_tang~~CallsGraph proc~add_tang add_tang proc~tang tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_tang~~CalledByGraph proc~add_tang add_tang proc~calculs_skku_tan calculs_skku_tan proc~calculs_skku_tan->proc~add_tang proc~calculs_skku_generique calculs_skku_generique proc~calculs_skku_generique->proc~calculs_skku_tan proc~fitness_skku_anal fitness_skku_anal proc~fitness_skku_anal->proc~calculs_skku_tan proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/add_tang.html"},{"title":"add_expo – CREST","text":"private  function add_expo(n, deb, fin, alp, bet, mu, si) Note Function that adds to the series mean the border integrals as explained in the modules\n presentation. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku integer(kind=I4), intent(in) :: deb first integration point integer(kind=I4), intent(in) :: fin last integration point real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) Calls proc~~add_expo~~CallsGraph proc~add_expo add_expo proc~expo expo proc~add_expo->proc~expo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_expo~~CalledByGraph proc~add_expo add_expo proc~calculs_skku_exp calculs_skku_exp proc~calculs_skku_exp->proc~add_expo proc~calculs_skku_generique calculs_skku_generique proc~calculs_skku_generique->proc~calculs_skku_exp proc~fitness_skku_anal fitness_skku_anal proc~fitness_skku_anal->proc~calculs_skku_exp proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/add_expo.html"},{"title":"tang – CREST","text":"private  function tang(xi, n, alp, bet, mu, si) Note Profile function based on the tangent function Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi abscissa integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) Called by proc~~tang~~CalledByGraph proc~tang tang proc~add_tang add_tang proc~add_tang->proc~tang proc~calculs_skku_tan calculs_skku_tan proc~calculs_skku_tan->proc~tang proc~calculs_skku_tan->proc~add_tang proc~calculs_skku_generique calculs_skku_generique proc~calculs_skku_generique->proc~calculs_skku_tan proc~fitness_skku_anal fitness_skku_anal proc~fitness_skku_anal->proc~calculs_skku_tan proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/tang.html"},{"title":"expo – CREST","text":"private  function expo(xi, n, alp, bet, mu, si) Note Profile function based on the exponential function Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi abscissa integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) Called by proc~~expo~~CalledByGraph proc~expo expo proc~add_expo add_expo proc~add_expo->proc~expo proc~calculs_skku_exp calculs_skku_exp proc~calculs_skku_exp->proc~add_expo proc~calculs_skku_generique calculs_skku_generique proc~calculs_skku_generique->proc~calculs_skku_exp proc~fitness_skku_anal fitness_skku_anal proc~fitness_skku_anal->proc~calculs_skku_exp proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/expo.html"},{"title":"build_heights – CREST","text":"public  subroutine build_heights(vec_out, use_fct_expo, stats_in, lg) Note Function that returns a set of heights that matches desired statistical moments. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:lg) :: vec_out height vector logical(kind=I4), intent(in) :: use_fct_expo should exponential function rather than tangent function be used? type(MOMENT_STAT), intent(in) :: stats_in input statistical moments integer(kind=I4), intent(in) :: lg length of the height vector Calls proc~~build_heights~~CallsGraph proc~build_heights build_heights calc_moments calc_moments proc~build_heights->calc_moments proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d sort_array2 sort_array2 proc~build_heights->sort_array2 init init proc~pikaia_skku_solver->init solve solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_heights~~CalledByGraph proc~build_heights build_heights proc~calc_z_f calc_z_f proc~calc_z_f->proc~build_heights proc~calc_z_i calc_z_i proc~calc_z_i->proc~build_heights proc~sub_surf sub_surf proc~sub_surf->proc~build_heights proc~read_job read_job proc~read_job->proc~calc_z_f proc~read_job->proc~calc_z_i proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine build_heights ( vec_out , use_fct_expo , stats_in , lg ) !================================================================================================ !<@note Function that returns a set of heights that matches desired statistical moments. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: lg !! *length of the height vector* type ( MOMENT_STAT ), intent ( in ) :: stats_in !! *input statistical moments* logical ( kind = I4 ), intent ( in ) :: use_fct_expo !! *should exponential function rather than tangent function be used?* real ( kind = R8 ), intent ( out ), dimension ( 1 : lg ) :: vec_out !! *height vector* integer ( kind = I4 ) :: istat , fct_sav real ( kind = R8 ) :: cost_val type ( MOMENT_STAT ) :: m_tmp real ( kind = R8 ), dimension ( 1 : PARAM % nparam ) :: xlower real ( kind = R8 ), dimension ( 1 : PARAM % nparam ) :: xupper real ( kind = R8 ), dimension ( 1 : PARAM % nparam ) :: xresul ! put input parameters in global variables, so that they can be used in the function \"fitness_skku_anal\" PARAM % m_inp % sk = stats_in % sk PARAM % m_inp % ku = stats_in % ku ! save PARAM%func_gen value fct_sav = PARAM % func_gen ! if the Pearson limit is to close to the point (Ssk, Sku), an exponential function is used if ( use_fct_expo ) PARAM % func_gen = FCT_EXPO ! Genetic algorithm is used to determinate the tangent parameters \\alpha and \\beta so that, the set of lg heights ! will match the statistical moments. !.............................................................................. ! initialization xresul ( 1 : PARAM % nparam ) = 0.0_R8 xlower ( 1 : PARAM % nparam ) = 0.0_R8 xupper ( 1 : PARAM % nparam ) = 1.0_R8 call pikaia_skku_solver ( pik_class = PARAM % pik_class , & ! INOUT step = 'init' , & ! IN xl = xlower ( 1 : PARAM % nparam ), & ! IN xu = xupper ( 1 : PARAM % nparam ), & ! IN xx = xresul ( 1 : PARAM % nparam ), & ! IN nparam = PARAM % nparam , & ! IN cost = cost_func_skku , & ! IN istat = istat , & ! OUT f = cost_val ) ! IN call pikaia_skku_solver ( pik_class = PARAM % pik_class , & ! INOUT step = 'solv' , & ! IN xl = xlower ( 1 : PARAM % nparam ), & ! IN xu = xupper ( 1 : PARAM % nparam ), & ! IN xx = xresul ( 1 : PARAM % nparam ), & ! OUT nparam = PARAM % nparam , & ! IN cost = cost_func_skku , & ! IN istat = istat , & ! OUT f = cost_val ) ! IN !.............................................................................. ! the parameters habe been found, let generate lg heights !.............................................................................. call profil_theo_trie_1D ( tab = vec_out ( 1 : lg ), & ! OUT lg = lg , & ! IN x = xresul ( 1 : PARAM % nparam ), & ! IN mx = m_tmp ) ! OUT !.............................................................................. ! PARAM%func_gen value is retrieved PARAM % func_gen = fct_sav ! height moments calculation call calc_moments ( tab = vec_out ( 1 : lg ), & ! IN mx = m_tmp , & ! OUT nb_mom = 4 ) ! IN ! scale and center vec_out ( 1 : lg ) = ( vec_out ( 1 : lg ) - m_tmp % mu ) / m_tmp % si ! the parameter found can lead to inverted heights if ( stats_in % sk * m_tmp % sk < 0. ) then vec_out ( 1 : lg ) = - vec_out ( 1 : lg ) endif ! heights are sorted call sort_array2 ( tab_inout = vec_out ( 1 : lg ), n = lg ) return endsubroutine build_heights","tags":"","loc":"proc/build_heights.html"},{"title":"cost_func_skku – CREST","text":"private  subroutine cost_func_skku(me, x, f) Quantify de distance between desired moments and calculated moments Arguments Type Intent Optional Attributes Name class(pikaia_class), intent(inout) :: me real(kind=R8), intent(in), dimension(:) :: x real(kind=R8), intent(out) :: f Calls proc~~cost_func_skku~~CallsGraph proc~cost_func_skku cost_func_skku proc~fitness_skku_anal fitness_skku_anal proc~cost_func_skku->proc~fitness_skku_anal proc~calculs_skku_exp calculs_skku_exp proc~fitness_skku_anal->proc~calculs_skku_exp proc~calculs_skku_tan calculs_skku_tan proc~fitness_skku_anal->proc~calculs_skku_tan proc~add_expo add_expo proc~calculs_skku_exp->proc~add_expo proc~add_tang add_tang proc~calculs_skku_tan->proc~add_tang proc~tang tang proc~calculs_skku_tan->proc~tang proc~expo expo proc~add_expo->proc~expo proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine cost_func_skku ( me , x , f ) !! Quantify de distance between desired moments and calculated moments implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f f = fitness_skku_anal ( n = PARAM % nparam , x = x ( 1 : PARAM % nparam ) ) return endsubroutine cost_func_skku","tags":"","loc":"proc/cost_func_skku.html"},{"title":"pikaia_skku_solver – CREST","text":"private  subroutine pikaia_skku_solver(pik_class, step, xl, xu, nparam, cost, istat, f, xx) Note This is a refactoring of the PIKAIA unconstrained optimization code from the High Altitude Observatory.\n The original code is public domain and was written by Paul Charbonneau & Barry Knapp. The present code is the awesome modern Fortran version written by Jabob Williams: OOP Pikaia, Jacob Williams Arguments Type Intent Optional Attributes Name type(pikaia_class), intent(inout) :: pik_class PIKAIA class instanciation character(len=4), intent(in) :: step init or solv real(kind=R8), intent(in), dimension(1:nparam) :: xl lower bonds of xx real(kind=R8), intent(in), dimension(1:nparam) :: xu upper bonds of xx integer(kind=I4), intent(in) :: nparam number of parameters private  subroutine cost(me, x, f) Arguments Type Intent Optional Attributes Name class(pikaia_class), intent(inout) :: me real(kind=R8), intent(in), dimension(:) :: x real(kind=R8), intent(out) :: f integer(kind=I4), intent(out) :: istat real(kind=R8), intent(out) :: f real(kind=R8), intent(out), dimension(1:nparam) :: xx chromosom for PIKAIA Calls proc~~pikaia_skku_solver~~CallsGraph proc~pikaia_skku_solver pikaia_skku_solver init init proc~pikaia_skku_solver->init solve solve proc~pikaia_skku_solver->solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pikaia_skku_solver~~CalledByGraph proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights build_heights proc~build_heights->proc~pikaia_skku_solver proc~calc_z_f calc_z_f proc~calc_z_f->proc~build_heights proc~calc_z_i calc_z_i proc~calc_z_i->proc~build_heights proc~sub_surf sub_surf proc~sub_surf->proc~build_heights proc~read_job read_job proc~read_job->proc~calc_z_f proc~read_job->proc~calc_z_i proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine pikaia_skku_solver ( pik_class , step , xl , xu , nparam , cost , istat , f , xx ) !================================================================================================ !<@note This is a refactoring of the PIKAIA unconstrained optimization code from the High Altitude Observatory. ! The original code is public domain and was written by Paul Charbonneau & Barry Knapp. ! ! The present code is the awesome modern Fortran version written by Jabob Williams: ! ! [OOP Pikaia, Jacob Williams](https://github.com/jacobwilliams/pikaia) ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none type ( pikaia_class ), intent ( inout ) :: pik_class !! **PIKAIA** *class instanciation* character ( len = 4 ), intent ( in ) :: step !! *init* or *solv* integer ( kind = I4 ), intent ( in ) :: nparam !! *number of parameters* real ( kind = R8 ), intent ( in ), dimension ( 1 : nparam ) :: xl !! *lower bonds of xx* real ( kind = R8 ), intent ( in ), dimension ( 1 : nparam ) :: xu !! *upper bonds of xx* real ( kind = R8 ), intent ( out ), dimension ( 1 : nparam ) :: xx !! *chromosom for* **PIKAIA** integer ( kind = I4 ), intent ( out ) :: istat real ( kind = R8 ), intent ( out ) :: f interface subroutine cost ( me , x , f ) use data_arch , only : R8 use pikaia_oop , only : pikaia_class implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f endsubroutine cost endinterface select case ( step ) case ( 'init' ) !initialize the class: call pik_class % init ( n = nparam , & ! IN           ; the parameter space dimension, i.e., the number of adjustable parameters (size of the x vector). xl = xl , & ! IN, DIM(n)   ;  vector of lower bounds for x xu = xu , & ! IN, DIM(n)   ;  vector of upper bounds for x f = cost , & !              ; user-supplied scalar function of n variables, which must have the pikaia_func procedure interface. status = istat , & ! OUT          ; status output flag (0 if there were no errors) !iter_f = report_iteration,    &  !     OPT      ; user-supplied subroutine that will report the best solution for each generation. It must have the iter_func procedure interface. np = 100 , & ! IN, OPT      ; number of individuals in a population (default is 100) ngen = 1000 , & ! IN, OPT      ; maximum number of iterations nd = 9 , & ! IN           ; number of significant digits (i.e., number of genes) retained in chromosomal encoding pcross = 0.85_R8 , & ! IN, OPT      ; crossover probability; must be <= 1.0 (default is 0.85). If crossover takes place, either one or two splicing points are used, with equal probabilities pmutmn = 0.0005_R8 , & ! IN, OPT      ; minimum mutation rate; must be >= 0.0 (default is 0.0005) pmutmx = 0.25_R8 , & ! IN, OPT      ; maximum mutation rate; must be <= 1.0 (default is 0.25) pmut = 0.005_R8 , & ! IN, OPT      ; initial mutation rate; should be small (default is 0.005) (Note: the mutation rate is the probability that any one gene locus will mutate in any one generation.) imut = 2 , & ! IN, OPT      ; mutation mode; 1/2/3/4/5 (default is 2). !              1=one-point mutation, fixed rate. !              2=one-point, adjustable rate based on fitness. !              3=one-point, adjustable rate based on distance. !              4=one-point+creep, fixed rate. !              5=one-point+creep, adjustable rate based on fitness. !              6=one-point+creep, adjustable rate based on distance. fdif = 1._R8 , & ! IN, OPT      ; relative fitness differential; range from 0 (none) to 1 (maximum). (default is 1.0) irep = 3 , & ! IN, OPT      ; reproduction plan; 1/2/3=Full generational replacement/Steady-state-replace-random/Steady- state-replace-worst (default is 3) ielite = 0 , & ! IN, OPT      ; elitism flag; 0/1=off/on (default is 0) (Applies only to reproduction plans 1 and 2) ivrb = 0 , & ! IN, OPT      ; printed output 0/1/2=None/Minimal/Verbose convergence_tol = 1.0e-6_R8 , & ! IN, OPT      ; convergence tolerance; must be > 0.0 (default is 0.0001) convergence_window = 200 , & ! IN, OPT      ; convergence window; must be >= 0 This is the number of consecutive solutions within the tolerance for convergence to be declared (default is 20) initial_guess_frac = 0.1_R8 , & ! IN, OPT      ; raction of the initial population to set equal to the initial guess. Range from 0 (none) to 1.0 (all). (default is 0.1 or 10%). iseed = 999 ) ! IN, OPT      ; random seed value; must be > 0 (default is 999) case ( 'solv' ) call pik_class % solve ( x = xx ( 1 : nparam ), & ! INOUT, DIM(*) ; f = f , & !   OUT         ; status = istat , & !   OUT         ; omp = . true . ) ! IN, OPTIONAL case default stop 'Wrong choice in \"pikaia_skku_solver\"' endselect return endsubroutine pikaia_skku_solver","tags":"","loc":"proc/pikaia_skku_solver.html"},{"title":"calculs_skku_tan – CREST","text":"private  subroutine calculs_skku_tan(bounds, lg, ssk, sku) Note Function to calculate the skewness and kurtosis of a tangent series Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: bounds defines the function limits [-pi/2.(1-bounds(1)), +pi/2.(1-bounds(2)] integer(kind=I4), intent(in) :: lg vec size real(kind=R8), intent(out) :: ssk theoretical Ssk real(kind=R8), intent(out) :: sku theoretical Sku Calls proc~~calculs_skku_tan~~CallsGraph proc~calculs_skku_tan calculs_skku_tan proc~add_tang add_tang proc~calculs_skku_tan->proc~add_tang proc~tang tang proc~calculs_skku_tan->proc~tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculs_skku_tan~~CalledByGraph proc~calculs_skku_tan calculs_skku_tan proc~calculs_skku_generique calculs_skku_generique proc~calculs_skku_generique->proc~calculs_skku_tan proc~fitness_skku_anal fitness_skku_anal proc~fitness_skku_anal->proc~calculs_skku_tan proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calculs_skku_tan ( bounds , lg , ssk , sku ) !================================================================================================ !<@note Function to calculate the skewness and kurtosis of a **tangent** series ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: bounds !! *defines the function limits* [-pi/2.(1-bounds(1)), +pi/2.(1-bounds(2)] integer ( kind = I4 ), intent ( in ) :: lg !! *vec size* real ( kind = R8 ), intent ( out ) :: ssk !! *theoretical Ssk* real ( kind = R8 ), intent ( out ) :: sku !! *theoretical Sku* real ( kind = R8 ) :: xa , xb , mu , si , sk , ku , a , b real ( kind = R8 ) :: h , hh , b1 , b2 , alp , bet integer ( kind = I4 ) :: i , ia , ib , deb , fin !--------------------------------------------- ! WXMAXIMA file !--------------------------------------------- !kill(all); ! !f11(x):=tan(x)$ ! !assume(u<0.)$ !assume(u>-%pi/2)$ !assume(v>0.)$ !assume(v<%pi/2)$ ! !I11:integrate(f11(x),x,u,v)$ !I11:subst(-%pi/2+%pi/2*xa,u,I11)$ !I11:subst(+%pi/2-%pi/2*xb,v,I11)$ !I11:expand(trigsimp(I11)); ! !f21(x):=f11(x)-mu$ !I21:integrate(expand(f21(x)&#94;2),x,u,v)$ !I21:subst(-%pi/2+%pi/2*xa,u,I21)$ !I21:subst(+%pi/2-%pi/2*xb,v,I21)$ !I21:expand(trigsimp(I21)); ! !f31(x):=f21(x)/si$ !I31:integrate(f31(x)&#94;3,x,u,v)$ !I31:subst(-%pi/2+%pi/2*xa,u,I31)$ !I31:subst(+%pi/2-%pi/2*xb,v,I31)$ !I31:expand(trigsimp(I31)); ! !I41:integrate(f31(x)&#94;4,x,u,v)$ !I41:subst(-%pi/2+%pi/2*xa,u,I41)$ !I41:subst(+%pi/2-%pi/2*xb,v,I41)$ !I41:expand(trigsimp(I41)); !--------------------------------------------- ia = 256 ! ia and ib define the interval edges to be excluded ... ib = 256 ! ... because of high variations of the function. deb = 1 + ia ! start fin = lg - ib ! end a = bounds ( 1 ) b = bounds ( 2 ) hh = ( 2._R8 - a - b ) / ( lg - 1 ) h = ( PI_R8 / 2 ) * hh xa = a + ia * hh xb = b + ib * hh b1 = - PI_R8 / 2 * ( UN - a ) b2 = + PI_R8 / 2 * ( UN - b ) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . mu = log ( sin (( PI_R8 * xa ) / 2. )) - log ( sin (( PI_R8 * xb ) / 2. )) mu = ( UN / h ) * mu + add_tang ( 1 , deb , fin , alp , bet , mu = 0._R8 , si = 1._R8 ) do i = 1 , ia - 1 mu = mu + tang ( i * UN , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo do i = lg , lg - ( ib - 2 ), - 1 mu = mu + tang ( i * UN , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo mu = mu / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . si = 2. * mu * log ( sin (( PI_R8 * xb ) / 2. )) + cos (( PI_R8 * xb ) / 2. ) / sin (( PI_R8 * xb ) / 2. ) - ( PI_R8 * mu ** 2. * xb ) / 2. + ( PI_R8 * xb ) / 2. & ! - 2. * mu * log ( sin (( PI_R8 * xa ) / 2. )) + cos (( PI_R8 * xa ) / 2. ) / sin (( PI_R8 * xa ) / 2. ) - ( PI_R8 * mu ** 2. * xa ) / 2. + ( PI_R8 * xa ) / 2. + PI_R8 * mu ** 2. - PI_R8 ! si = ( UN / h ) * si + add_tang ( 2 , deb , fin , alp , bet , mu , si = 1._R8 ) do i = 1 , ia - 1 si = si + tang ( i * UN , 2 , alp , bet , mu , si = 1._R8 ) enddo do i = lg , lg - ( ib - 2 ), - 1 si = si + tang ( i * UN , 2 , alp , bet , mu , si = 1._R8 ) enddo si = si / lg si = sqrt ( si ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . sk = log ( sin (( PI_R8 * xb ) / 2. ) ** 2. ) / ( 2. * si ** 3. ) & ! - ( 3. * mu ** 2. * log ( sin (( PI_R8 * xb ) / 2. ))) / si ** 3. & ! - ( 3. * mu * cos (( PI_R8 * xb ) / 2. )) / ( si ** 3. * sin (( PI_R8 * xb ) / 2. )) & ! + 1 / ( 2. * si ** 3. * sin (( PI_R8 * xb ) / 2. ) ** 2. ) + ( PI_R8 * mu ** 3. * xb ) / ( 2. * si ** 3. ) & ! - ( 3. * PI_R8 * mu * xb ) / ( 2. * si ** 3. ) & ! - log ( sin (( PI_R8 * xa ) / 2. ) ** 2. ) / ( 2. * si ** 3. ) & ! + ( 3. * mu ** 2. * log ( sin (( PI_R8 * xa ) / 2. ))) / si ** 3. & ! - ( 3. * mu * cos (( PI_R8 * xa ) / 2. )) / ( si ** 3. * sin (( PI_R8 * xa ) / 2. )) & ! - 1 / ( 2. * si ** 3. * sin (( PI_R8 * xa ) / 2. ) ** 2. ) + ( PI_R8 * mu ** 3. * xa ) / ( 2. * si ** 3. ) & ! - ( 3. * PI_R8 * mu * xa ) / ( 2. * si ** 3. ) - ( PI_R8 * mu ** 3. ) / si ** 3. + ( 3. * PI_R8 * mu ) / si ** 3. ! sk = ( UN / h ) * sk + add_tang ( 3 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 sk = sk + tang ( i * UN , 3 , alp , bet , mu , si ) enddo do i = lg , lg - ( ib - 2 ), - 1 sk = sk + tang ( i * UN , 3 , alp , bet , mu , si ) enddo sk = sk / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ku = - ( 2. * mu * log ( sin (( PI_R8 * xb ) / 2. ) ** 2. )) / si ** 4. + ( 4. * mu ** 3. * log ( sin (( PI_R8 * xb ) / 2. ))) / si ** 4. & ! + ( 6. * mu ** 2. * cos (( PI_R8 * xb ) / 2. )) / ( si ** 4. * sin (( PI_R8 * xb ) / 2. )) - ( 4. * cos (( PI_R8 * xb ) / 2. )) / ( 3. * si ** 4. * sin (( PI_R8 * xb ) / 2. )) & ! - ( 2. * mu ) / ( si ** 4. * sin (( PI_R8 * xb ) / 2. ) ** 2. ) + cos (( PI_R8 * xb ) / 2. ) / ( 3. * si ** 4. * sin (( PI_R8 * xb ) / 2. ) ** 3. ) & ! - ( PI_R8 * mu ** 4. * xb ) / ( 2. * si ** 4. ) + ( 3. * PI_R8 * mu ** 2. * xb ) / si ** 4. - ( PI_R8 * xb ) / ( 2. * si ** 4. ) & ! + ( 2. * mu * log ( sin (( PI_R8 * xa ) / 2. ) ** 2. )) / si ** 4. - ( 4. * mu ** 3. * log ( sin (( PI_R8 * xa ) / 2. ))) / si ** 4. & ! + ( 6. * mu ** 2. * cos (( PI_R8 * xa ) / 2. )) / ( si ** 4. * sin (( PI_R8 * xa ) / 2. )) - ( 4. * cos (( PI_R8 * xa ) / 2. )) / ( 3. * si ** 4. * sin (( PI_R8 * xa ) / 2. )) & ! + ( 2. * mu ) / ( si ** 4. * sin (( PI_R8 * xa ) / 2. ) ** 2. ) + cos (( PI_R8 * xa ) / 2. ) / ( 3. * si ** 4. * sin (( PI_R8 * xa ) / 2. ) ** 3. ) & ! - ( PI_R8 * mu ** 4. * xa ) / ( 2. * si ** 4. ) + ( 3. * PI_R8 * mu ** 2. * xa ) / si ** 4. - ( PI_R8 * xa ) / ( 2. * si ** 4. ) & ! + ( PI_R8 * mu ** 4. ) / si ** 4. - ( 6. * PI_R8 * mu ** 2. ) / si ** 4. + PI_R8 / si ** 4. ! ku = ( UN / h ) * ku + add_tang ( 4 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 ku = ku + tang ( i * UN , 4 , alp , bet , mu , si ) enddo do i = lg , lg - ( ib - 2 ), - 1 ku = ku + tang ( i * UN , 4 , alp , bet , mu , si ) enddo ku = ku / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ssk = sk sku = ku return endsubroutine calculs_skku_tan","tags":"","loc":"proc/calculs_skku_tan.html"},{"title":"calculs_skku_exp – CREST","text":"private  subroutine calculs_skku_exp(bounds, lg, ssk, sku) Note Function to calculate the skewness and kurtosis of an exponential series. The principle is the same as calculs_skku_tan , however it fits better some particular\n series quite binary (roughly two heights). Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: bounds interval limits [-(1/bounds(1)-1), +(1/bounds(2)-1)] integer(kind=I4), intent(in) :: lg vec size real(kind=R8), intent(out) :: ssk theoretical Ssk real(kind=R8), intent(out) :: sku theoretical Sku Calls proc~~calculs_skku_exp~~CallsGraph proc~calculs_skku_exp calculs_skku_exp proc~add_expo add_expo proc~calculs_skku_exp->proc~add_expo proc~expo expo proc~add_expo->proc~expo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculs_skku_exp~~CalledByGraph proc~calculs_skku_exp calculs_skku_exp proc~calculs_skku_generique calculs_skku_generique proc~calculs_skku_generique->proc~calculs_skku_exp proc~fitness_skku_anal fitness_skku_anal proc~fitness_skku_anal->proc~calculs_skku_exp proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calculs_skku_exp ( bounds , lg , ssk , sku ) !================================================================================================ !<@note Function to calculate the skewness and kurtosis of an **exponential** series.<br/> ! The principle is the same as [[calculs_skku_tan]], however it fits better some particular ! series quite binary (roughly two heights). ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: bounds !! *interval limits* [-(1/bounds(1)-1), +(1/bounds(2)-1)] integer ( kind = I4 ), intent ( in ) :: lg !! *vec size* real ( kind = R8 ), intent ( out ) :: ssk !! *theoretical Ssk* real ( kind = R8 ), intent ( out ) :: sku !! *theoretical Sku* real ( kind = R8 ) :: xa , xb , xk , mu , si , sk , ku , a , b , pente real ( kind = R8 ) :: h , hh , b1 , b2 , alp , bet real ( kind = R8 ) :: exp1b , exp1a , exp2b , exp2a , exp3b , exp3a , exp4b , exp4a , tmp1a , tmp1b , tmp2a , tmp2b , tmp3a , tmp3b , tmp4a , tmp4b integer ( kind = I4 ) :: deb , fin pente = UN !--------------------------------------------- ! WXMaxima file !--------------------------------------------- !kill(all); !load (f90)$ ! !f11(x):=-1+exp(+xk*x)$ !g11(x):=+1-exp(-xk*x)$ ! !f21(x):=f11(x)-mu$ !g21(x):=g11(x)-mu$ ! !f31(x):=f21(x)/si$ !g31(x):=g21(x)/si$ ! !assume(v>0.)$ !assume(u>0.)$ !/* [wxMaxima: input   end   ] */ ! !/* [wxMaxima: input   start ] */ !I11:integrate(f11(x),x,-u,0)$ !J11:integrate(g11(x),x,+0,v)$ !I11:subst(1./xa-1.,u,I11)$ !J11:subst(1./xb-1.,v,J11)$ !I11:I11+J11$ !I11:expand(trigsimp(I11))$ !f90(I11); !/* [wxMaxima: input   end   ] */ ! !/* [wxMaxima: input   start ] */ !I21:integrate(f21(x)&#94;2,x,-u,0)$ !J21:integrate(g21(x)&#94;2,x,+0,v)$ !I21:subst(1./xa-1.,u,I21)$ !J21:subst(1./xb-1.,v,J21)$ !I21:I21+J21$ !I21:expand(trigsimp(I21))$ !f90(I21); !/* [wxMaxima: input   end   ] */ ! !/* [wxMaxima: input   start ] */ !I31:integrate(f31(x)&#94;3,x,-u,0)$ !J31:integrate(g31(x)&#94;3,x,+0,v)$ !I31:subst(1./xa-1.,u,I31)$ !J31:subst(1./xb-1.,v,J31)$ !I31:I31+J31$ !I31:expand(trigsimp(I31))$ !f90(I31); !/* [wxMaxima: input   end   ] */ ! !/* [wxMaxima: input   start ] */ !I41:integrate(f31(x)&#94;4,x,-u,0)$ !J41:integrate(g31(x)&#94;4,x,+0,v)$ !I41:subst(1./xa-1.,u,I41)$ !J41:subst(1./xb-1.,v,J41)$ !I41:I41+J41$ !I41:expand(trigsimp(I41))$ !f90(I41); !--------------------------------------------- a = max ( bounds ( 1 ), 1.e-6_R8 ) b = max ( bounds ( 2 ), 1.e-6_R8 ) hh = ( - 2._R8 + UN / a + UN / b ) / ( lg - 1 ) h = hh xa = a xb = b xk = pente b1 = - ( UN - a ) / a b2 = + ( UN - b ) / b alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) deb = 1 fin = lg tmp1a = 1 * ( xk - xk / xa ) ; tmp1a = max ( - 0.9 * HIG_E8 , tmp1a ) ; tmp1a = min ( + 0.9 * HIG_E8 , tmp1a ) tmp1b = 1 * ( xk - xk / xb ) ; tmp1b = max ( - 0.9 * HIG_E8 , tmp1b ) ; tmp1b = min ( + 0.9 * HIG_E8 , tmp1b ) tmp2a = 2 * ( xk - xk / xa ) ; tmp2a = max ( - 0.9 * HIG_E8 , tmp2a ) ; tmp2a = min ( + 0.9 * HIG_E8 , tmp2a ) tmp2b = 2 * ( xk - xk / xb ) ; tmp2b = max ( - 0.9 * HIG_E8 , tmp2b ) ; tmp2b = min ( + 0.9 * HIG_E8 , tmp2b ) tmp3a = 3 * ( xk - xk / xa ) ; tmp3a = max ( - 0.9 * HIG_E8 , tmp3a ) ; tmp3a = min ( + 0.9 * HIG_E8 , tmp3a ) tmp3b = 3 * ( xk - xk / xb ) ; tmp3b = max ( - 0.9 * HIG_E8 , tmp3b ) ; tmp3b = min ( + 0.9 * HIG_E8 , tmp3b ) tmp4a = 4 * ( xk - xk / xa ) ; tmp4a = max ( - 0.9 * HIG_E8 , tmp4a ) ; tmp4a = min ( + 0.9 * HIG_E8 , tmp4a ) tmp4b = 4 * ( xk - xk / xb ) ; tmp4b = max ( - 0.9 * HIG_E8 , tmp4b ) ; tmp4b = min ( + 0.9 * HIG_E8 , tmp4b ) exp1a = exp ( tmp1a ) exp1b = exp ( tmp1b ) exp2a = exp ( tmp2a ) exp2b = exp ( tmp2b ) exp3a = exp ( tmp3a ) exp3b = exp ( tmp3b ) exp4a = exp ( tmp4a ) exp4b = exp ( tmp4b ) mu = exp1b / xk - exp1a / xk + 1 / xb - 1 / xa mu = ( UN / h ) * mu + add_expo ( 1 , deb , fin , alp , bet , mu = 0._R8 , si = 1._R8 ) mu = mu / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . si = - 2 * mu * exp1b / xk + 2 * exp1b / xk - exp2b / xk / 2.0 + 2 * mu * exp1a / xk + 2 * exp1a / xk - exp2a / xk / 2.0 & ! - 3 / xk + mu ** 2 / xb - 2 * mu / xb + 1 / xb + mu ** 2 / xa + 2 * mu / xa + 1 / xa - 2 * mu ** 2 - 2 ! si = ( UN / h ) * si + add_expo ( 2 , deb , fin , alp , bet , mu , si = 1._R8 ) si = si / lg si = sqrt ( si ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . sk = 3 * mu ** 2 * exp1b / ( si ** 3 * xk ) - 6 * mu * exp1b / ( si ** 3 * xk ) + 3 * exp1b / ( si ** 3 * xk ) + 3.0 * mu * exp2b / ( 2.0 * si ** 3 * xk ) & ! + ( - 3.0 ) * exp2b / ( 2.0 * si ** 3 * xk ) + exp3b / ( si ** 3 * xk ) / 3.0 - 3 * mu ** 2 * exp1a / ( si ** 3 * xk ) - 6 * mu * exp1a / ( si ** 3 * xk ) & ! - 3 * exp1a / ( si ** 3 * xk ) + 3.0 * mu * exp2a / ( 2.0 * si ** 3 * xk ) + 3.0 * exp2a / ( 2.0 * si ** 3 * xk ) - exp3a / ( si ** 3 * xk ) / 3.0 & ! + 9 * mu / ( si ** 3 * xk ) - mu ** 3 / ( si ** 3 * xb ) + 3 * mu ** 2 / ( si ** 3 * xb ) - 3 * mu / ( si ** 3 * xb ) + 1 / ( si ** 3 * xb ) - mu ** 3 / ( si ** 3 * xa ) & ! - 3 * mu ** 2 / ( si ** 3 * xa ) - 3 * mu / ( si ** 3 * xa ) - 1 / ( si ** 3 * xa ) + 2 * mu ** 3 / si ** 3 + 6 * mu / si ** 3 ! sk = ( UN / h ) * sk + add_expo ( 3 , deb , fin , alp , bet , mu , si ) sk = sk / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ku = - 4 * mu ** 3 * exp1b / ( si ** 4 * xk ) + 12 * mu ** 2 * exp1b / ( si ** 4 * xk ) - 12 * mu * exp1b / ( si ** 4 * xk ) + 4 * exp1b / ( si ** 4 * xk ) & ! - 3 * mu ** 2 * exp2b / ( si ** 4 * xk ) + 6 * mu * exp2b / ( si ** 4 * xk ) - 3 * exp2b / ( si ** 4 * xk ) + ( - 4.0 ) * mu * exp3b / ( 3.0 * si ** 4 * xk ) & ! + 4.0 * exp3b / ( 3.0 * si ** 4 * xk ) - exp4b / ( si ** 4 * xk ) / 4.0 + 4 * mu ** 3 * exp1a / ( si ** 4 * xk ) + 12 * mu ** 2 * exp1a / ( si ** 4 * xk ) & ! + 12 * mu * exp1a / ( si ** 4 * xk ) + 4 * exp1a / ( si ** 4 * xk ) - 3 * mu ** 2 * exp2a / ( si ** 4 * xk ) - 6 * mu * exp2a / ( si ** 4 * xk ) & ! - 3 * exp2a / ( si ** 4 * xk ) + 4.0 * mu * exp3a / ( 3.0 * si ** 4 * xk ) + 4.0 * exp3a / ( 3.0 * si ** 4 * xk ) - exp4a / ( si ** 4 * xk ) / 4.0 & ! - 18 * mu ** 2 / ( si ** 4 * xk ) + ( - 2 5.0 ) / ( 6.0 * si ** 4 * xk ) + mu ** 4 / ( si ** 4 * xb ) - 4 * mu ** 3 / ( si ** 4 * xb ) + 6 * mu ** 2 / ( si ** 4 * xb ) & ! - 4 * mu / ( si ** 4 * xb ) + 1 / ( si ** 4 * xb ) + mu ** 4 / ( si ** 4 * xa ) + 4 * mu ** 3 / ( si ** 4 * xa ) + 6 * mu ** 2 / ( si ** 4 * xa ) & ! + 4 * mu / ( si ** 4 * xa ) + 1 / ( si ** 4 * xa ) - 2 * mu ** 4 / si ** 4 - 12 * mu ** 2 / si ** 4 - 2 / si ** 4 ! ku = ( UN / h ) * ku + add_expo ( 4 , deb , fin , alp , bet , mu , si ) ku = ku / lg ssk = sk sku = ku return endsubroutine calculs_skku_exp","tags":"","loc":"proc/calculs_skku_exp.html"},{"title":"calculs_skku_generique – CREST","text":"public  subroutine calculs_skku_generique(bounds, lg, ssk, sku) Note Function that calls the right series generator. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(:) :: bounds interval limits integer(kind=I4), intent(in) :: lg vec size real(kind=R8), intent(out) :: ssk theoretical Ssk real(kind=R8), intent(out) :: sku theoretical Sku Calls proc~~calculs_skku_generique~~CallsGraph proc~calculs_skku_generique calculs_skku_generique proc~calculs_skku_exp calculs_skku_exp proc~calculs_skku_generique->proc~calculs_skku_exp proc~calculs_skku_tan calculs_skku_tan proc~calculs_skku_generique->proc~calculs_skku_tan proc~add_expo add_expo proc~calculs_skku_exp->proc~add_expo proc~add_tang add_tang proc~calculs_skku_tan->proc~add_tang proc~tang tang proc~calculs_skku_tan->proc~tang proc~expo expo proc~add_expo->proc~expo proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calculs_skku_generique ( bounds , lg , ssk , sku ) !================================================================================================ !<@note Function that calls the right series generator. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension (:) :: bounds !! *interval limits* integer ( kind = I4 ), intent ( in ) :: lg !! *vec size* real ( kind = R8 ), intent ( out ) :: ssk !! *theoretical Ssk* real ( kind = R8 ), intent ( out ) :: sku !! *theoretical Sku* select case ( PARAM % func_gen ) case ( FCT_TANG ) ; call calculs_skku_tan ( bounds , lg , ssk , sku ) case ( FCT_EXPO ) ; call calculs_skku_exp ( bounds , lg , ssk , sku ) endselect return endsubroutine calculs_skku_generique","tags":"","loc":"proc/calculs_skku_generique.html"},{"title":"profil_theo_trie_1D – CREST","text":"private  subroutine profil_theo_trie_1D(tab, lg, x, mx) Note Function that generates the heights when the function limits have been determined. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:lg) :: tab height vector integer(kind=I4), intent(in) :: lg height vector size real(kind=R8), intent(in), dimension( :  ) :: x unknowns: height function limits type(MOMENT_STAT), intent(out) :: mx resulting statistical moments Calls proc~~profil_theo_trie_1d~~CallsGraph proc~profil_theo_trie_1d profil_theo_trie_1D calc_moments calc_moments proc~profil_theo_trie_1d->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~profil_theo_trie_1d~~CalledByGraph proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights build_heights proc~build_heights->proc~profil_theo_trie_1d proc~calc_z_f calc_z_f proc~calc_z_f->proc~build_heights proc~calc_z_i calc_z_i proc~calc_z_i->proc~build_heights proc~sub_surf sub_surf proc~sub_surf->proc~build_heights proc~read_job read_job proc~read_job->proc~calc_z_f proc~read_job->proc~calc_z_i proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine profil_theo_trie_1D ( tab , lg , x , mx ) !================================================================================================ !<@note Function that generates the heights when the function limits have been determined. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: lg !! *height vector size* real ( kind = R8 ), intent ( out ), dimension ( 1 : lg ) :: tab !! *height vector* real ( kind = R8 ), intent ( in ), dimension ( : ) :: x !! *unknowns: height function limits* type ( MOMENT_STAT ), intent ( out ) :: mx !! *resulting statistical moments* real ( kind = R8 ) :: b1 , b2 , alp , bet , tmp , pente integer ( kind = I4 ) :: i select case ( PARAM % func_gen ) case ( FCT_TANG ) b1 = - PI_R8 / 2 * ( UN - x ( 1 )) b2 = + PI_R8 / 2 * ( UN - x ( 2 )) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) do i = 1 , lg tab ( i ) = tan ( ( i * UN + alp ) / bet ) enddo case ( FCT_EXPO ) pente = UN b1 = - ( UN - x ( 1 )) / x ( 1 ) b2 = + ( UN - x ( 2 )) / x ( 2 ) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) do i = 1 , lg tmp = ( i * UN + alp ) / bet tmp = max ( - 0.9 * HIG_E8 , tmp ) tmp = min ( + 0.9 * HIG_E8 , tmp ) tab ( i ) = sign ( UN , tmp ) * ( UN - exp ( - pente * abs ( tmp ))) enddo endselect call calc_moments ( tab = tab ( 1 : lg ), mx = mx , nb_mom = 4 ) tab ( 1 : lg ) = ( tab ( 1 : lg ) - mx % mu ) / mx % si ! normalization mx % mu = 0._R8 mx % si = 1._R8 return endsubroutine profil_theo_trie_1D","tags":"","loc":"proc/profil_theo_trie_1d.html"},{"title":"autocov_impo – CREST","text":"private  function autocov_impo(xi, xj, tau1, tau2, alpha, ang) Note Function that returns Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi coordinate real(kind=R8), intent(in) :: xj coordinate real(kind=R8), intent(in) :: tau1 correlation length along real(kind=R8), intent(in) :: tau2 correlation length along real(kind=R8), intent(in) :: alpha log(z) where z is often 0.2 real(kind=R8), intent(in) :: ang angle (rad) Return Value real(kind=r8) Called by proc~~autocov_impo~~CalledByGraph proc~autocov_impo autocov_impo proc~calc_imp_acf calc_imp_acf proc~calc_imp_acf->proc~autocov_impo proc~acf_theo acf_theo proc~acf_theo->proc~calc_imp_acf proc~sub_surf sub_surf proc~sub_surf->proc~calc_imp_acf proc~read_job read_job proc~read_job->proc~acf_theo proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autocov_impo.html"},{"title":"acf_wiener – CREST","text":"public  subroutine acf_wiener(tab_in, tab_out, w, h, multi_fft) Note Function that returns the acf of an array. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:w, 1:h) :: tab_in input array real(kind=R8), intent(out), dimension(1:w, 1:h) :: tab_out acf of the input array integer(kind=I4), intent(in) :: w 2D array length integer(kind=I4), intent(in) :: h 2D array width logical(kind=I4), intent(in), optional :: multi_fft run parallel acfs? Calls proc~~acf_wiener~~CallsGraph proc~acf_wiener acf_wiener calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~acf_wiener~~CalledByGraph proc~acf_wiener acf_wiener proc~calc_acf calc_acf proc~calc_acf->proc~acf_wiener proc~sub_surf sub_surf proc~sub_surf->proc~acf_wiener proc~read_job read_job proc~read_job->proc~calc_acf proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine acf_wiener ( tab_in , tab_out , w , h , multi_fft ) !================================================================================================ !<@note Function that returns the *acf* of an array. !  ! \\begin{align*} !    acf(i,j) &= (z \\ast z)(i,j) = \\sum_{k,l}&#94;{n,n} z(k+1-i,l+1-j)z(k,l)  \\\\ !    TF(acf)  &= ACF = Z \\cdot Z                                          \\\\ !    acf      &= TF&#94;{-1}(ACF) = TF&#94;{-1}(Z&#94;2) ! \\end{align*} !  ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: w !! *2D array length* integer ( kind = I4 ), intent ( in ) :: h !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: tab_in !! *input array* real ( kind = R8 ), intent ( out ), dimension ( 1 : w , 1 : h ) :: tab_out !! *acf of the input array* logical ( kind = I4 ), intent ( in ), optional :: multi_fft !! *run parallel acfs?* integer ( kind = I4 ) :: lo2 , la2 real ( kind = R8 ) :: tmp logical ( kind = I4 ) :: parallel_fft integer ( kind = I4 ), dimension ( 1 : 2 ) :: loc_max complex ( kind = R8 ), dimension (:,:), allocatable :: tab_cmpl real ( kind = R8 ), dimension (:,:), allocatable :: tab_real allocate ( tab_cmpl ( 1 : w , 1 : h ) ) allocate ( tab_real ( 1 : w , 1 : h ) ) ! check for simultaneous fftw calculations !......................................... parallel_fft = . false . if ( present ( multi_fft ) ) parallel_fft = multi_fft !......................................... ! DFFT real -> complex !......................................... if ( parallel_fft ) then call tab_calc_fftw3_real_fwd ( tab_in = tab_in ( 1 : w , 1 : h ), & ! IN tab_ou = tab_cmpl ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN else call calc_fftw3_real_fwd ( tab_in = tab_in ( 1 : w , 1 : h ), & ! IN tab_ou = tab_cmpl ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h , & ! IN planner_flag = FFTW_MEASURE ) ! IN endif !......................................... tab_cmpl ( 1 : w , 1 : h ) = cmplx ( abs ( tab_cmpl ( 1 : w , 1 : h ) ) ** 2 , 0 , kind = R8 ) ! IFFT complex -> real !......................................... if ( parallel_fft ) then call tab_calc_fftw3_real_bwd ( tab_in = tab_cmpl ( 1 : w , 1 : h ), & ! IN tab_ou = tab_real ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN else call calc_fftw3_real_bwd ( tab_in = tab_cmpl ( 1 : w , 1 : h ), & ! IN tab_ou = tab_real ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h , & ! IN planner_flag = FFTW_MEASURE ) ! IN endif !......................................... ! the maximum is placed in the array center !......................................... call trans_corner2center ( tab_in = tab_real ( 1 : w , 1 : h ), & ! IN tab_out = tab_out ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN !......................................... ! the maximum is 1 !......................................... loc_max ( 1 : 2 ) = maxloc ( tab_out ( 1 : w , 1 : h ) ) lo2 = loc_max ( 1 ) la2 = loc_max ( 2 ) tmp = tab_out ( lo2 , la2 ) tab_out ( 1 : w , 1 : h ) = tab_out ( 1 : w , 1 : h ) / tmp !......................................... deallocate ( tab_cmpl ) deallocate ( tab_real ) return endsubroutine acf_wiener","tags":"","loc":"proc/acf_wiener.html"},{"title":"calc_imp_acf – CREST","text":"public  subroutine calc_imp_acf(long, larg, tau1, tau2, alpha, ang, tab_acf, apod) Note Function that returns the theoretical autocorrelation function in an array. The autocorrelation function is supposed to be obtained from a real surface which must be periodic\n or nearly periodic (because of the use of FFTs).\n In addition, the surface is supposed to be 0 mean and normalized ( ),\n therefore acf is zero-mean and normalized so that its max value is 1. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long surface acf width integer(kind=I4), intent(in) :: larg surface acf height real(kind=R8), intent(in) :: tau1 first correlation length real(kind=R8), intent(in) :: tau2 surface second correlation length real(kind=R8), intent(in) :: alpha parameter that controls the expondential decrease real(kind=R8), intent(in) :: ang acf ellipsis angle real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_acf resulting acf logical(kind=I4), intent(in) :: apod apodization? Calls proc~~calc_imp_acf~~CallsGraph proc~calc_imp_acf calc_imp_acf proc~apod2 apod2 proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_imp_acf~~CalledByGraph proc~calc_imp_acf calc_imp_acf proc~acf_theo acf_theo proc~acf_theo->proc~calc_imp_acf proc~sub_surf sub_surf proc~sub_surf->proc~calc_imp_acf proc~read_job read_job proc~read_job->proc~acf_theo proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_imp_acf ( long , larg , tau1 , tau2 , alpha , ang , tab_acf , apod ) !================================================================================================ !<@note Function that returns the theoretical autocorrelation function in an array.<br/> ! The autocorrelation function is supposed to be obtained from a real surface which must be periodic ! or nearly periodic (because of the use of FFTs). ! In addition, the surface is supposed to be 0 mean and normalized (\\sigma = 1 ), ! therefore *acf* is zero-mean and normalized so that its max value is 1.<br/> ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface acf width* integer ( kind = I4 ), intent ( in ) :: larg !! *surface acf height* logical ( kind = I4 ), intent ( in ) :: apod !! *apodization?* real ( kind = R8 ), intent ( in ) :: tau1 !! *first correlation length* real ( kind = R8 ), intent ( in ) :: tau2 !! *surface second correlation length* real ( kind = R8 ), intent ( in ) :: alpha !! *parameter that controls the expondential decrease* real ( kind = R8 ), intent ( in ) :: ang !! *acf ellipsis angle* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_acf !! *resulting acf* integer ( kind = I4 ) :: i , j , long2 , larg2 real ( kind = R8 ) :: xi , xj , s , c , coeff real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp ! acf array, centered and normalized !......................................... c = cos ( ang ) ; s = sin ( ang ) long2 = long / 2 larg2 = larg / 2 if ( long == 2 * ( long / 2 ) ) long2 = long / 2 + 1 if ( larg == 2 * ( larg / 2 ) ) larg2 = larg / 2 + 1 do j = 1 , larg do i = 1 , long xi = real ( i - long2 , kind = R8 ) * PARAM % surf_dx ! dimensioned coordinate x xj = real ( j - larg2 , kind = R8 ) * PARAM % surf_dy ! dimensioned coordinate y tab_acf ( i , j ) = autocov_impo ( xi = xi , & ! IN xj = xj , & ! IN tau1 = tau1 , & ! IN tau2 = tau2 , & ! IN alpha = alpha , & ! IN ang = ang ) ! IN enddo enddo !......................................... ! For long correlation lengths and roughness orientation, the acf is far from periodic ! Furthermore, far from the center, respecting the acf becomes less important. A windowing ! can be determined so that at a given distance from the center, the acf is lessened. !......................................... if ( apod ) then allocate ( tab_tmp ( 1 : long , 1 : larg ) ) coeff = 0.4 * PARAM % surf_width * c / tau1 ! along the primary axis (longest correlation length) the acf is reduce beyond ! 0.4 * image width * cos(ang) ! (0.4 * image width is less than half width) call apod2 ( tab_in = tab_acf ( 1 : long , 1 : larg ), & ! IN tab_out = tab_tmp ( 1 : long , 1 : larg ), & ! OUT long = long , & ! IN larg = larg , & ! IN tau1 = coeff * tau1 , & ! IN tau2 = coeff * tau2 , & ! IN ang = ang ) ! IN tab_acf ( 1 : long , 1 : larg ) = tab_tmp ( 1 : long , 1 : larg ) deallocate ( tab_tmp ) endif !......................................... ! acf centered tab_acf ( 1 : long , 1 : larg ) = tab_acf ( 1 : long , 1 : larg ) - sum ( tab_acf ( 1 : long , 1 : larg ) ) / ( long * larg ) ! acf scaled (maximum = 1) tab_acf ( 1 : long , 1 : larg ) = tab_acf ( 1 : long , 1 : larg ) / tab_acf ( long2 , larg2 ) return endsubroutine calc_imp_acf","tags":"","loc":"proc/calc_imp_acf.html"},{"title":"apod2 – CREST","text":"private  subroutine apod2(tab_in, tab_out, long, larg, tau1, tau2, ang) Note Function that returns an apodized array. To prevent gaps from appearing after FFT (because of non periodic waves), the surface must\n be transformed, but not too much. Here a modified Tukey window is determined. The starting\n surface is not modified below the “correlation lengths”. Above the correlation lengths, a\n smooth decrease is forced with a cosine squared. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in input acf real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out apodized acf integer(kind=I4), intent(in) :: long surface acf length integer(kind=I4), intent(in) :: larg surface acf width real(kind=R8), intent(in) :: tau1 surface first correlation length real(kind=R8), intent(in) :: tau2 surface second correlation length real(kind=R8), intent(in) :: ang ellipsis angle Called by proc~~apod2~~CalledByGraph proc~apod2 apod2 proc~calc_imp_acf calc_imp_acf proc~calc_imp_acf->proc~apod2 proc~acf_theo acf_theo proc~acf_theo->proc~calc_imp_acf proc~sub_surf sub_surf proc~sub_surf->proc~calc_imp_acf proc~read_job read_job proc~read_job->proc~acf_theo proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine apod2 ( tab_in , tab_out , long , larg , tau1 , tau2 , ang ) !================================================================================================ !<@note Function that returns an apodized array.<br/> ! To prevent gaps from appearing after FFT (because of non periodic waves), the surface must ! be transformed, but not too much. Here a modified Tukey window is determined. The starting ! surface is not modified below the \"correlation lengths\". Above the correlation lengths, a ! smooth decrease is forced with a cosine squared. !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface acf length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface acf width* real ( kind = R8 ), intent ( in ) :: tau1 !! *surface first correlation length* real ( kind = R8 ), intent ( in ) :: tau2 !! *surface second correlation length* real ( kind = R8 ), intent ( in ) :: ang !! *ellipsis angle* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *input acf* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *apodized acf* real ( kind = R8 ) :: r2 , c0 , s0 , rd , rr , theta , theta_diag , x , y , t , a_min , sum_inn , sum_tab , sum_int integer ( kind = I4 ) :: i , j , k , long2 , larg2 , npt_out , n real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp ! first bissector angle (rad) theta_diag = atan2 ( PARAM % surf_height , PARAM % surf_width ) ! sine and cosine of the ellipsis angle c0 = cos ( ang ) ; s0 = sin ( ang ) long2 = long / 2 larg2 = larg / 2 if ( long == 2 * ( long / 2 ) ) long2 = long / 2 + 1 if ( larg == 2 * ( larg / 2 ) ) larg2 = larg / 2 + 1 tab_out ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) rr = 1.e6_R8 do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) cycle ! The correlation length is exceeded. ! The angle corresponding to the position (i,j) is calculated theta = atan2 ( y , x ) ; if ( theta < 0. ) theta = theta + 2 * Pi_R8 t = tan ( theta ) ! According the location of (i,j) (right, top, left or bottom) the line that begin at the surface center, passing by (i,j), ! ends on one of the four borders. if ( theta > 2 * Pi_R8 - theta_diag . or . theta <= + theta_diag ) then ; x = ( long - long2 ) * PARAM % surf_dx ; y = x * t ; endif if ( theta > + theta_diag . and . theta <= PI_R8 - theta_diag ) then ; y = ( larg - larg2 ) * PARAM % surf_dy ; x = y / t ; endif if ( theta > PI_R8 - theta_diag . and . theta <= PI_R8 + theta_diag ) then ; x = ( 1 - long2 ) * PARAM % surf_dx ; y = x * t ; endif if ( theta > PI_R8 + theta_diag . and . theta <= 2 * Pi_R8 - theta_diag ) then ; y = ( 1 - larg2 ) * PARAM % surf_dy ; x = y / t ; endif ! The same distance as above is calculated, from the center to the surface edge, then ... rd = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 rr = min ( rr , sqrt ( rd ) ) enddo enddo rr = 0.99 * rr sum_inn = 0 sum_tab = 0 sum_int = 0 npt_out = 0 n = 2 do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) then sum_inn = sum_inn + tab_in ( i , j ) cycle endif r2 = sqrt ( r2 ) if ( r2 >= rr ) then npt_out = npt_out + 1 cycle endif ! ... the modified Tuckey window can be determined. sum_tab = sum_tab + ( cos ( 0.5_R8 * PI_R8 * ( r2 - 1. ) / ( rr - 1. ) ) ** n ) * tab_in ( i , j ) sum_int = sum_int + ( r2 - 1. ) / ( rr - 1. ) enddo enddo a_min = - ( sum_inn + sum_tab ) / ( npt_out + sum_int ) do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) cycle r2 = sqrt ( r2 ) if ( r2 >= rr ) then tab_out ( i , j ) = a_min cycle endif ! ... the modified Tuckey window can be determined. tab_out ( i , j ) = ( cos ( 0.5_R8 * PI_R8 * ( r2 - 1. ) / ( rr - 1. ) ) ** n ) * tab_in ( i , j ) + a_min * ( r2 - 1. ) / ( rr - 1. ) enddo enddo allocate ( tab_tmp ( 1 : long , 1 : larg ) ) do k = 1 , 10 tab_tmp ( 1 : long , 1 : larg ) = tab_out ( 1 : long , 1 : larg ) do j = 1 + 1 , larg - 1 do i = 1 + 1 , long - 1 x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 r2 = sqrt ( r2 ) if ( r2 <= 0.98_R8 . or . ( r2 >= 1.02_R8 . and . r2 <= 0.98_R8 * rr ) . or . r2 >= 1.02_R8 * rr ) cycle tab_out ( i , j ) = ( 2 * tab_tmp ( i , j ) + tab_tmp ( i + 1 , j ) + tab_tmp ( i - 1 , j ) + & ! tab_tmp ( i , j + 1 ) + tab_tmp ( i , j - 1 ) + ( tab_tmp ( i + 1 , j - 1 ) + tab_tmp ( i - 1 , j - 1 ) + & ! tab_tmp ( i - 1 , j + 1 ) + tab_tmp ( i + 1 , j + 1 ) ) / sqrt ( 2._R8 ) ) / ( 6. + 4. / sqrt ( 2._R8 ) ) enddo enddo enddo deallocate ( tab_tmp ) return endsubroutine apod2","tags":"","loc":"proc/apod2.html"},{"title":"read_job – CREST","text":"public  subroutine read_job(job_file) Note Function that reads a script file. Keywords are identified and corresponding actions are\n triggered. Arguments Type Intent Optional Attributes Name character(len=512), intent(in) :: job_file job file with macros to execute Calls proc~~read_job~~CallsGraph proc~read_job read_job get_unit get_unit proc~read_job->get_unit proc~acf_theo acf_theo proc~read_job->proc~acf_theo proc~calc_acf calc_acf proc~read_job->proc~calc_acf proc~calc_ffh calc_ffh proc~read_job->proc~calc_ffh proc~calc_ord calc_ord proc~read_job->proc~calc_ord proc~calc_z_f calc_z_f proc~read_job->proc~calc_z_f proc~calc_z_i calc_z_i proc~read_job->proc~calc_z_i proc~def_size def_size proc~read_job->proc~def_size proc~digi_fil digi_fil proc~read_job->proc~digi_fil proc~end_loop end_loop proc~read_job->proc~end_loop proc~end_scri end_scri proc~read_job->proc~end_scri proc~nb_procs nb_procs proc~read_job->proc~nb_procs proc~plt__acf plt__acf proc~read_job->proc~plt__acf proc~save_img save_img proc~read_job->proc~save_img proc~smooth__ smooth__ proc~read_job->proc~smooth__ proc~sta_loop sta_loop proc~read_job->proc~sta_loop proc~sta_scri sta_scri proc~read_job->proc~sta_scri proc~sta_theo sta_theo proc~read_job->proc~sta_theo proc~sub_surf sub_surf proc~read_job->proc~sub_surf selectcase selectcase proc~read_job->selectcase str_remove_chars str_remove_chars proc~read_job->str_remove_chars ellipse_acf ellipse_acf proc~acf_theo->ellipse_acf proc~calc_imp_acf calc_imp_acf proc~acf_theo->proc~calc_imp_acf proc~acf_wiener acf_wiener proc~calc_acf->proc~acf_wiener calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_ffh->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_ffh->calc_fftw3_real_fwd calc_moments calc_moments proc~calc_ffh->calc_moments init_order init_order proc~calc_ord->init_order sort_array2 sort_array2 proc~calc_ord->sort_array2 proc~calc_z_f->calc_moments proc~build_heights build_heights proc~calc_z_f->proc~build_heights proc~calc_z_i->calc_moments proc~calc_z_i->proc~build_heights scramble scramble proc~calc_z_i->scramble proc~digi_fil->calc_fftw3_real_bwd proc~digi_fil->calc_fftw3_real_fwd proc~digi_fil->calc_moments end_fftw3 end_fftw3 proc~end_scri->end_fftw3 omp_get_num_procs omp_get_num_procs proc~nb_procs->omp_get_num_procs proc~plt__acf->get_unit proc~plt__acf->ellipse_acf init_scal init_scal proc~save_img->init_scal write_surf write_surf proc~save_img->write_surf proc~smooth__->calc_moments fft_filter fft_filter proc~smooth__->fft_filter random_init random_init proc~sta_scri->random_init proc~sub_surf->calc_moments proc~sub_surf->end_fftw3 fftw_plan_with_nthreads fftw_plan_with_nthreads proc~sub_surf->fftw_plan_with_nthreads proc~sub_surf->init_order omp_get_max_threads omp_get_max_threads proc~sub_surf->omp_get_max_threads proc~sub_surf->proc~acf_wiener proc~sub_surf->proc~build_heights proc~sub_surf->proc~calc_imp_acf proc~calc_res_acf calc_res_acf proc~sub_surf->proc~calc_res_acf progress_bar_terminal progress_bar_terminal proc~sub_surf->progress_bar_terminal proc~sub_surf->sort_array2 tab_end_fftw3_real tab_end_fftw3_real proc~sub_surf->tab_end_fftw3_real tab_init_fftw3_real tab_init_fftw3_real proc~sub_surf->tab_init_fftw3_real proc~acf_wiener->calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center proc~build_heights->calc_moments proc~build_heights->sort_array2 proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d proc~apod2 apod2 proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo init init proc~pikaia_skku_solver->init solve solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_job~~CalledByGraph proc~read_job read_job proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine read_job ( job_file ) !================================================================================================ !<@note Function that reads a script file. Keywords are identified and corresponding actions are ! triggered. !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 512 ), intent ( in ) :: job_file !! job file with macros to execute integer ( kind = I4 ) :: vide character ( len = 512 ) :: keyword logical ( kind = I4 ) :: first ! script file call get_unit ( JOB ) open ( unit = JOB , file = trim ( job_file ), status = 'old' ) ! witness file call get_unit ( SPY ) open ( unit = SPY , file = \"out/spy.txt\" , status = 'unknown' ) LINE_READ = 0 first = . true . ! determine if calc_z_f has been already used ! default function used: the tangent function PARAM % func_gen = FCT_TANG ! default is 2 bounds when generating profiles PARAM % nparam = 2 o : do keyword = repeat ( ' ' , len ( keyword ) ) read ( JOB , * , iostat = vide ) keyword ; LINE_READ = LINE_READ + 1 ! remove unwanted characters from keyword keyword = str_remove_chars ( string = trim ( keyword ), chars = '- # *' ) write ( SPY , '(a6,I4.4,a)' ) \"line: \" , LINE_READ , ' ' , trim ( keyword ) selectcase ( keyword ( 1 : 8 ) ) case ( 'STA_SCRI' ) ! start script call sta_scri () case ( 'DEF_SIZE' ) ! image size call def_size () case ( 'NB_PROCS' ) ! number of threads call nb_procs () case ( 'STA_THEO' ) ! desired stat moments call sta_theo () case ( 'ACF_THEO' ) ! desired acf call acf_theo () case ( 'CALC_FFH' ) ! deigital filter call calc_ffh ( calc_m_stt = first ) case ( 'CALC_Z_I' ) ! starting heights call calc_z_i () case ( 'DIGI_FIL' ) ! apply digital filter call digi_fil () case ( 'CALC_ORD' ) ! determine heights order call calc_ord () case ( 'CALC_Z_F' ) ! final heights call calc_z_f ( to_be_made = first ) ! now, calc_z_f is considered as already ran first = . false . case ( 'STA_LOOP' ) ! loop start call sta_loop () case ( 'END_LOOP' ) ! loop end call end_loop () case ( 'SUB_SURF' ) ! extract the best surface call sub_surf () case ( 'SMOOTH__' ) ! low-pass filter call smooth__ () case ( 'SAVE_PRF' ) ! save image call save_img ( tab = PARAM % surf ) ! IN case ( 'CALC_ACF' ) ! determine the surface acf call calc_acf () case ( 'PLT__ACF' ) ! print the correlation graphs and/or determine ! if the stop criterion is reached. call plt__acf () case ( 'SAVE_ACF' ) ! save the acf surface call save_img ( tab = PARAM % imp_acf ) ! IN case ( 'END_SCRI' ) ! close the script reading call end_scri () exit o endselect enddo o close ( JOB ) return endsubroutine read_job","tags":"","loc":"proc/read_job.html"},{"title":"plt__acf – CREST","text":"private  subroutine plt__acf() Note Function that calculates the mean absolute difference between the desired Acf and\n the one obtained.\n However, the important zone where both should match is above acf__z - where the correlation\n lengths are determined. If the mean absolute difference is below the criterion, the loops to improve the acf are\n stopped. The function can also plot the acfs. Arguments None Calls proc~~plt__acf~~CallsGraph proc~plt__acf plt__acf ellipse_acf ellipse_acf proc~plt__acf->ellipse_acf get_unit get_unit proc~plt__acf->get_unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~plt__acf~~CalledByGraph proc~plt__acf plt__acf proc~read_job read_job proc~read_job->proc~plt__acf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine plt__acf () !================================================================================================ !<@note Function that calculates the mean absolute difference between the desired Acf and ! the one obtained. ! However, the important zone where both should match is above acf__z - where the correlation ! lengths are determined. ! ! If the mean absolute difference is below the criterion, the loops to improve the acf are ! stopped. ! ! The function can also plot the acfs. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: i , w , h , mw , mh , uplot , ll logical ( kind = I4 ) :: is_x , is_y real ( kind = R8 ) :: lim_crit_acf , crit_acf , dxy , l1 , l2 character ( len = 512 ) :: plt_acf real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp real ( kind = R8 ), dimension ( 1 : 8 ) :: res read ( JOB , * ) lim_crit_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , \"Acf criterion \" , lim_crit_acf read ( JOB , * ) plt_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , trim ( plt_acf ) PARAM % crt_acf = lim_crit_acf ! mean absolute difference limit w = PARAM % width h = PARAM % height ! Mean absolute difference between the calculated acf and the theoretical acf !................................................................................... allocate ( tab_tmp ( 1 : w , 1 : h ) ) tab_tmp ( 1 : w , 1 : h ) = 0 where ( PARAM % imp_acf > PARAM % acf__z ) tab_tmp = abs ( PARAM % acf_surf - PARAM % imp_acf ) crit_acf = 100 * sum ( tab_tmp ( 1 : w , 1 : h ) ) / count ( tab_tmp ( 1 : w , 1 : h ) > 0 ) PARAM % res_acf = crit_acf deallocate ( tab_tmp ) write ( TER , * ) \"acf difference \" , crit_acf write ( SPY , * ) 'acf difference ' , crit_acf ! if the acf criterion is reached, the loops stop: a means is to modify the max number ! of loops, so that the main loop is exited. if ( lim_crit_acf > 0. . and . lim_crit_acf > crit_acf ) NB_ITER = 1 !................................................................................... ! Graphs? !................................................................................... ! if 'x' is present, plot the graph along the principal axis ! if 'y' is present, plot the graph along the secondary axis is_x = ( index ( trim ( plt_acf ), 'x' ) /= 0 ) is_y = ( index ( trim ( plt_acf ), 'y' ) /= 0 ) if ( . not .( is_x . or . is_y ) ) return ! ensure that w and h are odd, or act accordingly mw = w / 2 mh = h / 2 if ( w == 2 * ( w / 2 ) ) mw = w / 2 + 1 if ( h == 2 * ( h / 2 ) ) mh = h / 2 + 1 call ellipse_acf ( tabin = PARAM % acf_surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN p_acv = res ( 1 : 8 ), & ! OUT -> correlation lengths cut = PARAM % acf__z , & ! IN  -> z cut plane scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN  -> lags along x and y omp = . true . ) ! IN  -> use multithread? write ( TER , * ) res ( 1 : 2 ), res ( 4 ) write ( SPY , * ) 'acf lengths and roughness orientation ' , res ( 1 : 2 ), res ( 4 ) ! parameters for the plot ll = 2 * min ( mw , mh ) - 3 dxy = sqrt ( PARAM % surf_dx ** 2 + PARAM % surf_dy ** 2 ) call get_unit ( uplot ) if ( is_x ) call graph ( axis = 1 ) if ( is_y ) call graph ( axis = 2 ) contains subroutine graph ( axis ) !================================================================================================ !<@note Function that plots the graphs to compare the ACF along the primary and/or secondary axes. !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: axis !! *1 or 2 for primary or secondary axis* character ( len = 256 ) :: file_acf , file_gpl , title character ( len = 003 ) :: xlab real ( kind = R8 ) :: angle real ( kind = R8 ), allocatable , dimension (:) :: profile_acf_surf , profile_imp_acf allocate ( profile_acf_surf ( 1 : ll ) ) allocate ( profile_imp_acf ( 1 : ll ) ) if ( axis == 1 ) then angle = PARAM % a_acf file_acf = 'out/gpl/acfx.txt' file_gpl = 'out/gpl/acfx.gpl' title = '\"ACF comparison along primary axis X\"' xlab = '\"X\"' else angle = PARAM % a_acf + 9 0. file_acf = 'out/gpl/acfy.txt' file_gpl = 'out/gpl/acfy.gpl' title = '\"ACF comparison along secondary axis Y\"' xlab = '\"Y\"' endif ! extract the ACF profile along a particular direction call profile_at_angle ( tab = PARAM % acf_surf ( 1 : w , 1 : h ), profile = profile_acf_surf ( 1 : ll ), theta = angle ) call profile_at_angle ( tab = PARAM % imp_acf ( 1 : w , 1 : h ), profile = profile_imp_acf ( 1 : ll ), theta = angle ) open ( uplot , file = trim ( file_acf )) write ( uplot , * ) 'X' , '\"calculated acf\"' , '\"theoretical acf\"' do i = 1 , ll write ( uplot , * ) ( i - ll / 2 ) * dxy , real ( profile_acf_surf ( i ), kind = R4 ), & ! real ( profile_imp_acf ( i ), kind = R4 ) ! if ( i - ll / 2 < 0 ) then if ( profile_acf_surf ( i ) < PARAM % acf__z . and . profile_acf_surf ( i + 1 ) > PARAM % acf__z ) l1 = ( i - ll / 2 ) * dxy endif if ( i - ll / 2 > 0 . and . i < ll ) then if ( profile_acf_surf ( i ) > PARAM % acf__z . and . profile_acf_surf ( i + 1 ) < PARAM % acf__z ) l2 = ( i - ll / 2 ) * dxy endif enddo close ( uplot ) open ( uplot , file = trim ( file_gpl )) write ( uplot , '(a)' ) 'set title ' // trim ( title ) write ( uplot , '(a)' ) 'set xlabel ' // trim ( xlab ) write ( uplot , '(a)' ) 'set ylabel \"ACF\"' write ( uplot , '(a,f4.2,a,f5.2,a)' ) \"set arrow from graph 0, first \" , PARAM % acf__z , & ! \" to graph 1, first \" , PARAM % acf__z , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2,a)' ) \"set arrow from \" , l1 , \", graph 0 to \" , & ! l1 , \",\" , PARAM % acf__z , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2,a)' ) \"set arrow from \" , l2 , \", graph 0 to \" , & ! l2 , \",\" , PARAM % acf__z , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2)' ) 'set label \"L1 = ' , res ( axis ), '\" at ' , l2 , ',' , PARAM % acf__z + 0.1 write ( uplot , '(a,i2,a)' ) 'plot \"' // trim ( file_acf ) // '\" using 1:2 with lines title \"acf real surface\", \"' // trim ( file_acf ) // '\" using 1:3 with lines title \"theoretical acf\"' write ( uplot , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( uplot , '(a)' ) 'q' close ( uplot ) call system ( 'gnuplot \"' // trim ( file_gpl ) // '\"' ) deallocate ( profile_acf_surf ) deallocate ( profile_imp_acf ) return endsubroutine graph subroutine profile_at_angle ( tab , profile , theta ) !================================================================================================ !<@note Function that extract the ACF profile along a particular direction !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: tab real ( kind = R8 ), intent ( in ) :: theta real ( kind = R8 ), intent ( out ), dimension ( 1 : ll ) :: profile integer ( kind = I4 ) :: p , nx , ny real ( kind = R8 ) :: r , x , y , xb , yb , xm , ym , xp , yp , h1 , h2 , h3 , h4 , hh do p = - ll / 2 , ll / 2 !  identifying a point on the diameter r = p !  corresponding algebraic radius !  projection on x and y of the point marked by its radius and angle !  by taking the lower integer, we have the number of the bottom row and left-hand column of the rectangle !  the remainder (x-nx) represents the abscissa of the point in the rectangle with sides=1 !  the 0.9999 coefficient is used to avoid falling right on an existing point x = mw + r * cos ( theta * PI_R8 / 180 ) * 0.9999_R8 ; nx = floor ( x ) ; xb = x - nx y = mh + r * sin ( theta * PI_R8 / 180 ) * 0.9999_R8 ; ny = floor ( y ) ; yb = y - ny xm = UN - xb ; xp = xb ym = UN - yb ; yp = yb if ( nx + 1 <= w . and . ny + 1 <= h . and . & ! nx >= 1 . and . ny >= 1 ) then ! attention r may be greater than lo2 or la2 h1 = tab ( nx , ny ) h2 = tab ( nx + 1 , ny ) h3 = tab ( nx + 1 , ny + 1 ) h4 = tab ( nx , ny + 1 ) hh = h1 * xm * ym + & ! h2 * xp * ym + & ! h3 * xp * yp + & ! h4 * xm * yp ! profile ( p + ll / 2 + 1 ) = hh endif enddo return endsubroutine profile_at_angle endsubroutine plt__acf","tags":"","loc":"proc/plt__acf.html"},{"title":"calc_acf – CREST","text":"private  subroutine calc_acf() Note Function that returns the autocorrelation function of a surface PARAM%acf_surf Arguments None Calls proc~~calc_acf~~CallsGraph proc~calc_acf calc_acf proc~acf_wiener acf_wiener proc~calc_acf->proc~acf_wiener calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_acf~~CalledByGraph proc~calc_acf calc_acf proc~read_job read_job proc~read_job->proc~calc_acf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_acf () !================================================================================================ !<@note Function that returns the autocorrelation function of a surface PARAM%acf_surf ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h w = PARAM % width h = PARAM % height call acf_wiener ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! IN tab_out = PARAM % acf_surf ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h ) ! IN return endsubroutine calc_acf","tags":"","loc":"proc/calc_acf.html"},{"title":"sta_loop – CREST","text":"private  subroutine sta_loop() Starting the loop Arguments None Called by proc~~sta_loop~~CalledByGraph proc~sta_loop sta_loop proc~read_job read_job proc~read_job->proc~sta_loop proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sta_loop () !! Starting the loop implicit none read ( JOB , * ) NB_ITER ; LINE_READ = LINE_READ + 1 write ( SPY , * ) LINE_READ , I_ITER , '/' , NB_ITER I_ITER = 1 ! the account begins SAVE_LINE_READ = LINE_READ ! remember where to go when rewinding return endsubroutine sta_loop","tags":"","loc":"proc/sta_loop.html"},{"title":"end_loop – CREST","text":"private  subroutine end_loop() The loop ends here Arguments None Called by proc~~end_loop~~CalledByGraph proc~end_loop end_loop proc~read_job read_job proc~read_job->proc~end_loop proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine end_loop () !! The loop ends here implicit none integer ( kind = I4 ) :: i_ligne if ( I_ITER < NB_ITER ) then rewind ( JOB ) ! the maximum number of loops is not reached, ! go to the begining of the script else I_ITER = NB_ITER ! the maximum number of loops is reached return endif ! return to the beginning of the loop LINE_READ = SAVE_LINE_READ do i_ligne = 1 , SAVE_LINE_READ read ( JOB , * ) enddo I_ITER = I_ITER + 1 return endsubroutine end_loop","tags":"","loc":"proc/end_loop.html"},{"title":"sub_surf – CREST","text":"private  subroutine sub_surf() Note Function that returns the best subsurface from the final surface. We are here because a non periodic resulting surface is required. To do that, a wider\n periodic surface is created, and it matches the required moments and acf. However, sub-sampling the surface into a smaller surface that matches the required size\n will result in degraded moments and acf. Hence, several locations are tested to find the\n best subsurface. Note that the right moments can always be obtained by substitution, respecting the order of heights.\n However, the acf will be slightly impacted. Arguments None Calls proc~~sub_surf~~CallsGraph proc~sub_surf sub_surf calc_moments calc_moments proc~sub_surf->calc_moments end_fftw3 end_fftw3 proc~sub_surf->end_fftw3 fftw_plan_with_nthreads fftw_plan_with_nthreads proc~sub_surf->fftw_plan_with_nthreads init_order init_order proc~sub_surf->init_order omp_get_max_threads omp_get_max_threads proc~sub_surf->omp_get_max_threads proc~acf_wiener acf_wiener proc~sub_surf->proc~acf_wiener proc~build_heights build_heights proc~sub_surf->proc~build_heights proc~calc_imp_acf calc_imp_acf proc~sub_surf->proc~calc_imp_acf proc~calc_res_acf calc_res_acf proc~sub_surf->proc~calc_res_acf progress_bar_terminal progress_bar_terminal proc~sub_surf->progress_bar_terminal sort_array2 sort_array2 proc~sub_surf->sort_array2 tab_end_fftw3_real tab_end_fftw3_real proc~sub_surf->tab_end_fftw3_real tab_init_fftw3_real tab_init_fftw3_real proc~sub_surf->tab_init_fftw3_real calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center proc~build_heights->calc_moments proc~build_heights->sort_array2 proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d proc~apod2 apod2 proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo init init proc~pikaia_skku_solver->init solve solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sub_surf~~CalledByGraph proc~sub_surf sub_surf proc~read_job read_job proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sub_surf () !================================================================================================ !<@note Function that returns the best subsurface from the final surface. ! ! We are here because a non periodic resulting surface is required. To do that, a wider ! periodic surface is created, and it matches the required moments and acf. ! ! However, sub-sampling the surface into a smaller surface that matches the required size ! will result in degraded moments and acf. Hence, several locations are tested to find the ! best subsurface. ! ! Note that the right moments can always be obtained by substitution, respecting the order of heights. ! However, the acf will be slightly impacted. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: i , w , h , l , we , he , dw , dh , ndw , ndh , idw , jdh , ib , ie , jb , je , best_idw , best_jdh integer ( kind = I4 ) :: n_seek , inc_dw , inc_dh , nn_res , res_ratio real ( kind = R8 ) :: best_acf , res_acf , size_ratio character ( len = 100 ) :: text type ( MOMENT_STAT ) :: m_res integer ( kind = I4 ), dimension ( 1 : 2 ) :: best_ind integer ( kind = I4 ), allocatable , dimension (:) :: order_tmp real ( kind = R8 ), allocatable , dimension (:,:) :: sav_surf , surf_tmp , acf_tmp , tab_res_acf real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp read ( JOB , * ) n_seek ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"n_seek  \" , n_seek ! n_seek is the number of subsurfaces explored if ( PARAM % periodic ) return ! reset the FFTW configuration because from now on, the acf will be calculated on smaller surfaces call end_fftw3 () ! extended surface size we = PARAM % width he = PARAM % height allocate ( sav_surf ( 1 : we , 1 : he ) ) ! save the extended surface sav_surf ( 1 : we , 1 : he ) = PARAM % surf ( 1 : we , 1 : he ) ! reset previous arrays deallocate ( PARAM % surf ) deallocate ( PARAM % imp_acf ) deallocate ( PARAM % acf_surf ) call fftw_plan_with_nthreads ( nthreads = 1 ) NB_THREADS_FFT = omp_get_max_threads () ! the new image size is the one of the subsurface, because it is the size defined by the user w = PARAM % sub_width h = PARAM % sub_height l = PARAM % sub_npts call tab_init_fftw3_real ( long = w , larg = h , plan_flag = FFTW_MEASURE ) PARAM % width = w PARAM % height = h PARAM % npts = l allocate ( PARAM % surf ( 1 : w , 1 : h ) ) allocate ( PARAM % acf_surf ( 1 : w , 1 : h ) ) ! build a smaller set of heights that match the required moments call build_heights ( vec_out = PARAM % vect_h ( 1 : l ), & ! use_fct_expo = ( PARAM % m_end % ku < 1.10 * PARAM % m_end % sk ** 2 + 1. ), & ! stats_in = PARAM % m_end , & ! lg = l ) ! allocate ( PARAM % imp_acf ( 1 : w , 1 : h ) ) ! recalculate the theoretical acf, for the new size surface call calc_imp_acf ( long = w , & ! IN larg = h , & ! IN apod = PARAM % apod , & ! IN tau1 = PARAM % l_acf1 , & ! IN tau2 = PARAM % l_acf2 , & ! IN alpha = log ( PARAM % acf__z ), & ! IN ang = PARAM % a_acf * PI_R8 / 180 , & ! IN tab_acf = PARAM % imp_acf ( 1 : w , 1 : h )) ! OUT ! difference between old and new size: hence, there will be dw*dh possible locations ! for the subsurface dw = we - w dh = he - h ! initialize the best acf result (mean absolute difference) and subsurface locations best_acf = 1.e6_R8 best_idw = 0 best_jdh = 0 size_ratio = dw / dh ! Number of locations along x and y. It respects the total number to be explored, as set ! by the user and the size ratio of the surface ndw = nint ( sqrt ( n_seek / size_ratio ) ) ndh = nint ( real ( n_seek , kind = R8 ) / ndw ) ! ndw and ndh are modified to be mumtiples of the number of threads, but the product ! should not be too far from n_seek if ( size_ratio > 1. ) then ndw = NB_THREADS_FFT * ( int ( ndw / NB_THREADS_FFT ) + 1 ) ndh = NB_THREADS_FFT * ( int ( ndh / NB_THREADS_FFT ) ) else ndw = NB_THREADS_FFT * ( int ( ndw / NB_THREADS_FFT ) ) ndh = NB_THREADS_FFT * ( int ( ndh / NB_THREADS_FFT ) + 1 ) endif ! don't exceed the maximums ndw = min ( ndw , dw ) ndh = min ( ndh , dh ) ! increments for looping inc_dw = dw / ndw inc_dh = dh / ndh ! result storage allocate ( tab_res_acf ( 1 : ndw , 1 : ndh ) ) tab_res_acf ( 1 : ndw , 1 : ndh ) = - 1 allocate ( surf_tmp ( 1 : w , 1 : h ) ) allocate ( acf_tmp ( 1 : w , 1 : h ) ) allocate ( order_tmp ( 1 : l ) ) allocate ( tab_tmp ( 1 : l ) ) call progress_bar_terminal ( val = 0 , max_val = ndw * ndh , init = . true .) !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_THREADS_FFT) !$OMP DO SCHEDULE (STATIC, ndw/NB_THREADS_FFT) PRIVATE(ib, ie, jb, je, jdh, surf_tmp, tab_tmp, order_tmp, acf_tmp, i, m_res, res_acf, nn_res, res_ratio, text) do idw = 1 , ndw ib = idw * inc_dw ie = ib + w - 1 do jdh = 1 , ndh jb = jdh * inc_dh je = jb + h - 1 surf_tmp ( 1 : w , 1 : h ) = sav_surf ( ib : ie , jb : je ) !....................................................................................... tab_tmp ( 1 : l ) = reshape ( surf_tmp ( 1 : w , 1 : h ), [ l ] ) ! store the subsurface height order call init_order ( order = order_tmp ( 1 : l ), & ! OUT n = l ) ! IN call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! INOUT tab0 = order_tmp ( 1 : l ), & ! INOUT n = l ) ! IN ! replace old heights with new ones that matches required moments do i = 1 , l tab_tmp ( order_tmp ( i ) ) = PARAM % vect_h ( i ) enddo surf_tmp ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call calc_moments ( tab = tab_tmp ( 1 : l ), & ! IN mx = m_res , & ! OUT nb_mom = 4 ) ! IN surf_tmp ( 1 : w , 1 : h ) = ( surf_tmp ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si !....................................................................................... ! calculate the acf call acf_wiener ( tab_in = surf_tmp ( 1 : w , 1 : h ), & ! IN tab_out = acf_tmp ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h , & ! IN multi_fft = . true . ) ! IN ! calculate the result (mean absolute difference between theoretical acf and calculated acf) call calc_res_acf ( acf_surf = acf_tmp ( 1 : w , 1 : h ), & ! IN imp_acf = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN acf__z = PARAM % acf__z , & ! IN crit_acf = res_acf , & ! OUT w = w , & ! IN h = h ) ! IN tab_res_acf ( idw , jdh ) = res_acf ! update progressbar !$OMP CRITICAL nn_res = count ( tab_res_acf > 0 ) call progress_bar_terminal ( val = nn_res , max_val = ndw * ndh , init = . false .) !$OMP END CRITICAL enddo enddo !$OMP END DO !$OMP END PARALLEL ! find the best subsurface best_ind ( 1 : 2 ) = minloc ( tab_res_acf ) idw = best_ind ( 1 ) jdh = best_ind ( 2 ) ib = idw * ( dw / ndw ) ie = ib + w - 1 jb = jdh * ( dh / ndh ) je = jb + h - 1 PARAM % surf ( 1 : w , 1 : h ) = sav_surf ( ib : ie , jb : je ) ! redo calculations on the best subsurface !....................................................................................... tab_tmp ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call init_order ( order = PARAM % order ( 1 : l ), & ! n = l ) ! call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! tab0 = PARAM % order ( 1 : l ), & ! n = l ) ! do i = 1 , l tab_tmp ( PARAM % order ( i ) ) = PARAM % vect_h ( i ) enddo PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call calc_moments ( tab = tab_tmp ( 1 : l ), & ! mx = m_res , & ! nb_mom = 4 ) ! PARAM % surf ( 1 : w , 1 : h ) = ( PARAM % surf ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si !....................................................................................... call tab_end_fftw3_real () deallocate ( sav_surf ) deallocate ( tab_tmp ) deallocate ( surf_tmp ) deallocate ( acf_tmp ) deallocate ( order_tmp ) deallocate ( tab_res_acf ) return endsubroutine sub_surf","tags":"","loc":"proc/sub_surf.html"},{"title":"calc_res_acf – CREST","text":"private  subroutine calc_res_acf(acf_surf, imp_acf, crit_acf, acf__z, w, h) Note Function that returns crit_acf the mean absolute difference between theoretical\n and calculated acfs Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:w, 1:h) :: acf_surf calculated surface acf real(kind=R8), intent(in), dimension(1:w, 1:h) :: imp_acf required surface acf real(kind=R8), intent(out) :: crit_acf mean absolute difference between theoretical and calculated acfs real(kind=R8), intent(in) :: acf__z plane elevation z where correlation lengths are calculated integer(kind=I4), intent(in) :: w surface acf width (points) integer(kind=I4), intent(in) :: h surface acf height (points) Called by proc~~calc_res_acf~~CalledByGraph proc~calc_res_acf calc_res_acf proc~sub_surf sub_surf proc~sub_surf->proc~calc_res_acf proc~read_job read_job proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_res_acf ( acf_surf , imp_acf , crit_acf , acf__z , w , h ) !================================================================================================ !<@note Function that returns *crit_acf* the mean absolute difference between theoretical ! and calculated acfs ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: w !! *surface acf width (points)* integer ( kind = I4 ), intent ( in ) :: h !! *surface acf height (points)* real ( kind = R8 ), intent ( in ) :: acf__z !! *plane elevation z where correlation lengths are calculated* real ( kind = R8 ), intent ( out ) :: crit_acf !! *mean absolute difference between theoretical and calculated acfs* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: acf_surf !! *calculated surface acf* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: imp_acf !! *required surface acf* real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp allocate ( tab_tmp ( 1 : w , 1 : h ) ) tab_tmp ( 1 : w , 1 : h ) = 0 where ( imp_acf > acf__z ) tab_tmp = abs ( acf_surf - imp_acf ) crit_acf = 100 * sum ( tab_tmp ( 1 : w , 1 : h ) ) / count ( tab_tmp ( 1 : w , 1 : h ) > 0 ) deallocate ( tab_tmp ) return endsubroutine calc_res_acf","tags":"","loc":"proc/calc_res_acf.html"},{"title":"save_img – CREST","text":"private  subroutine save_img(tab) Note Function that save an array tab as a digital surf file. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(:,:) :: tab a surface to save as a .sur file Calls proc~~save_img~~CallsGraph proc~save_img save_img init_scal init_scal proc~save_img->init_scal write_surf write_surf proc~save_img->write_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~save_img~~CalledByGraph proc~save_img save_img proc~read_job read_job proc~read_job->proc~save_img proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine save_img ( tab ) !================================================================================================ !<@note Function that save an array *tab* as a digital surf file. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension (:,:) :: tab !! *a surface to save as a .sur file* integer ( kind = I4 ) :: w ! image width integer ( kind = I4 ) :: h ! image height integer ( kind = I4 ), dimension ( 1 : 2 ) :: shape_tab character ( len = 512 ) :: nom_surf type ( SCALE_SURF ) :: scale_img shape_tab = shape ( tab ) w = shape_tab ( 1 ) h = shape_tab ( 2 ) nom_surf = repeat ( \" \" , len ( nom_surf ) ) read ( JOB , * ) nom_surf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , trim ( nom_surf ) call init_scal ( scal = scale_img , & ! out; creates a surface type, containing ... nx = w , & !  in; ... the number of points along x ... ny = h , & !  in; ... the number of points along y ... lx = PARAM % surf_width , & !  in; ... the length (default unit : m) ... ly = PARAM % surf_height , & !  in; ... the width ... unit_z = 'm' ) !  in; ... and the unit along z. call write_surf ( nom_fic = trim ( nom_surf ), & ! tab_s = tab ( 1 : w , 1 : h ), & ! scal = scale_img ) ! return endsubroutine save_img","tags":"","loc":"proc/save_img.html"},{"title":"smooth__ – CREST","text":"private  subroutine smooth__() Note Function that applies a low-pass filter to the surface PARAM%surf Arguments None Calls proc~~smooth__~~CallsGraph proc~smooth__ smooth__ calc_moments calc_moments proc~smooth__->calc_moments fft_filter fft_filter proc~smooth__->fft_filter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~smooth__~~CalledByGraph proc~smooth__ smooth__ proc~read_job read_job proc~read_job->proc~smooth__ proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine smooth__ () !================================================================================================ !<@note Function that applies a low-pass filter to the surface PARAM%surf ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp type ( MOMENT_STAT ) :: m_res real ( kind = R8 ) :: cutoff read ( JOB , * ) cutoff ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"cutoff \" , cutoff PARAM % cutoff = cutoff w = PARAM % width h = PARAM % height allocate ( tab_tmp ( 1 : w , 1 : h ) ) call fft_filter ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN cutoff = PARAM % cutoff , & ! IN bf_tab = tab_tmp ( 1 : w , 1 : h ), & ! OUT multi_fft = . false ., & ! IN pad = - 1._R8 , & ! IN ext = 'constant' ) ! IN call calc_moments ( tab = tab_tmp ( 1 : w , 1 : h ), & ! IN mx = m_res , & ! OUT nb_mom = 2 ) ! IN ! the surface has been modified, so recenter and rescale PARAM % surf ( 1 : w , 1 : h ) = ( tab_tmp ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si deallocate ( tab_tmp ) return endsubroutine smooth__","tags":"","loc":"proc/smooth__.html"},{"title":"calc_z_f – CREST","text":"private  subroutine calc_z_f(to_be_made) Note Function that returns PARAM%surf, the surface made of heights with the required statistical\n moments, in the right order. The heights come from the vector PARAM%vect_h the heights order is stored in the vector PARAM%order Arguments Type Intent Optional Attributes Name logical(kind=I4), intent(in) :: to_be_made whether to determine the heights, or reuse them Calls proc~~calc_z_f~~CallsGraph proc~calc_z_f calc_z_f calc_moments calc_moments proc~calc_z_f->calc_moments proc~build_heights build_heights proc~calc_z_f->proc~build_heights proc~build_heights->calc_moments proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d sort_array2 sort_array2 proc~build_heights->sort_array2 init init proc~pikaia_skku_solver->init solve solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_z_f~~CalledByGraph proc~calc_z_f calc_z_f proc~read_job read_job proc~read_job->proc~calc_z_f proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_z_f ( to_be_made ) !================================================================================================ !<@note Function that returns PARAM%surf, the surface made of heights with the required statistical ! moments, in the right order. ! ! - The heights come from the vector PARAM%vect_h ! - the heights order is stored in the vector PARAM%order ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none logical ( kind = I4 ), intent ( in ) :: to_be_made !! *whether to determine the heights, or reuse them* integer ( kind = I4 ) :: i integer ( kind = I4 ) :: w , h , l real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp type ( MOMENT_STAT ) :: m_res w = PARAM % width h = PARAM % height l = PARAM % npts ! final set of heights are generated to meet the desired statistical moments ! It is done once. if ( to_be_made ) then write ( SPY , * ) 'calc_z_f -> final set of heights are generated to meet the desired statistical moments' call build_heights ( vec_out = PARAM % vect_h ( 1 : l ), & ! OUT use_fct_expo = ( PARAM % m_end % ku < 1.10 * PARAM % m_end % sk ** 2 + 1. ), & ! IN stats_in = PARAM % m_end , & ! IN lg = l ) ! IN endif ! The heights stored in PARAM%vect_h(1:lg) are reinjected in PARAM%surf, with respect to the order PARAM%order write ( SPY , * ) 'calc_z_f -> substitution of PARAM%surf with PARAM%vect_h with respect to PARAM%order' allocate ( tab_tmp ( 1 : l ) ) do i = 1 , l tab_tmp ( PARAM % order ( i ) ) = PARAM % vect_h ( i ) enddo PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call calc_moments ( tab = tab_tmp ( 1 : l ), & ! IN mx = m_res , & ! OUT nb_mom = 2 ) ! IN PARAM % surf ( 1 : w , 1 : h ) = ( PARAM % surf ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si deallocate ( tab_tmp ) return endsubroutine calc_z_f","tags":"","loc":"proc/calc_z_f.html"},{"title":"calc_ord – CREST","text":"private  subroutine calc_ord() Note Function that returns the vector PARAM%order that contains the heights order. Arguments None Calls proc~~calc_ord~~CallsGraph proc~calc_ord calc_ord init_order init_order proc~calc_ord->init_order sort_array2 sort_array2 proc~calc_ord->sort_array2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_ord~~CalledByGraph proc~calc_ord calc_ord proc~read_job read_job proc~read_job->proc~calc_ord proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_ord () !================================================================================================ !<@note Function that returns the vector PARAM%order that contains the heights order. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: l , w , h real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( tab_tmp ( 1 : l ) ) tab_tmp ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call init_order ( order = PARAM % order ( 1 : l ), & ! OUT n = l ) ! IN call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! IN tab0 = PARAM % order ( 1 : l ), & ! OUT n = l ) ! IN deallocate ( tab_tmp ) return endsubroutine calc_ord","tags":"","loc":"proc/calc_ord.html"},{"title":"digi_fil – CREST","text":"private  subroutine digi_fil() Note Function that applies the digital filter to the random heights Arguments None Calls proc~~digi_fil~~CallsGraph proc~digi_fil digi_fil calc_fftw3_real_bwd calc_fftw3_real_bwd proc~digi_fil->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~digi_fil->calc_fftw3_real_fwd calc_moments calc_moments proc~digi_fil->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~digi_fil~~CalledByGraph proc~digi_fil digi_fil proc~read_job read_job proc~read_job->proc~digi_fil proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine digi_fil () !================================================================================================ !<@note Function that applies the digital filter to the random heights ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h complex ( kind = R8 ), dimension (:,:), allocatable :: cmple complex ( kind = R8 ), dimension (:,:), allocatable :: ftab ! FFT(tab_prf) type ( MOMENT_STAT ) :: m_res write ( SPY , * ) 'digi_fil -> 1 - extends then windows PARAM%surf to calculate its FFT ftab' write ( SPY , * ) 'digi_fil -> 2 - multiplies ftab and the digital filter PARAM%fhi, then FFT-1' write ( SPY , * ) 'digi_fil -> 3 - retrieves PARAM%surf by removing the padded extension' w = PARAM % width h = PARAM % height allocate ( cmple ( 1 : w , 1 : h ) ) ! allocate ( ftab ( 1 : w , 1 : h ) ) ! cmple ( 1 : w , 1 : h ) = cmplx ( PARAM % surf ( 1 : w , 1 : h ), 0 , kind = R8 ) call calc_fftw3_real_fwd ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! IN tab_ou = cmple ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN ftab ( 1 : w , 1 : h ) = cmple ( 1 : w , 1 : h ) where ( abs ( cmple ( 1 : w , 1 : h )) > 100 * EPS_R8 ) ftab ( 1 : w , 1 : h ) = cmple ( 1 : w , 1 : h ) / abs ( cmple ( 1 : w , 1 : h ) ) elsewhere ftab ( 1 : w , 1 : h ) = cmplx ( UN , 0._R8 , kind = R8 ) endwhere write ( SPY , * ) 'ftab normalized' !-------------------------------------------------------------------- ! FFT of the filter * FFT of the random heights !-------------------------------------------------------------------- cmple ( 1 : w , 1 : h ) = PARAM % fhi ( 1 : w , 1 : h ) * ftab ( 1 : w , 1 : h ) call calc_fftw3_real_bwd ( tab_in = cmple ( 1 : w , 1 : h ), & ! IN tab_ou = PARAM % surf ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN ! signal centré et normé call calc_moments ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN mx = m_res , & ! OUT nb_mom = 4 ) ! IN PARAM % surf ( 1 : w , 1 : h ) = ( PARAM % surf ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si write ( SPY , * ) 'sk ku fin ' , m_res % sk , m_res % ku deallocate ( cmple ) deallocate ( ftab ) return endsubroutine digi_fil","tags":"","loc":"proc/digi_fil.html"},{"title":"calc_z_i – CREST","text":"private  subroutine calc_z_i() Note Function that returns the starting surface of random heights Arguments None Calls proc~~calc_z_i~~CallsGraph proc~calc_z_i calc_z_i calc_moments calc_moments proc~calc_z_i->calc_moments proc~build_heights build_heights proc~calc_z_i->proc~build_heights scramble scramble proc~calc_z_i->scramble proc~build_heights->calc_moments proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d sort_array2 sort_array2 proc~build_heights->sort_array2 init init proc~pikaia_skku_solver->init solve solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_z_i~~CalledByGraph proc~calc_z_i calc_z_i proc~read_job read_job proc~read_job->proc~calc_z_i proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_z_i () !================================================================================================ !<@note Function that returns the starting surface of random heights ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp type ( MOMENT_STAT ) :: m_res w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( tab_tmp ( 1 : l ) ) ! starting set of heights are generated to meet the statistical moments prescribed by calc_ffh write ( SPY , * ) 'calc_z_i -> starting set of heights are generated to meet the prescribed statistical moments by calc_ffh' call build_heights ( vec_out = tab_tmp ( 1 : l ), & ! OUT use_fct_expo = ( PARAM % m_stt % ku < 1.34 * PARAM % m_stt % sk ** 2 + 1. ), & ! IN stats_in = PARAM % m_stt , & ! IN lg = l ) ! IN call calc_moments ( tab = tab_tmp ( 1 : l ), & ! IN mx = m_res , & ! OUT nb_mom = 4 ) ! IN write ( TER , * ) 'starting statistical moments ' , m_res % mu , m_res % va , m_res % sk , m_res % ku tab_tmp ( 1 : l ) = ( tab_tmp ( 1 : l ) - m_res % mu ) / m_res % si call scramble ( tab = tab_tmp ( 1 : l ), & ! INOUT lg = l ) ! IN PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) deallocate ( tab_tmp ) return endsubroutine calc_z_i","tags":"","loc":"proc/calc_z_i.html"},{"title":"calc_ffh – CREST","text":"private  subroutine calc_ffh(calc_m_stt) Note Function that returns … the digital filter to apply to the height distribution the starting statistical moments PARAM%m_stt%sk, PARAM%m_stt%ku whether the exponential function will be used, PARAM%reajust_skku Arguments Type Intent Optional Attributes Name logical(kind=I4), intent(inout) :: calc_m_stt compute starting moments ? Calls proc~~calc_ffh~~CallsGraph proc~calc_ffh calc_ffh calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_ffh->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_ffh->calc_fftw3_real_fwd calc_moments calc_moments proc~calc_ffh->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_ffh~~CalledByGraph proc~calc_ffh calc_ffh proc~read_job read_job proc~read_job->proc~calc_ffh proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_ffh ( calc_m_stt ) !================================================================================================ !<@note Function that returns ... ! ! - the digital filter to apply to the height distribution  \\text{PARAM%fhi} = \\sqrt{ \\left| FFT(\\text{PARAM%imp_acf}) \\right| }  ! - the starting statistical moments PARAM%m_stt%sk, PARAM%m_stt%ku ! - whether the exponential function will be used, PARAM%reajust_skku ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none logical ( kind = I4 ), intent ( inout ) :: calc_m_stt !! *compute starting moments ?* integer ( kind = I4 ) :: w , h , l complex ( kind = R8 ), dimension (:,:), allocatable :: cmple real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp type ( MOMENT_STAT ) :: m_h w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( cmple ( 1 : w , 1 : h ) ) write ( SPY , * ) 'calc_ffh -> PARAM%fhi = sqrt( abs( FFT(PARAM%imp_acf) ) )' call calc_fftw3_real_fwd ( tab_in = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN tab_ou = cmple ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN PARAM % fhi ( 1 : w , 1 : h ) = sqrt ( abs ( cmple ( 1 : w , 1 : h ) ) ) if ( calc_m_stt ) then ! determine starting statistical moments, if not already done !....................................................................... write ( SPY , * ) 'calc_ffh -> PARAM%m_stt calculated' cmple ( 1 : w , 1 : h ) = cmplx ( PARAM % fhi ( 1 : w , 1 : h ), 0 , kind = R8 ) allocate ( tab_tmp ( 1 : w , 1 : h ) ) call calc_fftw3_real_bwd ( tab_in = cmple ( 1 : w , 1 : h ), & ! IN tab_ou = tab_tmp ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN call calc_moments ( tab = tab_tmp ( 1 : w , 1 : h ), & ! IN mx = m_h , & ! OUT nb_mom = 4 ) ! IN PARAM % m_stt % mu = 0 PARAM % m_stt % va = 1 PARAM % m_end % mu = 0 PARAM % m_end % va = m_h % va PARAM % m_stt % sk = sqrt ( UN * l ) * PARAM % m_end % sk / m_h % sk PARAM % m_stt % ku = l * ( PARAM % m_end % ku - 3. ) / ( m_h % ku - 3. ) + 3. PARAM % reajust_skku = . false . if ( PARAM % m_stt % ku < PARAM % m_stt % sk ** 2 + 1. ) then PARAM % m_stt % ku = PARAM % m_stt % sk ** 2 + 1. PARAM % reajust_skku = . true . endif deallocate ( tab_tmp ) !....................................................................... else write ( SPY , * ) 'calc_ffh -> PARAM%m_stt NOT calculated, set to PARAM%m_end' PARAM % m_stt % sk = PARAM % m_end % sk PARAM % m_stt % ku = PARAM % m_end % ku endif deallocate ( cmple ) return endsubroutine calc_ffh","tags":"","loc":"proc/calc_ffh.html"},{"title":"sta_scri – CREST","text":"private  subroutine sta_scri() Start the script reading Arguments None Calls proc~~sta_scri~~CallsGraph proc~sta_scri sta_scri random_init random_init proc~sta_scri->random_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sta_scri~~CalledByGraph proc~sta_scri sta_scri proc~read_job read_job proc~read_job->proc~sta_scri proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sta_scri () !! Start the script reading implicit none ! Initializes the state of the pseudorandom number generator used by RANDOM_NUMBER. call random_init ( repeatable = . false ., image_distinct = . true .) return endsubroutine sta_scri","tags":"","loc":"proc/sta_scri.html"},{"title":"def_size – CREST","text":"private  subroutine def_size() Geometrical characteristics of the numerical surface Arguments None Called by proc~~def_size~~CalledByGraph proc~def_size def_size proc~read_job read_job proc~read_job->proc~def_size proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine def_size () !! Geometrical characteristics of the numerical surface implicit none integer ( kind = I4 ) :: w , h logical ( kind = I4 ) :: period real ( kind = R8 ) :: lw , lh read ( JOB , * ) w , h ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"width, height  \" , w , h read ( JOB , * ) lw , lh ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"img width and height (m) \" , lw , lh read ( JOB , * ) period ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"periodic surface? \" , period PARAM % periodic = period PARAM % width = w PARAM % height = h PARAM % npts = w * h PARAM % surf_width = lw PARAM % surf_height = lh PARAM % surf_dx = lw / w PARAM % surf_dy = lh / h return endsubroutine def_size","tags":"","loc":"proc/def_size.html"},{"title":"acf_theo – CREST","text":"private  subroutine acf_theo() Note Function that returns the theoretical acf PARAM%imp_acf. If the surface to generate is non periodic, the starting surface is extended. The final surface\n will be a part of it. Indeed the extended surface will be periodic, because the use of FFTs.\n If a roughness orientation is chosen, in addition with long correlation lengths, a windowing\n should be applied to the acf to prevent from artifacts (vertical and horizontal lines) Arguments None Calls proc~~acf_theo~~CallsGraph proc~acf_theo acf_theo ellipse_acf ellipse_acf proc~acf_theo->ellipse_acf proc~calc_imp_acf calc_imp_acf proc~acf_theo->proc~calc_imp_acf proc~apod2 apod2 proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~acf_theo~~CalledByGraph proc~acf_theo acf_theo proc~read_job read_job proc~read_job->proc~acf_theo proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine acf_theo () !================================================================================================ !<@note Function that returns the theoretical acf PARAM%imp_acf. ! ! If the surface to generate is non periodic, the starting surface is extended. The final surface ! will be a part of it. Indeed the extended surface will be periodic, because the use of FFTs. ! If a roughness orientation is chosen, in addition with long correlation lengths, a windowing ! should be applied to the acf to prevent from artifacts (vertical and horizontal lines) ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h logical ( kind = I4 ) :: with_apod real ( kind = R8 ) :: ratio , a , b , c , s , lx , ly real ( kind = R8 ), dimension ( 1 : 8 ) :: res read ( JOB , * ) PARAM % l_acf1 , PARAM % l_acf2 , PARAM % acf__z ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"l_acf \" , PARAM % l_acf1 , PARAM % l_acf2 , PARAM % acf__z if ( PARAM % l_acf1 < PARAM % l_acf2 ) stop \"inverser l_acf1, l_acf2\" read ( JOB , * ) PARAM % a_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"a_acf \" , PARAM % a_acf write ( SPY , * ) 'acf_theo -> determines the theoretical acf with a padded size, so correlation lengths are adjusted accordingly' read ( JOB , * ) with_apod ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"apod \" , with_apod PARAM % apod = with_apod w = PARAM % width h = PARAM % height if ( . not . PARAM % periodic ) then PARAM % sub_width = w PARAM % sub_height = h PARAM % sub_npts = w * h PARAM % sub_surf_width = PARAM % surf_width PARAM % sub_surf_height = PARAM % surf_height ! the surface must be extended a = PARAM % l_acf1 b = PARAM % l_acf2 c = cos ( PARAM % a_acf * PI_R8 / 180 ) s = sin ( PARAM % a_acf * PI_R8 / 180 ) lx = sqrt ( ( a * c ) ** 2 + ( b * s ) ** 2 ) ly = sqrt ( ( a * s ) ** 2 + ( b * c ) ** 2 ) w = w + nint ( lx / PARAM % surf_dx ) h = h + nint ( ly / PARAM % surf_dy ) ! update sizes PARAM % width = w PARAM % height = h PARAM % npts = w * h PARAM % surf_width = w * PARAM % surf_dx PARAM % surf_height = h * PARAM % surf_dy endif allocate ( PARAM % surf ( 1 : w , 1 : h ) ) allocate ( PARAM % fhi ( 1 : w , 1 : h ) ) allocate ( PARAM % imp_acf ( 1 : w , 1 : h ) ) allocate ( PARAM % order ( 1 : w * h ) ) allocate ( PARAM % vect_h ( 1 : w * h ) ) allocate ( PARAM % acf_surf ( 1 : w , 1 : h ) ) ratio = PARAM % l_acf2 / PARAM % l_acf1 ! acf_theo is the theoretical acf for the normal surface call calc_imp_acf ( long = w , & ! IN larg = h , & ! IN apod = with_apod , & ! IN tau1 = PARAM % l_acf1 , & ! IN tau2 = PARAM % l_acf2 , & ! IN alpha = log ( PARAM % acf__z ), & ! IN ang = PARAM % a_acf * PI_R8 / 180 , & ! IN tab_acf = PARAM % imp_acf ( 1 : w , 1 : h )) ! OUT call ellipse_acf ( tabin = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN p_acv = res ( 1 : 8 ), & ! OUT cut = PARAM % acf__z , & ! IN scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN omp = . true . ) ! IN return endsubroutine acf_theo","tags":"","loc":"proc/acf_theo.html"},{"title":"nb_procs – CREST","text":"private  subroutine nb_procs() Number of concurrent threads Arguments None Calls proc~~nb_procs~~CallsGraph proc~nb_procs nb_procs omp_get_num_procs omp_get_num_procs proc~nb_procs->omp_get_num_procs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nb_procs~~CalledByGraph proc~nb_procs nb_procs proc~read_job read_job proc~read_job->proc~nb_procs proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine nb_procs () !! Number of concurrent threads implicit none integer ( kind = I4 ) :: nb_th read ( JOB , * ) nb_th ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , 'nb_procs' , nb_th select case ( nb_th ) case ( 0 ) ! no multihreading PARAM % nb_threads = 1 NB_THREADS_FFT = 1 case ( - 1 ) ! determined by system PARAM % nb_threads = omp_get_num_procs () NB_THREADS_FFT = PARAM % nb_threads case default stop 'Bad choice \"nb_procs\" in \"mod_script\"' endselect return endsubroutine nb_procs","tags":"","loc":"proc/nb_procs.html"},{"title":"sta_theo – CREST","text":"private  subroutine sta_theo() Required statistical moments Arguments None Called by proc~~sta_theo~~CalledByGraph proc~sta_theo sta_theo proc~read_job read_job proc~read_job->proc~sta_theo proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sta_theo () !! Required statistical moments implicit none read ( JOB , * ) PARAM % m_end % sk , PARAM % m_end % ku ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"m_end \" , PARAM % m_end % sk , PARAM % m_end % ku return endsubroutine sta_theo","tags":"","loc":"proc/sta_theo.html"},{"title":"end_scri – CREST","text":"private  subroutine end_scri() End of script Arguments None Calls proc~~end_scri~~CallsGraph proc~end_scri end_scri end_fftw3 end_fftw3 proc~end_scri->end_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~end_scri~~CalledByGraph proc~end_scri end_scri proc~read_job read_job proc~read_job->proc~end_scri proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine end_scri () !! End of script implicit none close ( SPY ) if ( allocated ( PARAM % imp_acf ) ) deallocate ( PARAM % imp_acf ) if ( allocated ( PARAM % acf_surf ) ) deallocate ( PARAM % acf_surf ) if ( allocated ( PARAM % surf ) ) deallocate ( PARAM % surf ) if ( allocated ( PARAM % vect_h ) ) deallocate ( PARAM % vect_h ) if ( allocated ( PARAM % fhi ) ) deallocate ( PARAM % fhi ) if ( allocated ( PARAM % order ) ) deallocate ( PARAM % order ) call end_fftw3 () return endsubroutine end_scri","tags":"","loc":"proc/end_scri.html"},{"title":"crest_param – CREST","text":"Global variables and types Uses data_arch stat_mom pikaia_oop module~~crest_param~~UsesGraph module~crest_param crest_param data_arch data_arch module~crest_param->data_arch pikaia_oop pikaia_oop module~crest_param->pikaia_oop stat_mom stat_mom module~crest_param->stat_mom Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~crest_param~~UsedByGraph module~crest_param crest_param module~func_acf func_acf module~func_acf->module~crest_param module~script script module~script->module~crest_param module~script->module~func_acf module~skku_profiles skku_profiles module~script->module~skku_profiles module~skku_profiles->module~crest_param program~main main program~main->module~crest_param program~main->module~script Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=I4), public :: JOB JOB file: script integer(kind=I4), public :: SPY SPY file integer(kind=I4), public, parameter :: TER = 6 terminal output type( param_crest ), public :: PARAM integer(kind=I4), public, parameter :: FCT_TANG = 1 tangent function for height generation integer(kind=I4), public, parameter :: FCT_EXPO = 2 exponential function for height generation Derived Types type, public :: param_crest Components Type Visibility Attributes Name Initial real(kind=R8), public, allocatable, dimension(:) :: vect_h vector used to store the heights that meet the stat moments real(kind=R8), public, allocatable, dimension(:,:) :: surf surface array real(kind=R8), public, allocatable, dimension(:,:) :: imp_acf imposed autocorrelation real(kind=R8), public, allocatable, dimension(:,:) :: fhi digital filter real(kind=R8), public, allocatable, dimension(:,:) :: acf_surf calculated autocorrelation integer(kind=I4), public, allocatable, dimension(:) :: order vector that stores heights order type(MOMENT_STAT), public :: m_end final stat moments type(MOMENT_STAT), public :: m_inp input stat moments for genetic algo optimizer type(MOMENT_STAT), public :: m_stt starting stat moments type(pikaia_class), public :: pik_class PIKAIA class instanciation integer(kind=I4), public :: func_gen mathematical function used to generate the heights integer(kind=I4), public :: nparam number of parameters for the mathematical function integer(kind=I4), public :: nb_threads number of concurrent threads integer(kind=I4), public :: width surface nb points along x integer(kind=I4), public :: height surface nb points along y integer(kind=I4), public :: npts surface nb points integer(kind=I4), public :: sub_width subsurface nb points along x integer(kind=I4), public :: sub_height subsurface nb points along y integer(kind=I4), public :: sub_npts subsurface nb points logical(kind=I4), public :: reajust_skku if Ssk 2 +1 > Sku, modify Sku logical(kind=I4), public :: periodic is the surface periodic? logical(kind=I4), public :: apod apodize imposed acf? real(kind=R8), public :: l_acf1 correlation principal length at z=acf__z real(kind=R8), public :: l_acf2 correlation secondary length at z=acf__z real(kind=R8), public :: acf__z acf cutting plane z, for correlation lengths determination real(kind=R8), public :: a_acf roughness orientation real(kind=R8), public :: cutoff Gaussian filter cutoff real(kind=R8), public :: surf_width surface width (m) real(kind=R8), public :: surf_height surface height (m) real(kind=R8), public :: sub_surf_width subsurface width (m) real(kind=R8), public :: sub_surf_height subsurface height (m) real(kind=R8), public :: surf_dx surface increment along x (m) real(kind=R8), public :: surf_dy surface increment along y (m) real(kind=R8), public :: crt_acf acf criterion: mean absolute difference between imposed and calculated acf allowed real(kind=R8), public :: res_acf store mean absolute difference between imposed and calculated acf","tags":"","loc":"module/crest_param.html"},{"title":"skku_profiles – CREST","text":"Routines to generate a (Sk, Ku) series Principle If one wishes to analytically generate a height series with the given statistical moments Sk and Ku, a means is to transform a Gaussian series with Johnson’s Translation System .\nBut an alternative means is to use the tangent function: in most of industrial cases, the surface heights can be fitted with a tangent function which limits are the parameters it’s possible to cover a large (Sk, Ku) domain with these 2 parameters: the starting point and the ending point of the tangent height series. close to generates deep pits, and close to generates high pics. the four first statistical moments can be analytically determined, as functions of and the four first statistical moments can be linked to the analytical expressions so that the calculus are very fast an optimization process is used to choose the tangent limits when Sk and Ku are given. The i surface height is expressed as: with and .\nAs explained above the limits are and Statistical moments Transformation of a data set sum into an integral The use of an analytical representation of the heights is of limited interest if the sums, as expressed above, cannot be avoided\nbecause it becomes time consuming for large . So, how will be the statistical moments calculated in a discrete problem? … recalling that Simpson’s method involves such sums and that it links it to the function integral. NB : it is considered that is an even number, so It can be deduced from the figure: As for the borders: As a result: therefore: Extension A formula that links the mean of a sum to a function integral has been determined.\nThe same goes for the standard deviation which is the mean of the sum of squares. The same process applies therefore to the four statistical moments, provided\nthat one is able to analytically determine the integrals (Maxima and Mathematica are useful tools). mu is calculated as explained above when va is calculated, is replaced by with si=1 when Sk is calculated, is replaced by when Ku is calculated, is replaced by Uses crest_param data_arch sort_arrays stat_mom pikaia_oop module~~skku_profiles~~UsesGraph module~skku_profiles skku_profiles data_arch data_arch module~skku_profiles->data_arch module~crest_param crest_param module~skku_profiles->module~crest_param pikaia_oop pikaia_oop module~skku_profiles->pikaia_oop sort_arrays sort_arrays module~skku_profiles->sort_arrays stat_mom stat_mom module~skku_profiles->stat_mom module~crest_param->data_arch module~crest_param->pikaia_oop module~crest_param->stat_mom Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~skku_profiles~~UsedByGraph module~skku_profiles skku_profiles module~script script module~script->module~skku_profiles program~main main program~main->module~script Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function fitness_skku_anal (n, x) Generic cost function: difference between the imposed statistical moments and those\n obtained. The optimization problem must be turned into a maximization problem (as often\n in the optimization routines). Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n number of unknowns real(kind=R8), intent(in), dimension(1:n) :: x vector of unknowns Return Value real(kind=r8) private  function add_tang (n, deb, fin, alp, bet, mu, si) Function that adds to the series mean the border integrals as explained in the docs Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku integer(kind=I4), intent(in) :: deb first integration point integer(kind=I4), intent(in) :: fin last integration point real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) private  function add_expo (n, deb, fin, alp, bet, mu, si) Function that adds to the series mean the border integrals as explained in the modules\n presentation. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku integer(kind=I4), intent(in) :: deb first integration point integer(kind=I4), intent(in) :: fin last integration point real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) private  function tang (xi, n, alp, bet, mu, si) Profile function based on the tangent function Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi abscissa integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) private  function expo (xi, n, alp, bet, mu, si) Profile function based on the exponential function Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi abscissa integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) Subroutines public  subroutine build_heights (vec_out, use_fct_expo, stats_in, lg) Function that returns a set of heights that matches desired statistical moments. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:lg) :: vec_out height vector logical(kind=I4), intent(in) :: use_fct_expo should exponential function rather than tangent function be used? type(MOMENT_STAT), intent(in) :: stats_in input statistical moments integer(kind=I4), intent(in) :: lg length of the height vector private  subroutine cost_func_skku (me, x, f) Quantify de distance between desired moments and calculated moments Arguments Type Intent Optional Attributes Name class(pikaia_class), intent(inout) :: me real(kind=R8), intent(in), dimension(:) :: x real(kind=R8), intent(out) :: f private  subroutine pikaia_skku_solver (pik_class, step, xl, xu, nparam, cost, istat, f, xx) This is a refactoring of the PIKAIA unconstrained optimization code from the High Altitude Observatory.\n The original code is public domain and was written by Paul Charbonneau & Barry Knapp. Read more… Arguments Type Intent Optional Attributes Name type(pikaia_class), intent(inout) :: pik_class PIKAIA class instanciation character(len=4), intent(in) :: step init or solv real(kind=R8), intent(in), dimension(1:nparam) :: xl lower bonds of xx real(kind=R8), intent(in), dimension(1:nparam) :: xu upper bonds of xx integer(kind=I4), intent(in) :: nparam number of parameters private  subroutine cost(me, x, f) Arguments Type Intent Optional Attributes Name class(pikaia_class), intent(inout) :: me real(kind=R8), intent(in), dimension(:) :: x real(kind=R8), intent(out) :: f integer(kind=I4), intent(out) :: istat real(kind=R8), intent(out) :: f real(kind=R8), intent(out), dimension(1:nparam) :: xx chromosom for PIKAIA private  subroutine calculs_skku_tan (bounds, lg, ssk, sku) Function to calculate the skewness and kurtosis of a tangent series Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: bounds defines the function limits [-pi/2.(1-bounds(1)), +pi/2.(1-bounds(2)] integer(kind=I4), intent(in) :: lg vec size real(kind=R8), intent(out) :: ssk theoretical Ssk real(kind=R8), intent(out) :: sku theoretical Sku private  subroutine calculs_skku_exp (bounds, lg, ssk, sku) Function to calculate the skewness and kurtosis of an exponential series. The principle is the same as calculs_skku_tan , however it fits better some particular\n series quite binary (roughly two heights). Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: bounds interval limits [-(1/bounds(1)-1), +(1/bounds(2)-1)] integer(kind=I4), intent(in) :: lg vec size real(kind=R8), intent(out) :: ssk theoretical Ssk real(kind=R8), intent(out) :: sku theoretical Sku public  subroutine calculs_skku_generique (bounds, lg, ssk, sku) Function that calls the right series generator. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(:) :: bounds interval limits integer(kind=I4), intent(in) :: lg vec size real(kind=R8), intent(out) :: ssk theoretical Ssk real(kind=R8), intent(out) :: sku theoretical Sku private  subroutine profil_theo_trie_1D (tab, lg, x, mx) Function that generates the heights when the function limits have been determined. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:lg) :: tab height vector integer(kind=I4), intent(in) :: lg height vector size real(kind=R8), intent(in), dimension( :  ) :: x unknowns: height function limits type(MOMENT_STAT), intent(out) :: mx resulting statistical moments","tags":"","loc":"module/skku_profiles.html"},{"title":"func_acf – CREST","text":"Routines for acf calculations Uses crest_param data_arch fftw3 miscellaneous stat_mom module~~func_acf~~UsesGraph module~func_acf func_acf data_arch data_arch module~func_acf->data_arch fftw3 fftw3 module~func_acf->fftw3 miscellaneous miscellaneous module~func_acf->miscellaneous module~crest_param crest_param module~func_acf->module~crest_param stat_mom stat_mom module~func_acf->stat_mom module~crest_param->data_arch module~crest_param->stat_mom pikaia_oop pikaia_oop module~crest_param->pikaia_oop Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~func_acf~~UsedByGraph module~func_acf func_acf module~script script module~script->module~func_acf program~main main program~main->module~script Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function autocov_impo (xi, xj, tau1, tau2, alpha, ang) Function that returns Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi coordinate real(kind=R8), intent(in) :: xj coordinate real(kind=R8), intent(in) :: tau1 correlation length along real(kind=R8), intent(in) :: tau2 correlation length along real(kind=R8), intent(in) :: alpha log(z) where z is often 0.2 real(kind=R8), intent(in) :: ang angle (rad) Return Value real(kind=r8) Subroutines public  subroutine acf_wiener (tab_in, tab_out, w, h, multi_fft) Function that returns the acf of an array. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:w, 1:h) :: tab_in input array real(kind=R8), intent(out), dimension(1:w, 1:h) :: tab_out acf of the input array integer(kind=I4), intent(in) :: w 2D array length integer(kind=I4), intent(in) :: h 2D array width logical(kind=I4), intent(in), optional :: multi_fft run parallel acfs? public  subroutine calc_imp_acf (long, larg, tau1, tau2, alpha, ang, tab_acf, apod) Function that returns the theoretical autocorrelation function in an array. The autocorrelation function is supposed to be obtained from a real surface which must be periodic\n or nearly periodic (because of the use of FFTs).\n In addition, the surface is supposed to be 0 mean and normalized ( ),\n therefore acf is zero-mean and normalized so that its max value is 1. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long surface acf width integer(kind=I4), intent(in) :: larg surface acf height real(kind=R8), intent(in) :: tau1 first correlation length real(kind=R8), intent(in) :: tau2 surface second correlation length real(kind=R8), intent(in) :: alpha parameter that controls the expondential decrease real(kind=R8), intent(in) :: ang acf ellipsis angle real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_acf resulting acf logical(kind=I4), intent(in) :: apod apodization? private  subroutine apod2 (tab_in, tab_out, long, larg, tau1, tau2, ang) Function that returns an apodized array. To prevent gaps from appearing after FFT (because of non periodic waves), the surface must\n be transformed, but not too much. Here a modified Tukey window is determined. The starting\n surface is not modified below the “correlation lengths”. Above the correlation lengths, a\n smooth decrease is forced with a cosine squared. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in input acf real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out apodized acf integer(kind=I4), intent(in) :: long surface acf length integer(kind=I4), intent(in) :: larg surface acf width real(kind=R8), intent(in) :: tau1 surface first correlation length real(kind=R8), intent(in) :: tau2 surface second correlation length real(kind=R8), intent(in) :: ang ellipsis angle","tags":"","loc":"module/func_acf.html"},{"title":"script – CREST","text":"Routines to decode the script Uses filter surfile gnufor files func_acf skku_profiles crest_param data_arch sort_arrays fftw3 anisotropy miscellaneous stat_mom pikaia_oop module~~script~~UsesGraph module~script script anisotropy anisotropy module~script->anisotropy data_arch data_arch module~script->data_arch fftw3 fftw3 module~script->fftw3 files files module~script->files filter filter module~script->filter gnufor gnufor module~script->gnufor miscellaneous miscellaneous module~script->miscellaneous module~crest_param crest_param module~script->module~crest_param module~func_acf func_acf module~script->module~func_acf module~skku_profiles skku_profiles module~script->module~skku_profiles pikaia_oop pikaia_oop module~script->pikaia_oop sort_arrays sort_arrays module~script->sort_arrays stat_mom stat_mom module~script->stat_mom surfile surfile module~script->surfile module~crest_param->data_arch module~crest_param->pikaia_oop module~crest_param->stat_mom module~func_acf->data_arch module~func_acf->fftw3 module~func_acf->miscellaneous module~func_acf->module~crest_param module~func_acf->stat_mom module~skku_profiles->data_arch module~skku_profiles->module~crest_param module~skku_profiles->pikaia_oop module~skku_profiles->sort_arrays module~skku_profiles->stat_mom Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~script~~UsedByGraph module~script script program~main main program~main->module~script Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=I4), public :: LINE_READ integer(kind=I4), public :: SAVE_LINE_READ integer(kind=I4), public :: I_ITER integer(kind=I4), public :: NB_ITER Subroutines public  subroutine read_job (job_file) Function that reads a script file. Keywords are identified and corresponding actions are\n triggered. Read more… Arguments Type Intent Optional Attributes Name character(len=512), intent(in) :: job_file job file with macros to execute private  subroutine plt__acf () Function that calculates the mean absolute difference between the desired Acf and\n the one obtained.\n However, the important zone where both should match is above acf__z - where the correlation\n lengths are determined. Read more… Arguments None private  subroutine calc_acf () Function that returns the autocorrelation function of a surface PARAM%acf_surf Read more… Arguments None private  subroutine sta_loop () Starting the loop Arguments None private  subroutine end_loop () The loop ends here Arguments None private  subroutine sub_surf () Function that returns the best subsurface from the final surface. Read more… Arguments None private  subroutine calc_res_acf (acf_surf, imp_acf, crit_acf, acf__z, w, h) Function that returns crit_acf the mean absolute difference between theoretical\n and calculated acfs Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:w, 1:h) :: acf_surf calculated surface acf real(kind=R8), intent(in), dimension(1:w, 1:h) :: imp_acf required surface acf real(kind=R8), intent(out) :: crit_acf mean absolute difference between theoretical and calculated acfs real(kind=R8), intent(in) :: acf__z plane elevation z where correlation lengths are calculated integer(kind=I4), intent(in) :: w surface acf width (points) integer(kind=I4), intent(in) :: h surface acf height (points) private  subroutine save_img (tab) Function that save an array tab as a digital surf file. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(:,:) :: tab a surface to save as a .sur file private  subroutine smooth__ () Function that applies a low-pass filter to the surface PARAM%surf Read more… Arguments None private  subroutine calc_z_f (to_be_made) Function that returns PARAM%surf, the surface made of heights with the required statistical\n moments, in the right order. Read more… Arguments Type Intent Optional Attributes Name logical(kind=I4), intent(in) :: to_be_made whether to determine the heights, or reuse them private  subroutine calc_ord () Function that returns the vector PARAM%order that contains the heights order. Read more… Arguments None private  subroutine digi_fil () Function that applies the digital filter to the random heights Read more… Arguments None private  subroutine calc_z_i () Function that returns the starting surface of random heights Read more… Arguments None private  subroutine calc_ffh (calc_m_stt) Function that returns … Read more… Arguments Type Intent Optional Attributes Name logical(kind=I4), intent(inout) :: calc_m_stt compute starting moments ? private  subroutine sta_scri () Start the script reading Arguments None private  subroutine def_size () Geometrical characteristics of the numerical surface Arguments None private  subroutine acf_theo () Function that returns the theoretical acf PARAM%imp_acf. Read more… Arguments None private  subroutine nb_procs () Number of concurrent threads Arguments None private  subroutine sta_theo () Required statistical moments Arguments None private  subroutine end_scri () End of script Arguments None","tags":"","loc":"module/script.html"},{"title":"main – CREST","text":"Uses script data_arch crest_param program~~main~~UsesGraph program~main main data_arch data_arch program~main->data_arch module~crest_param crest_param program~main->module~crest_param module~script script program~main->module~script module~crest_param->data_arch pikaia_oop pikaia_oop module~crest_param->pikaia_oop stat_mom stat_mom module~crest_param->stat_mom module~script->data_arch module~script->module~crest_param anisotropy anisotropy module~script->anisotropy fftw3 fftw3 module~script->fftw3 files files module~script->files filter filter module~script->filter gnufor gnufor module~script->gnufor miscellaneous miscellaneous module~script->miscellaneous module~func_acf func_acf module~script->module~func_acf module~skku_profiles skku_profiles module~script->module~skku_profiles module~script->pikaia_oop sort_arrays sort_arrays module~script->sort_arrays module~script->stat_mom surfile surfile module~script->surfile module~func_acf->data_arch module~func_acf->module~crest_param module~func_acf->fftw3 module~func_acf->miscellaneous module~func_acf->stat_mom module~skku_profiles->data_arch module~skku_profiles->module~crest_param module~skku_profiles->pikaia_oop module~skku_profiles->sort_arrays module~skku_profiles->stat_mom Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Main program Calls program~~main~~CallsGraph program~main main proc~prg_surf prg_surf program~main->proc~prg_surf proc~read_job read_job proc~prg_surf->proc~read_job get_unit get_unit proc~read_job->get_unit proc~acf_theo acf_theo proc~read_job->proc~acf_theo proc~calc_acf calc_acf proc~read_job->proc~calc_acf proc~calc_ffh calc_ffh proc~read_job->proc~calc_ffh proc~calc_ord calc_ord proc~read_job->proc~calc_ord proc~calc_z_f calc_z_f proc~read_job->proc~calc_z_f proc~calc_z_i calc_z_i proc~read_job->proc~calc_z_i proc~def_size def_size proc~read_job->proc~def_size proc~digi_fil digi_fil proc~read_job->proc~digi_fil proc~end_loop end_loop proc~read_job->proc~end_loop proc~end_scri end_scri proc~read_job->proc~end_scri proc~nb_procs nb_procs proc~read_job->proc~nb_procs proc~plt__acf plt__acf proc~read_job->proc~plt__acf proc~save_img save_img proc~read_job->proc~save_img proc~smooth__ smooth__ proc~read_job->proc~smooth__ proc~sta_loop sta_loop proc~read_job->proc~sta_loop proc~sta_scri sta_scri proc~read_job->proc~sta_scri proc~sta_theo sta_theo proc~read_job->proc~sta_theo proc~sub_surf sub_surf proc~read_job->proc~sub_surf selectcase selectcase proc~read_job->selectcase str_remove_chars str_remove_chars proc~read_job->str_remove_chars ellipse_acf ellipse_acf proc~acf_theo->ellipse_acf proc~calc_imp_acf calc_imp_acf proc~acf_theo->proc~calc_imp_acf proc~acf_wiener acf_wiener proc~calc_acf->proc~acf_wiener calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_ffh->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_ffh->calc_fftw3_real_fwd calc_moments calc_moments proc~calc_ffh->calc_moments init_order init_order proc~calc_ord->init_order sort_array2 sort_array2 proc~calc_ord->sort_array2 proc~calc_z_f->calc_moments proc~build_heights build_heights proc~calc_z_f->proc~build_heights proc~calc_z_i->calc_moments proc~calc_z_i->proc~build_heights scramble scramble proc~calc_z_i->scramble proc~digi_fil->calc_fftw3_real_bwd proc~digi_fil->calc_fftw3_real_fwd proc~digi_fil->calc_moments end_fftw3 end_fftw3 proc~end_scri->end_fftw3 omp_get_num_procs omp_get_num_procs proc~nb_procs->omp_get_num_procs proc~plt__acf->get_unit proc~plt__acf->ellipse_acf init_scal init_scal proc~save_img->init_scal write_surf write_surf proc~save_img->write_surf proc~smooth__->calc_moments fft_filter fft_filter proc~smooth__->fft_filter random_init random_init proc~sta_scri->random_init proc~sub_surf->calc_moments proc~sub_surf->end_fftw3 fftw_plan_with_nthreads fftw_plan_with_nthreads proc~sub_surf->fftw_plan_with_nthreads proc~sub_surf->init_order omp_get_max_threads omp_get_max_threads proc~sub_surf->omp_get_max_threads proc~sub_surf->proc~acf_wiener proc~sub_surf->proc~build_heights proc~sub_surf->proc~calc_imp_acf proc~calc_res_acf calc_res_acf proc~sub_surf->proc~calc_res_acf progress_bar_terminal progress_bar_terminal proc~sub_surf->progress_bar_terminal proc~sub_surf->sort_array2 tab_end_fftw3_real tab_end_fftw3_real proc~sub_surf->tab_end_fftw3_real tab_init_fftw3_real tab_init_fftw3_real proc~sub_surf->tab_init_fftw3_real proc~acf_wiener->calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center proc~build_heights->calc_moments proc~build_heights->sort_array2 proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d proc~apod2 apod2 proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo init init proc~pikaia_skku_solver->init solve solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines subroutine prg_surf () Main function… Read more… Arguments None Source Code program main !$ use omp_lib use script , only : read_job use crest_param use data_arch , only : I4 , R8 implicit none call prg_surf contains subroutine prg_surf () !================================================================================================ !<@note Main function... ! ! - retrieve script (job) file ! - read script ! - run specific functions associated to a script keyword ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 128 ) :: arg_prg character ( len = 512 ) :: job_file character ( len = 008 ) :: chara_d character ( len = 010 ) :: chara_t integer ( kind = I4 ) :: var_i ! String initialisation arg_prg = repeat ( ' ' , len ( arg_prg )) JOB_FILE = repeat ( ' ' , len ( JOB_FILE )) var_i = 1 call get_command_argument ( var_i , arg_prg ) ! argument one: argument string if ( len_trim ( arg_prg ) == 0 ) then ! if there is no job file, stop write ( TER , * ) 'no job file, stop' stop else job_file = trim ( arg_prg ) endif call read_job ( job_file ) ! the program executes 'prg_repeat' times write ( TER , * ) 'Program completed' return endsubroutine prg_surf endprogram main","tags":"","loc":"program/main.html"},{"title":"mod_crest_param.f90 – CREST","text":"Files dependent on this one sourcefile~~mod_crest_param.f90~~AfferentGraph sourcefile~mod_crest_param.f90 mod_crest_param.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_script.f90 mod_script.f90 sourcefile~main.f90->sourcefile~mod_script.f90 sourcefile~mod_func_acf.f90 mod_func_acf.f90 sourcefile~mod_func_acf.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_script.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_script.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_skku_profiles.f90 mod_skku_profiles.f90 sourcefile~mod_script.f90->sourcefile~mod_skku_profiles.f90 sourcefile~mod_skku_profiles.f90->sourcefile~mod_crest_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: october, 23 2024 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.2em;\"> !        **Global variables and types** !  </span> module crest_param use data_arch , only : I4 , R8 use stat_mom , only : moment_stat use pikaia_oop , only : pikaia_class implicit none public integer ( kind = I4 ) :: JOB !! *JOB file: script* integer ( kind = I4 ) :: SPY !! *SPY file* integer ( kind = I4 ), parameter :: TER = 6 !! *terminal output* type param_crest real ( kind = R8 ), allocatable , dimension (:) :: vect_h !! *vector used to store the heights that meet the stat moments* real ( kind = R8 ), allocatable , dimension (:,:) :: surf !! *surface array* real ( kind = R8 ), allocatable , dimension (:,:) :: imp_acf !! *imposed autocorrelation* real ( kind = R8 ), allocatable , dimension (:,:) :: fhi !! *digital filter* real ( kind = R8 ), allocatable , dimension (:,:) :: acf_surf !! *calculated autocorrelation* integer ( kind = I4 ), allocatable , dimension (:) :: order !! *vector that stores heights order* type ( MOMENT_STAT ) :: m_end !! *final stat moments* type ( MOMENT_STAT ) :: m_inp !! *input stat moments for genetic algo optimizer* type ( MOMENT_STAT ) :: m_stt !! *starting stat moments* type ( pikaia_class ) :: pik_class !! **PIKAIA** *class instanciation* integer ( kind = I4 ) :: func_gen !! *mathematical function used to generate the heights* integer ( kind = I4 ) :: nparam !! *number of parameters for the mathematical function* integer ( kind = I4 ) :: nb_threads !! *number of concurrent threads* integer ( kind = I4 ) :: width !! *surface nb points along x* integer ( kind = I4 ) :: height !! *surface nb points along y* integer ( kind = I4 ) :: npts !! *surface nb points* integer ( kind = I4 ) :: sub_width !! *subsurface nb points along x* integer ( kind = I4 ) :: sub_height !! *subsurface nb points along y* integer ( kind = I4 ) :: sub_npts !! *subsurface nb points* logical ( kind = I4 ) :: reajust_skku !! *if Ssk**2 +1 > Sku, modify Sku* logical ( kind = I4 ) :: periodic !! *is the surface periodic?* logical ( kind = I4 ) :: apod !! *apodize imposed acf?* real ( kind = R8 ) :: l_acf1 !! *correlation principal length at z=acf__z* real ( kind = R8 ) :: l_acf2 !! *correlation secondary length at z=acf__z* real ( kind = R8 ) :: acf__z !! *acf cutting plane z, for correlation lengths determination* real ( kind = R8 ) :: a_acf !! *roughness orientation* real ( kind = R8 ) :: cutoff !! *Gaussian filter cutoff* real ( kind = R8 ) :: surf_width !! *surface width (m)* real ( kind = R8 ) :: surf_height !! *surface height (m)* real ( kind = R8 ) :: sub_surf_width !! *subsurface width (m)* real ( kind = R8 ) :: sub_surf_height !! *subsurface height (m)* real ( kind = R8 ) :: surf_dx !! *surface increment along x (m)* real ( kind = R8 ) :: surf_dy !! *surface increment along y (m)* real ( kind = R8 ) :: crt_acf !! *acf criterion: mean absolute difference between imposed and calculated acf allowed* real ( kind = R8 ) :: res_acf !! *store mean absolute difference between imposed and calculated acf* endtype param_crest type ( param_crest ) :: PARAM integer ( kind = I4 ), parameter :: FCT_TANG = 1 !! *tangent function for height generation* integer ( kind = I4 ), parameter :: FCT_EXPO = 2 !! *exponential function for height generation* endmodule crest_param","tags":"","loc":"sourcefile/mod_crest_param.f90.html"},{"title":"main.f90 – CREST","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~mod_crest_param.f90 mod_crest_param.f90 sourcefile~main.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_script.f90 mod_script.f90 sourcefile~main.f90->sourcefile~mod_script.f90 sourcefile~mod_script.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_func_acf.f90 mod_func_acf.f90 sourcefile~mod_script.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_skku_profiles.f90 mod_skku_profiles.f90 sourcefile~mod_script.f90->sourcefile~mod_skku_profiles.f90 sourcefile~mod_func_acf.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_skku_profiles.f90->sourcefile~mod_crest_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: october, 23 2024 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.2em;\"> !        **Main program** !  </span> program main !$ use omp_lib use script , only : read_job use crest_param use data_arch , only : I4 , R8 implicit none call prg_surf contains subroutine prg_surf () !================================================================================================ !<@note Main function... ! ! - retrieve script (job) file ! - read script ! - run specific functions associated to a script keyword ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 128 ) :: arg_prg character ( len = 512 ) :: job_file character ( len = 008 ) :: chara_d character ( len = 010 ) :: chara_t integer ( kind = I4 ) :: var_i ! String initialisation arg_prg = repeat ( ' ' , len ( arg_prg )) JOB_FILE = repeat ( ' ' , len ( JOB_FILE )) var_i = 1 call get_command_argument ( var_i , arg_prg ) ! argument one: argument string if ( len_trim ( arg_prg ) == 0 ) then ! if there is no job file, stop write ( TER , * ) 'no job file, stop' stop else job_file = trim ( arg_prg ) endif call read_job ( job_file ) ! the program executes 'prg_repeat' times write ( TER , * ) 'Program completed' return endsubroutine prg_surf endprogram main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"mod_skku_profiles.f90 – CREST","text":"This file depends on sourcefile~~mod_skku_profiles.f90~~EfferentGraph sourcefile~mod_skku_profiles.f90 mod_skku_profiles.f90 sourcefile~mod_crest_param.f90 mod_crest_param.f90 sourcefile~mod_skku_profiles.f90->sourcefile~mod_crest_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_skku_profiles.f90~~AfferentGraph sourcefile~mod_skku_profiles.f90 mod_skku_profiles.f90 sourcefile~mod_script.f90 mod_script.f90 sourcefile~mod_script.f90->sourcefile~mod_skku_profiles.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_script.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: may, 03 2019 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.2em;\"> !        **Routines to generate a (Sk, Ku) series** !  </span> module skku_profiles use data_arch , only : I4 , R8 , UN , EPS_R8 , PI_R8 , HIG_E8 use crest_param , only : PARAM , JOB , SPY , TER , FCT_TANG , FCT_EXPO use stat_mom , only : moment_stat , calc_moments , scramble use sort_arrays , only : sort_array2 , init_order use pikaia_oop , only : pikaia_class implicit none !> {!src/inc_doc/profile_generation.md!} private public :: calculs_skku_generique , build_heights contains subroutine build_heights ( vec_out , use_fct_expo , stats_in , lg ) !================================================================================================ !<@note Function that returns a set of heights that matches desired statistical moments. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: lg !! *length of the height vector* type ( MOMENT_STAT ), intent ( in ) :: stats_in !! *input statistical moments* logical ( kind = I4 ), intent ( in ) :: use_fct_expo !! *should exponential function rather than tangent function be used?* real ( kind = R8 ), intent ( out ), dimension ( 1 : lg ) :: vec_out !! *height vector* integer ( kind = I4 ) :: istat , fct_sav real ( kind = R8 ) :: cost_val type ( MOMENT_STAT ) :: m_tmp real ( kind = R8 ), dimension ( 1 : PARAM % nparam ) :: xlower real ( kind = R8 ), dimension ( 1 : PARAM % nparam ) :: xupper real ( kind = R8 ), dimension ( 1 : PARAM % nparam ) :: xresul ! put input parameters in global variables, so that they can be used in the function \"fitness_skku_anal\" PARAM % m_inp % sk = stats_in % sk PARAM % m_inp % ku = stats_in % ku ! save PARAM%func_gen value fct_sav = PARAM % func_gen ! if the Pearson limit is to close to the point (Ssk, Sku), an exponential function is used if ( use_fct_expo ) PARAM % func_gen = FCT_EXPO ! Genetic algorithm is used to determinate the tangent parameters \\alpha and \\beta so that, the set of lg heights ! will match the statistical moments. !.............................................................................. ! initialization xresul ( 1 : PARAM % nparam ) = 0.0_R8 xlower ( 1 : PARAM % nparam ) = 0.0_R8 xupper ( 1 : PARAM % nparam ) = 1.0_R8 call pikaia_skku_solver ( pik_class = PARAM % pik_class , & ! INOUT step = 'init' , & ! IN xl = xlower ( 1 : PARAM % nparam ), & ! IN xu = xupper ( 1 : PARAM % nparam ), & ! IN xx = xresul ( 1 : PARAM % nparam ), & ! IN nparam = PARAM % nparam , & ! IN cost = cost_func_skku , & ! IN istat = istat , & ! OUT f = cost_val ) ! IN call pikaia_skku_solver ( pik_class = PARAM % pik_class , & ! INOUT step = 'solv' , & ! IN xl = xlower ( 1 : PARAM % nparam ), & ! IN xu = xupper ( 1 : PARAM % nparam ), & ! IN xx = xresul ( 1 : PARAM % nparam ), & ! OUT nparam = PARAM % nparam , & ! IN cost = cost_func_skku , & ! IN istat = istat , & ! OUT f = cost_val ) ! IN !.............................................................................. ! the parameters habe been found, let generate lg heights !.............................................................................. call profil_theo_trie_1D ( tab = vec_out ( 1 : lg ), & ! OUT lg = lg , & ! IN x = xresul ( 1 : PARAM % nparam ), & ! IN mx = m_tmp ) ! OUT !.............................................................................. ! PARAM%func_gen value is retrieved PARAM % func_gen = fct_sav ! height moments calculation call calc_moments ( tab = vec_out ( 1 : lg ), & ! IN mx = m_tmp , & ! OUT nb_mom = 4 ) ! IN ! scale and center vec_out ( 1 : lg ) = ( vec_out ( 1 : lg ) - m_tmp % mu ) / m_tmp % si ! the parameter found can lead to inverted heights if ( stats_in % sk * m_tmp % sk < 0. ) then vec_out ( 1 : lg ) = - vec_out ( 1 : lg ) endif ! heights are sorted call sort_array2 ( tab_inout = vec_out ( 1 : lg ), n = lg ) return endsubroutine build_heights subroutine cost_func_skku ( me , x , f ) !! Quantify de distance between desired moments and calculated moments implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f f = fitness_skku_anal ( n = PARAM % nparam , x = x ( 1 : PARAM % nparam ) ) return endsubroutine cost_func_skku real ( kind = R8 ) function fitness_skku_anal ( n , x ) !================================================================================================ !<@note Generic cost function: difference between the imposed statistical moments and those ! obtained. The optimization problem must be turned into a maximization problem (as often ! in the optimization routines). ! ! The closer cost to 100 the better series. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n !! *number of unknowns* real ( kind = R8 ), intent ( in ), dimension ( 1 : n ) :: x !! *vector of unknowns* real ( kind = R8 ) :: sk , ku select case ( PARAM % func_gen ) case ( FCT_TANG ) ; call calculs_skku_tan ( bounds = x , lg = PARAM % npts , ssk = sk , sku = ku ) case ( FCT_EXPO ) ; call calculs_skku_exp ( bounds = x , lg = PARAM % npts , ssk = sk , sku = ku ) endselect fitness_skku_anal = ( abs ( sk ** 2 - PARAM % m_inp % sk ** 2 ) + & ! abs ( ku - PARAM % m_inp % ku ) ) / PARAM % m_inp % ku ! fitness_skku_anal = 10 0._r8 / ( 1._r8 + fitness_skku_anal ) return endfunction fitness_skku_anal subroutine pikaia_skku_solver ( pik_class , step , xl , xu , nparam , cost , istat , f , xx ) !================================================================================================ !<@note This is a refactoring of the PIKAIA unconstrained optimization code from the High Altitude Observatory. ! The original code is public domain and was written by Paul Charbonneau & Barry Knapp. ! ! The present code is the awesome modern Fortran version written by Jabob Williams: ! ! [OOP Pikaia, Jacob Williams](https://github.com/jacobwilliams/pikaia) ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none type ( pikaia_class ), intent ( inout ) :: pik_class !! **PIKAIA** *class instanciation* character ( len = 4 ), intent ( in ) :: step !! *init* or *solv* integer ( kind = I4 ), intent ( in ) :: nparam !! *number of parameters* real ( kind = R8 ), intent ( in ), dimension ( 1 : nparam ) :: xl !! *lower bonds of xx* real ( kind = R8 ), intent ( in ), dimension ( 1 : nparam ) :: xu !! *upper bonds of xx* real ( kind = R8 ), intent ( out ), dimension ( 1 : nparam ) :: xx !! *chromosom for* **PIKAIA** integer ( kind = I4 ), intent ( out ) :: istat real ( kind = R8 ), intent ( out ) :: f interface subroutine cost ( me , x , f ) use data_arch , only : R8 use pikaia_oop , only : pikaia_class implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f endsubroutine cost endinterface select case ( step ) case ( 'init' ) !initialize the class: call pik_class % init ( n = nparam , & ! IN           ; the parameter space dimension, i.e., the number of adjustable parameters (size of the x vector). xl = xl , & ! IN, DIM(n)   ;  vector of lower bounds for x xu = xu , & ! IN, DIM(n)   ;  vector of upper bounds for x f = cost , & !              ; user-supplied scalar function of n variables, which must have the pikaia_func procedure interface. status = istat , & ! OUT          ; status output flag (0 if there were no errors) !iter_f = report_iteration,    &  !     OPT      ; user-supplied subroutine that will report the best solution for each generation. It must have the iter_func procedure interface. np = 100 , & ! IN, OPT      ; number of individuals in a population (default is 100) ngen = 1000 , & ! IN, OPT      ; maximum number of iterations nd = 9 , & ! IN           ; number of significant digits (i.e., number of genes) retained in chromosomal encoding pcross = 0.85_R8 , & ! IN, OPT      ; crossover probability; must be <= 1.0 (default is 0.85). If crossover takes place, either one or two splicing points are used, with equal probabilities pmutmn = 0.0005_R8 , & ! IN, OPT      ; minimum mutation rate; must be >= 0.0 (default is 0.0005) pmutmx = 0.25_R8 , & ! IN, OPT      ; maximum mutation rate; must be <= 1.0 (default is 0.25) pmut = 0.005_R8 , & ! IN, OPT      ; initial mutation rate; should be small (default is 0.005) (Note: the mutation rate is the probability that any one gene locus will mutate in any one generation.) imut = 2 , & ! IN, OPT      ; mutation mode; 1/2/3/4/5 (default is 2). !              1=one-point mutation, fixed rate. !              2=one-point, adjustable rate based on fitness. !              3=one-point, adjustable rate based on distance. !              4=one-point+creep, fixed rate. !              5=one-point+creep, adjustable rate based on fitness. !              6=one-point+creep, adjustable rate based on distance. fdif = 1._R8 , & ! IN, OPT      ; relative fitness differential; range from 0 (none) to 1 (maximum). (default is 1.0) irep = 3 , & ! IN, OPT      ; reproduction plan; 1/2/3=Full generational replacement/Steady-state-replace-random/Steady- state-replace-worst (default is 3) ielite = 0 , & ! IN, OPT      ; elitism flag; 0/1=off/on (default is 0) (Applies only to reproduction plans 1 and 2) ivrb = 0 , & ! IN, OPT      ; printed output 0/1/2=None/Minimal/Verbose convergence_tol = 1.0e-6_R8 , & ! IN, OPT      ; convergence tolerance; must be > 0.0 (default is 0.0001) convergence_window = 200 , & ! IN, OPT      ; convergence window; must be >= 0 This is the number of consecutive solutions within the tolerance for convergence to be declared (default is 20) initial_guess_frac = 0.1_R8 , & ! IN, OPT      ; raction of the initial population to set equal to the initial guess. Range from 0 (none) to 1.0 (all). (default is 0.1 or 10%). iseed = 999 ) ! IN, OPT      ; random seed value; must be > 0 (default is 999) case ( 'solv' ) call pik_class % solve ( x = xx ( 1 : nparam ), & ! INOUT, DIM(*) ; f = f , & !   OUT         ; status = istat , & !   OUT         ; omp = . true . ) ! IN, OPTIONAL case default stop 'Wrong choice in \"pikaia_skku_solver\"' endselect return endsubroutine pikaia_skku_solver subroutine calculs_skku_tan ( bounds , lg , ssk , sku ) !================================================================================================ !<@note Function to calculate the skewness and kurtosis of a **tangent** series ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: bounds !! *defines the function limits* [-pi/2.(1-bounds(1)), +pi/2.(1-bounds(2)] integer ( kind = I4 ), intent ( in ) :: lg !! *vec size* real ( kind = R8 ), intent ( out ) :: ssk !! *theoretical Ssk* real ( kind = R8 ), intent ( out ) :: sku !! *theoretical Sku* real ( kind = R8 ) :: xa , xb , mu , si , sk , ku , a , b real ( kind = R8 ) :: h , hh , b1 , b2 , alp , bet integer ( kind = I4 ) :: i , ia , ib , deb , fin !--------------------------------------------- ! WXMAXIMA file !--------------------------------------------- !kill(all); ! !f11(x):=tan(x)$ ! !assume(u<0.)$ !assume(u>-%pi/2)$ !assume(v>0.)$ !assume(v<%pi/2)$ ! !I11:integrate(f11(x),x,u,v)$ !I11:subst(-%pi/2+%pi/2*xa,u,I11)$ !I11:subst(+%pi/2-%pi/2*xb,v,I11)$ !I11:expand(trigsimp(I11)); ! !f21(x):=f11(x)-mu$ !I21:integrate(expand(f21(x)&#94;2),x,u,v)$ !I21:subst(-%pi/2+%pi/2*xa,u,I21)$ !I21:subst(+%pi/2-%pi/2*xb,v,I21)$ !I21:expand(trigsimp(I21)); ! !f31(x):=f21(x)/si$ !I31:integrate(f31(x)&#94;3,x,u,v)$ !I31:subst(-%pi/2+%pi/2*xa,u,I31)$ !I31:subst(+%pi/2-%pi/2*xb,v,I31)$ !I31:expand(trigsimp(I31)); ! !I41:integrate(f31(x)&#94;4,x,u,v)$ !I41:subst(-%pi/2+%pi/2*xa,u,I41)$ !I41:subst(+%pi/2-%pi/2*xb,v,I41)$ !I41:expand(trigsimp(I41)); !--------------------------------------------- ia = 256 ! ia and ib define the interval edges to be excluded ... ib = 256 ! ... because of high variations of the function. deb = 1 + ia ! start fin = lg - ib ! end a = bounds ( 1 ) b = bounds ( 2 ) hh = ( 2._R8 - a - b ) / ( lg - 1 ) h = ( PI_R8 / 2 ) * hh xa = a + ia * hh xb = b + ib * hh b1 = - PI_R8 / 2 * ( UN - a ) b2 = + PI_R8 / 2 * ( UN - b ) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . mu = log ( sin (( PI_R8 * xa ) / 2. )) - log ( sin (( PI_R8 * xb ) / 2. )) mu = ( UN / h ) * mu + add_tang ( 1 , deb , fin , alp , bet , mu = 0._R8 , si = 1._R8 ) do i = 1 , ia - 1 mu = mu + tang ( i * UN , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo do i = lg , lg - ( ib - 2 ), - 1 mu = mu + tang ( i * UN , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo mu = mu / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . si = 2. * mu * log ( sin (( PI_R8 * xb ) / 2. )) + cos (( PI_R8 * xb ) / 2. ) / sin (( PI_R8 * xb ) / 2. ) - ( PI_R8 * mu ** 2. * xb ) / 2. + ( PI_R8 * xb ) / 2. & ! - 2. * mu * log ( sin (( PI_R8 * xa ) / 2. )) + cos (( PI_R8 * xa ) / 2. ) / sin (( PI_R8 * xa ) / 2. ) - ( PI_R8 * mu ** 2. * xa ) / 2. + ( PI_R8 * xa ) / 2. + PI_R8 * mu ** 2. - PI_R8 ! si = ( UN / h ) * si + add_tang ( 2 , deb , fin , alp , bet , mu , si = 1._R8 ) do i = 1 , ia - 1 si = si + tang ( i * UN , 2 , alp , bet , mu , si = 1._R8 ) enddo do i = lg , lg - ( ib - 2 ), - 1 si = si + tang ( i * UN , 2 , alp , bet , mu , si = 1._R8 ) enddo si = si / lg si = sqrt ( si ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . sk = log ( sin (( PI_R8 * xb ) / 2. ) ** 2. ) / ( 2. * si ** 3. ) & ! - ( 3. * mu ** 2. * log ( sin (( PI_R8 * xb ) / 2. ))) / si ** 3. & ! - ( 3. * mu * cos (( PI_R8 * xb ) / 2. )) / ( si ** 3. * sin (( PI_R8 * xb ) / 2. )) & ! + 1 / ( 2. * si ** 3. * sin (( PI_R8 * xb ) / 2. ) ** 2. ) + ( PI_R8 * mu ** 3. * xb ) / ( 2. * si ** 3. ) & ! - ( 3. * PI_R8 * mu * xb ) / ( 2. * si ** 3. ) & ! - log ( sin (( PI_R8 * xa ) / 2. ) ** 2. ) / ( 2. * si ** 3. ) & ! + ( 3. * mu ** 2. * log ( sin (( PI_R8 * xa ) / 2. ))) / si ** 3. & ! - ( 3. * mu * cos (( PI_R8 * xa ) / 2. )) / ( si ** 3. * sin (( PI_R8 * xa ) / 2. )) & ! - 1 / ( 2. * si ** 3. * sin (( PI_R8 * xa ) / 2. ) ** 2. ) + ( PI_R8 * mu ** 3. * xa ) / ( 2. * si ** 3. ) & ! - ( 3. * PI_R8 * mu * xa ) / ( 2. * si ** 3. ) - ( PI_R8 * mu ** 3. ) / si ** 3. + ( 3. * PI_R8 * mu ) / si ** 3. ! sk = ( UN / h ) * sk + add_tang ( 3 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 sk = sk + tang ( i * UN , 3 , alp , bet , mu , si ) enddo do i = lg , lg - ( ib - 2 ), - 1 sk = sk + tang ( i * UN , 3 , alp , bet , mu , si ) enddo sk = sk / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ku = - ( 2. * mu * log ( sin (( PI_R8 * xb ) / 2. ) ** 2. )) / si ** 4. + ( 4. * mu ** 3. * log ( sin (( PI_R8 * xb ) / 2. ))) / si ** 4. & ! + ( 6. * mu ** 2. * cos (( PI_R8 * xb ) / 2. )) / ( si ** 4. * sin (( PI_R8 * xb ) / 2. )) - ( 4. * cos (( PI_R8 * xb ) / 2. )) / ( 3. * si ** 4. * sin (( PI_R8 * xb ) / 2. )) & ! - ( 2. * mu ) / ( si ** 4. * sin (( PI_R8 * xb ) / 2. ) ** 2. ) + cos (( PI_R8 * xb ) / 2. ) / ( 3. * si ** 4. * sin (( PI_R8 * xb ) / 2. ) ** 3. ) & ! - ( PI_R8 * mu ** 4. * xb ) / ( 2. * si ** 4. ) + ( 3. * PI_R8 * mu ** 2. * xb ) / si ** 4. - ( PI_R8 * xb ) / ( 2. * si ** 4. ) & ! + ( 2. * mu * log ( sin (( PI_R8 * xa ) / 2. ) ** 2. )) / si ** 4. - ( 4. * mu ** 3. * log ( sin (( PI_R8 * xa ) / 2. ))) / si ** 4. & ! + ( 6. * mu ** 2. * cos (( PI_R8 * xa ) / 2. )) / ( si ** 4. * sin (( PI_R8 * xa ) / 2. )) - ( 4. * cos (( PI_R8 * xa ) / 2. )) / ( 3. * si ** 4. * sin (( PI_R8 * xa ) / 2. )) & ! + ( 2. * mu ) / ( si ** 4. * sin (( PI_R8 * xa ) / 2. ) ** 2. ) + cos (( PI_R8 * xa ) / 2. ) / ( 3. * si ** 4. * sin (( PI_R8 * xa ) / 2. ) ** 3. ) & ! - ( PI_R8 * mu ** 4. * xa ) / ( 2. * si ** 4. ) + ( 3. * PI_R8 * mu ** 2. * xa ) / si ** 4. - ( PI_R8 * xa ) / ( 2. * si ** 4. ) & ! + ( PI_R8 * mu ** 4. ) / si ** 4. - ( 6. * PI_R8 * mu ** 2. ) / si ** 4. + PI_R8 / si ** 4. ! ku = ( UN / h ) * ku + add_tang ( 4 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 ku = ku + tang ( i * UN , 4 , alp , bet , mu , si ) enddo do i = lg , lg - ( ib - 2 ), - 1 ku = ku + tang ( i * UN , 4 , alp , bet , mu , si ) enddo ku = ku / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ssk = sk sku = ku return endsubroutine calculs_skku_tan subroutine calculs_skku_exp ( bounds , lg , ssk , sku ) !================================================================================================ !<@note Function to calculate the skewness and kurtosis of an **exponential** series.<br/> ! The principle is the same as [[calculs_skku_tan]], however it fits better some particular ! series quite binary (roughly two heights). ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: bounds !! *interval limits* [-(1/bounds(1)-1), +(1/bounds(2)-1)] integer ( kind = I4 ), intent ( in ) :: lg !! *vec size* real ( kind = R8 ), intent ( out ) :: ssk !! *theoretical Ssk* real ( kind = R8 ), intent ( out ) :: sku !! *theoretical Sku* real ( kind = R8 ) :: xa , xb , xk , mu , si , sk , ku , a , b , pente real ( kind = R8 ) :: h , hh , b1 , b2 , alp , bet real ( kind = R8 ) :: exp1b , exp1a , exp2b , exp2a , exp3b , exp3a , exp4b , exp4a , tmp1a , tmp1b , tmp2a , tmp2b , tmp3a , tmp3b , tmp4a , tmp4b integer ( kind = I4 ) :: deb , fin pente = UN !--------------------------------------------- ! WXMaxima file !--------------------------------------------- !kill(all); !load (f90)$ ! !f11(x):=-1+exp(+xk*x)$ !g11(x):=+1-exp(-xk*x)$ ! !f21(x):=f11(x)-mu$ !g21(x):=g11(x)-mu$ ! !f31(x):=f21(x)/si$ !g31(x):=g21(x)/si$ ! !assume(v>0.)$ !assume(u>0.)$ !/* [wxMaxima: input   end   ] */ ! !/* [wxMaxima: input   start ] */ !I11:integrate(f11(x),x,-u,0)$ !J11:integrate(g11(x),x,+0,v)$ !I11:subst(1./xa-1.,u,I11)$ !J11:subst(1./xb-1.,v,J11)$ !I11:I11+J11$ !I11:expand(trigsimp(I11))$ !f90(I11); !/* [wxMaxima: input   end   ] */ ! !/* [wxMaxima: input   start ] */ !I21:integrate(f21(x)&#94;2,x,-u,0)$ !J21:integrate(g21(x)&#94;2,x,+0,v)$ !I21:subst(1./xa-1.,u,I21)$ !J21:subst(1./xb-1.,v,J21)$ !I21:I21+J21$ !I21:expand(trigsimp(I21))$ !f90(I21); !/* [wxMaxima: input   end   ] */ ! !/* [wxMaxima: input   start ] */ !I31:integrate(f31(x)&#94;3,x,-u,0)$ !J31:integrate(g31(x)&#94;3,x,+0,v)$ !I31:subst(1./xa-1.,u,I31)$ !J31:subst(1./xb-1.,v,J31)$ !I31:I31+J31$ !I31:expand(trigsimp(I31))$ !f90(I31); !/* [wxMaxima: input   end   ] */ ! !/* [wxMaxima: input   start ] */ !I41:integrate(f31(x)&#94;4,x,-u,0)$ !J41:integrate(g31(x)&#94;4,x,+0,v)$ !I41:subst(1./xa-1.,u,I41)$ !J41:subst(1./xb-1.,v,J41)$ !I41:I41+J41$ !I41:expand(trigsimp(I41))$ !f90(I41); !--------------------------------------------- a = max ( bounds ( 1 ), 1.e-6_R8 ) b = max ( bounds ( 2 ), 1.e-6_R8 ) hh = ( - 2._R8 + UN / a + UN / b ) / ( lg - 1 ) h = hh xa = a xb = b xk = pente b1 = - ( UN - a ) / a b2 = + ( UN - b ) / b alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) deb = 1 fin = lg tmp1a = 1 * ( xk - xk / xa ) ; tmp1a = max ( - 0.9 * HIG_E8 , tmp1a ) ; tmp1a = min ( + 0.9 * HIG_E8 , tmp1a ) tmp1b = 1 * ( xk - xk / xb ) ; tmp1b = max ( - 0.9 * HIG_E8 , tmp1b ) ; tmp1b = min ( + 0.9 * HIG_E8 , tmp1b ) tmp2a = 2 * ( xk - xk / xa ) ; tmp2a = max ( - 0.9 * HIG_E8 , tmp2a ) ; tmp2a = min ( + 0.9 * HIG_E8 , tmp2a ) tmp2b = 2 * ( xk - xk / xb ) ; tmp2b = max ( - 0.9 * HIG_E8 , tmp2b ) ; tmp2b = min ( + 0.9 * HIG_E8 , tmp2b ) tmp3a = 3 * ( xk - xk / xa ) ; tmp3a = max ( - 0.9 * HIG_E8 , tmp3a ) ; tmp3a = min ( + 0.9 * HIG_E8 , tmp3a ) tmp3b = 3 * ( xk - xk / xb ) ; tmp3b = max ( - 0.9 * HIG_E8 , tmp3b ) ; tmp3b = min ( + 0.9 * HIG_E8 , tmp3b ) tmp4a = 4 * ( xk - xk / xa ) ; tmp4a = max ( - 0.9 * HIG_E8 , tmp4a ) ; tmp4a = min ( + 0.9 * HIG_E8 , tmp4a ) tmp4b = 4 * ( xk - xk / xb ) ; tmp4b = max ( - 0.9 * HIG_E8 , tmp4b ) ; tmp4b = min ( + 0.9 * HIG_E8 , tmp4b ) exp1a = exp ( tmp1a ) exp1b = exp ( tmp1b ) exp2a = exp ( tmp2a ) exp2b = exp ( tmp2b ) exp3a = exp ( tmp3a ) exp3b = exp ( tmp3b ) exp4a = exp ( tmp4a ) exp4b = exp ( tmp4b ) mu = exp1b / xk - exp1a / xk + 1 / xb - 1 / xa mu = ( UN / h ) * mu + add_expo ( 1 , deb , fin , alp , bet , mu = 0._R8 , si = 1._R8 ) mu = mu / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . si = - 2 * mu * exp1b / xk + 2 * exp1b / xk - exp2b / xk / 2.0 + 2 * mu * exp1a / xk + 2 * exp1a / xk - exp2a / xk / 2.0 & ! - 3 / xk + mu ** 2 / xb - 2 * mu / xb + 1 / xb + mu ** 2 / xa + 2 * mu / xa + 1 / xa - 2 * mu ** 2 - 2 ! si = ( UN / h ) * si + add_expo ( 2 , deb , fin , alp , bet , mu , si = 1._R8 ) si = si / lg si = sqrt ( si ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . sk = 3 * mu ** 2 * exp1b / ( si ** 3 * xk ) - 6 * mu * exp1b / ( si ** 3 * xk ) + 3 * exp1b / ( si ** 3 * xk ) + 3.0 * mu * exp2b / ( 2.0 * si ** 3 * xk ) & ! + ( - 3.0 ) * exp2b / ( 2.0 * si ** 3 * xk ) + exp3b / ( si ** 3 * xk ) / 3.0 - 3 * mu ** 2 * exp1a / ( si ** 3 * xk ) - 6 * mu * exp1a / ( si ** 3 * xk ) & ! - 3 * exp1a / ( si ** 3 * xk ) + 3.0 * mu * exp2a / ( 2.0 * si ** 3 * xk ) + 3.0 * exp2a / ( 2.0 * si ** 3 * xk ) - exp3a / ( si ** 3 * xk ) / 3.0 & ! + 9 * mu / ( si ** 3 * xk ) - mu ** 3 / ( si ** 3 * xb ) + 3 * mu ** 2 / ( si ** 3 * xb ) - 3 * mu / ( si ** 3 * xb ) + 1 / ( si ** 3 * xb ) - mu ** 3 / ( si ** 3 * xa ) & ! - 3 * mu ** 2 / ( si ** 3 * xa ) - 3 * mu / ( si ** 3 * xa ) - 1 / ( si ** 3 * xa ) + 2 * mu ** 3 / si ** 3 + 6 * mu / si ** 3 ! sk = ( UN / h ) * sk + add_expo ( 3 , deb , fin , alp , bet , mu , si ) sk = sk / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ku = - 4 * mu ** 3 * exp1b / ( si ** 4 * xk ) + 12 * mu ** 2 * exp1b / ( si ** 4 * xk ) - 12 * mu * exp1b / ( si ** 4 * xk ) + 4 * exp1b / ( si ** 4 * xk ) & ! - 3 * mu ** 2 * exp2b / ( si ** 4 * xk ) + 6 * mu * exp2b / ( si ** 4 * xk ) - 3 * exp2b / ( si ** 4 * xk ) + ( - 4.0 ) * mu * exp3b / ( 3.0 * si ** 4 * xk ) & ! + 4.0 * exp3b / ( 3.0 * si ** 4 * xk ) - exp4b / ( si ** 4 * xk ) / 4.0 + 4 * mu ** 3 * exp1a / ( si ** 4 * xk ) + 12 * mu ** 2 * exp1a / ( si ** 4 * xk ) & ! + 12 * mu * exp1a / ( si ** 4 * xk ) + 4 * exp1a / ( si ** 4 * xk ) - 3 * mu ** 2 * exp2a / ( si ** 4 * xk ) - 6 * mu * exp2a / ( si ** 4 * xk ) & ! - 3 * exp2a / ( si ** 4 * xk ) + 4.0 * mu * exp3a / ( 3.0 * si ** 4 * xk ) + 4.0 * exp3a / ( 3.0 * si ** 4 * xk ) - exp4a / ( si ** 4 * xk ) / 4.0 & ! - 18 * mu ** 2 / ( si ** 4 * xk ) + ( - 2 5.0 ) / ( 6.0 * si ** 4 * xk ) + mu ** 4 / ( si ** 4 * xb ) - 4 * mu ** 3 / ( si ** 4 * xb ) + 6 * mu ** 2 / ( si ** 4 * xb ) & ! - 4 * mu / ( si ** 4 * xb ) + 1 / ( si ** 4 * xb ) + mu ** 4 / ( si ** 4 * xa ) + 4 * mu ** 3 / ( si ** 4 * xa ) + 6 * mu ** 2 / ( si ** 4 * xa ) & ! + 4 * mu / ( si ** 4 * xa ) + 1 / ( si ** 4 * xa ) - 2 * mu ** 4 / si ** 4 - 12 * mu ** 2 / si ** 4 - 2 / si ** 4 ! ku = ( UN / h ) * ku + add_expo ( 4 , deb , fin , alp , bet , mu , si ) ku = ku / lg ssk = sk sku = ku return endsubroutine calculs_skku_exp subroutine calculs_skku_generique ( bounds , lg , ssk , sku ) !================================================================================================ !<@note Function that calls the right series generator. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension (:) :: bounds !! *interval limits* integer ( kind = I4 ), intent ( in ) :: lg !! *vec size* real ( kind = R8 ), intent ( out ) :: ssk !! *theoretical Ssk* real ( kind = R8 ), intent ( out ) :: sku !! *theoretical Sku* select case ( PARAM % func_gen ) case ( FCT_TANG ) ; call calculs_skku_tan ( bounds , lg , ssk , sku ) case ( FCT_EXPO ) ; call calculs_skku_exp ( bounds , lg , ssk , sku ) endselect return endsubroutine calculs_skku_generique real ( kind = R8 ) function add_tang ( n , deb , fin , alp , bet , mu , si ) !================================================================================================ !<@note Function that adds to the series mean the border integrals as explained in the docs ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: alp !! *offset so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: bet !! *reduction so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: mu !! *numerical mean* real ( kind = R8 ), intent ( in ) :: si !! *numerical standard deviation* integer ( kind = I4 ), intent ( in ) :: n !! *statistical moment degree, n=3 for sk and n=4 for ku* integer ( kind = I4 ), intent ( in ) :: fin !! *last integration point* integer ( kind = I4 ), intent ( in ) :: deb !! *first integration point* real ( kind = R8 ) :: xdeb , xfin xdeb = deb xfin = fin add_tang = ( UN / 12 ) * ( + 9 * ( tang ( xdeb + 0.0_R8 , n , alp , bet , mu , si ) + tang ( xfin - 0.0_R8 , n , alp , bet , mu , si )) & + 1 * ( tang ( xdeb + 1.0_R8 , n , alp , bet , mu , si ) + tang ( xfin - 1.0_R8 , n , alp , bet , mu , si )) & - 4 * ( tang ( xdeb + 0.5_R8 , n , alp , bet , mu , si ) + tang ( xfin - 0.5_R8 , n , alp , bet , mu , si )) ) return endfunction add_tang real ( kind = R8 ) function add_expo ( n , deb , fin , alp , bet , mu , si ) !================================================================================================ !<@note Function that adds to the series mean the border integrals as explained in the modules ! presentation. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: alp !! *offset so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: bet !! *reduction so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: mu !! *numerical mean* real ( kind = R8 ), intent ( in ) :: si !! *numerical standard deviation* integer ( kind = I4 ), intent ( in ) :: n !! *statistical moment degree, n=3 for sk and n=4 for ku* integer ( kind = I4 ), intent ( in ) :: fin !! *last integration point* integer ( kind = I4 ), intent ( in ) :: deb !! *first integration point* real ( kind = R8 ) :: xdeb , xfin xdeb = deb xfin = fin add_expo = ( UN / 12 ) * ( + 9 * ( expo ( xdeb + 0.0_R8 , n , alp , bet , mu , si ) + expo ( xfin - 0.0_R8 , n , alp , bet , mu , si )) & + 1 * ( expo ( xdeb + 1.0_R8 , n , alp , bet , mu , si ) + expo ( xfin - 1.0_R8 , n , alp , bet , mu , si )) & - 4 * ( expo ( xdeb + 0.5_R8 , n , alp , bet , mu , si ) + expo ( xfin - 0.5_R8 , n , alp , bet , mu , si )) ) return endfunction add_expo real ( kind = R8 ) function tang ( xi , n , alp , bet , mu , si ) !================================================================================================ !<@note Profile function based on the tangent function ! !@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: alp !! *offset so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: bet !! *reduction so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: mu !! *numerical mean* real ( kind = R8 ), intent ( in ) :: si !! *numerical standard deviation* real ( kind = R8 ), intent ( in ) :: xi !! *abscissa* integer ( kind = I4 ), intent ( in ) :: n !! *statistical moment degree, n=3 for sk and n=4 for ku* real ( kind = R8 ) :: tmp tmp = ( xi + alp ) / bet tang = ( ( tan ( tmp ) - mu ) / si ) ** n return endfunction tang real ( kind = R8 ) function expo ( xi , n , alp , bet , mu , si ) !================================================================================================ !<@note Profile function based on the exponential function ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: alp !! *offset so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: bet !! *reduction so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: mu !! *numerical mean* real ( kind = R8 ), intent ( in ) :: si !! *numerical standard deviation* real ( kind = R8 ), intent ( in ) :: xi !! *abscissa* integer ( kind = I4 ), intent ( in ) :: n !! *statistical moment degree, n=3 for sk and n=4 for ku* real ( kind = R8 ) :: tmp , pente pente = UN tmp = ( xi + alp ) / bet tmp = min ( + 0.9 * HIG_E8 , tmp ) tmp = max ( - 0.9 * HIG_E8 , tmp ) expo = ( ( sign ( UN , tmp ) * ( UN - exp ( - pente * abs ( tmp ))) - mu ) / si ) ** n return endfunction expo subroutine profil_theo_trie_1D ( tab , lg , x , mx ) !================================================================================================ !<@note Function that generates the heights when the function limits have been determined. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: lg !! *height vector size* real ( kind = R8 ), intent ( out ), dimension ( 1 : lg ) :: tab !! *height vector* real ( kind = R8 ), intent ( in ), dimension ( : ) :: x !! *unknowns: height function limits* type ( MOMENT_STAT ), intent ( out ) :: mx !! *resulting statistical moments* real ( kind = R8 ) :: b1 , b2 , alp , bet , tmp , pente integer ( kind = I4 ) :: i select case ( PARAM % func_gen ) case ( FCT_TANG ) b1 = - PI_R8 / 2 * ( UN - x ( 1 )) b2 = + PI_R8 / 2 * ( UN - x ( 2 )) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) do i = 1 , lg tab ( i ) = tan ( ( i * UN + alp ) / bet ) enddo case ( FCT_EXPO ) pente = UN b1 = - ( UN - x ( 1 )) / x ( 1 ) b2 = + ( UN - x ( 2 )) / x ( 2 ) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) do i = 1 , lg tmp = ( i * UN + alp ) / bet tmp = max ( - 0.9 * HIG_E8 , tmp ) tmp = min ( + 0.9 * HIG_E8 , tmp ) tab ( i ) = sign ( UN , tmp ) * ( UN - exp ( - pente * abs ( tmp ))) enddo endselect call calc_moments ( tab = tab ( 1 : lg ), mx = mx , nb_mom = 4 ) tab ( 1 : lg ) = ( tab ( 1 : lg ) - mx % mu ) / mx % si ! normalization mx % mu = 0._R8 mx % si = 1._R8 return endsubroutine profil_theo_trie_1D endmodule skku_profiles","tags":"","loc":"sourcefile/mod_skku_profiles.f90.html"},{"title":"mod_func_acf.f90 – CREST","text":"This file depends on sourcefile~~mod_func_acf.f90~~EfferentGraph sourcefile~mod_func_acf.f90 mod_func_acf.f90 sourcefile~mod_crest_param.f90 mod_crest_param.f90 sourcefile~mod_func_acf.f90->sourcefile~mod_crest_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_func_acf.f90~~AfferentGraph sourcefile~mod_func_acf.f90 mod_func_acf.f90 sourcefile~mod_script.f90 mod_script.f90 sourcefile~mod_script.f90->sourcefile~mod_func_acf.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_script.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: october, 23 2024 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.2em;\"> !        **Routines for acf calculations** !  </span> module func_acf use data_arch , only : I4 , R8 , HIG_E8 , EPS_R8 , UN , PI_R8 use fftw3 , only : calc_fftw3_real_bwd , calc_fftw3_real_fwd , tab_calc_fftw3_real_bwd , tab_calc_fftw3_real_fwd , fftw_plan_with_nthreads , init_fftw3_real , end_fftw3 , PAD_FFT , extend , & ! SINGL_FFTW_ALLOCATED , NB_THREADS_FFT , FFT_DIM , FFTW_ESTIMATE , FFTW_MEASURE , FFTW_EXHAUSTIVE use stat_mom , only : calc_moments use crest_param , only : PARAM , SPY , TER use stat_mom , only : moment_stat use miscellaneous , only : trans_corner2center , trans_center2corner implicit none private public :: calc_imp_acf , acf_wiener contains subroutine acf_wiener ( tab_in , tab_out , w , h , multi_fft ) !================================================================================================ !<@note Function that returns the *acf* of an array. !  ! \\begin{align*} !    acf(i,j) &= (z \\ast z)(i,j) = \\sum_{k,l}&#94;{n,n} z(k+1-i,l+1-j)z(k,l)  \\\\ !    TF(acf)  &= ACF = Z \\cdot Z                                          \\\\ !    acf      &= TF&#94;{-1}(ACF) = TF&#94;{-1}(Z&#94;2) ! \\end{align*} !  ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: w !! *2D array length* integer ( kind = I4 ), intent ( in ) :: h !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: tab_in !! *input array* real ( kind = R8 ), intent ( out ), dimension ( 1 : w , 1 : h ) :: tab_out !! *acf of the input array* logical ( kind = I4 ), intent ( in ), optional :: multi_fft !! *run parallel acfs?* integer ( kind = I4 ) :: lo2 , la2 real ( kind = R8 ) :: tmp logical ( kind = I4 ) :: parallel_fft integer ( kind = I4 ), dimension ( 1 : 2 ) :: loc_max complex ( kind = R8 ), dimension (:,:), allocatable :: tab_cmpl real ( kind = R8 ), dimension (:,:), allocatable :: tab_real allocate ( tab_cmpl ( 1 : w , 1 : h ) ) allocate ( tab_real ( 1 : w , 1 : h ) ) ! check for simultaneous fftw calculations !......................................... parallel_fft = . false . if ( present ( multi_fft ) ) parallel_fft = multi_fft !......................................... ! DFFT real -> complex !......................................... if ( parallel_fft ) then call tab_calc_fftw3_real_fwd ( tab_in = tab_in ( 1 : w , 1 : h ), & ! IN tab_ou = tab_cmpl ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN else call calc_fftw3_real_fwd ( tab_in = tab_in ( 1 : w , 1 : h ), & ! IN tab_ou = tab_cmpl ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h , & ! IN planner_flag = FFTW_MEASURE ) ! IN endif !......................................... tab_cmpl ( 1 : w , 1 : h ) = cmplx ( abs ( tab_cmpl ( 1 : w , 1 : h ) ) ** 2 , 0 , kind = R8 ) ! IFFT complex -> real !......................................... if ( parallel_fft ) then call tab_calc_fftw3_real_bwd ( tab_in = tab_cmpl ( 1 : w , 1 : h ), & ! IN tab_ou = tab_real ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN else call calc_fftw3_real_bwd ( tab_in = tab_cmpl ( 1 : w , 1 : h ), & ! IN tab_ou = tab_real ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h , & ! IN planner_flag = FFTW_MEASURE ) ! IN endif !......................................... ! the maximum is placed in the array center !......................................... call trans_corner2center ( tab_in = tab_real ( 1 : w , 1 : h ), & ! IN tab_out = tab_out ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN !......................................... ! the maximum is 1 !......................................... loc_max ( 1 : 2 ) = maxloc ( tab_out ( 1 : w , 1 : h ) ) lo2 = loc_max ( 1 ) la2 = loc_max ( 2 ) tmp = tab_out ( lo2 , la2 ) tab_out ( 1 : w , 1 : h ) = tab_out ( 1 : w , 1 : h ) / tmp !......................................... deallocate ( tab_cmpl ) deallocate ( tab_real ) return endsubroutine acf_wiener real ( kind = R8 ) function autocov_impo ( xi , xj , tau1 , tau2 , alpha , ang ) !================================================================================================ !<@note Function that returns  \\exp \\left(\\alpha \\sqrt{\\left(\\frac{x}{\\tau_1}\\right)&#94;2+ !                                                        \\left(\\frac{y}{\\tau_2}\\right)&#94;2} !                                      \\right)  ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: tau1 !! *correlation length along x* real ( kind = R8 ), intent ( in ) :: tau2 !! *correlation length along y* real ( kind = R8 ), intent ( in ) :: alpha !! *log(z)* where *z* is often 0.2 real ( kind = R8 ), intent ( in ) :: xi !! *x coordinate* real ( kind = R8 ), intent ( in ) :: xj !! *y coordinate* real ( kind = R8 ), intent ( in ) :: ang !! *angle* (rad) real ( kind = R8 ) :: x , y x = + cos ( ang ) * xi + sin ( ang ) * xj y = - sin ( ang ) * xi + cos ( ang ) * xj autocov_impo = exp ( alpha * sqrt ( ( x / tau1 ) ** 2 + ( y / tau2 ) ** 2 ) ) return endfunction autocov_impo subroutine calc_imp_acf ( long , larg , tau1 , tau2 , alpha , ang , tab_acf , apod ) !================================================================================================ !<@note Function that returns the theoretical autocorrelation function in an array.<br/> ! The autocorrelation function is supposed to be obtained from a real surface which must be periodic ! or nearly periodic (because of the use of FFTs). ! In addition, the surface is supposed to be 0 mean and normalized (\\sigma = 1 ), ! therefore *acf* is zero-mean and normalized so that its max value is 1.<br/> ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface acf width* integer ( kind = I4 ), intent ( in ) :: larg !! *surface acf height* logical ( kind = I4 ), intent ( in ) :: apod !! *apodization?* real ( kind = R8 ), intent ( in ) :: tau1 !! *first correlation length* real ( kind = R8 ), intent ( in ) :: tau2 !! *surface second correlation length* real ( kind = R8 ), intent ( in ) :: alpha !! *parameter that controls the expondential decrease* real ( kind = R8 ), intent ( in ) :: ang !! *acf ellipsis angle* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_acf !! *resulting acf* integer ( kind = I4 ) :: i , j , long2 , larg2 real ( kind = R8 ) :: xi , xj , s , c , coeff real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp ! acf array, centered and normalized !......................................... c = cos ( ang ) ; s = sin ( ang ) long2 = long / 2 larg2 = larg / 2 if ( long == 2 * ( long / 2 ) ) long2 = long / 2 + 1 if ( larg == 2 * ( larg / 2 ) ) larg2 = larg / 2 + 1 do j = 1 , larg do i = 1 , long xi = real ( i - long2 , kind = R8 ) * PARAM % surf_dx ! dimensioned coordinate x xj = real ( j - larg2 , kind = R8 ) * PARAM % surf_dy ! dimensioned coordinate y tab_acf ( i , j ) = autocov_impo ( xi = xi , & ! IN xj = xj , & ! IN tau1 = tau1 , & ! IN tau2 = tau2 , & ! IN alpha = alpha , & ! IN ang = ang ) ! IN enddo enddo !......................................... ! For long correlation lengths and roughness orientation, the acf is far from periodic ! Furthermore, far from the center, respecting the acf becomes less important. A windowing ! can be determined so that at a given distance from the center, the acf is lessened. !......................................... if ( apod ) then allocate ( tab_tmp ( 1 : long , 1 : larg ) ) coeff = 0.4 * PARAM % surf_width * c / tau1 ! along the primary axis (longest correlation length) the acf is reduce beyond ! 0.4 * image width * cos(ang) ! (0.4 * image width is less than half width) call apod2 ( tab_in = tab_acf ( 1 : long , 1 : larg ), & ! IN tab_out = tab_tmp ( 1 : long , 1 : larg ), & ! OUT long = long , & ! IN larg = larg , & ! IN tau1 = coeff * tau1 , & ! IN tau2 = coeff * tau2 , & ! IN ang = ang ) ! IN tab_acf ( 1 : long , 1 : larg ) = tab_tmp ( 1 : long , 1 : larg ) deallocate ( tab_tmp ) endif !......................................... ! acf centered tab_acf ( 1 : long , 1 : larg ) = tab_acf ( 1 : long , 1 : larg ) - sum ( tab_acf ( 1 : long , 1 : larg ) ) / ( long * larg ) ! acf scaled (maximum = 1) tab_acf ( 1 : long , 1 : larg ) = tab_acf ( 1 : long , 1 : larg ) / tab_acf ( long2 , larg2 ) return endsubroutine calc_imp_acf subroutine apod2 ( tab_in , tab_out , long , larg , tau1 , tau2 , ang ) !================================================================================================ !<@note Function that returns an apodized array.<br/> ! To prevent gaps from appearing after FFT (because of non periodic waves), the surface must ! be transformed, but not too much. Here a modified Tukey window is determined. The starting ! surface is not modified below the \"correlation lengths\". Above the correlation lengths, a ! smooth decrease is forced with a cosine squared. !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface acf length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface acf width* real ( kind = R8 ), intent ( in ) :: tau1 !! *surface first correlation length* real ( kind = R8 ), intent ( in ) :: tau2 !! *surface second correlation length* real ( kind = R8 ), intent ( in ) :: ang !! *ellipsis angle* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *input acf* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *apodized acf* real ( kind = R8 ) :: r2 , c0 , s0 , rd , rr , theta , theta_diag , x , y , t , a_min , sum_inn , sum_tab , sum_int integer ( kind = I4 ) :: i , j , k , long2 , larg2 , npt_out , n real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp ! first bissector angle (rad) theta_diag = atan2 ( PARAM % surf_height , PARAM % surf_width ) ! sine and cosine of the ellipsis angle c0 = cos ( ang ) ; s0 = sin ( ang ) long2 = long / 2 larg2 = larg / 2 if ( long == 2 * ( long / 2 ) ) long2 = long / 2 + 1 if ( larg == 2 * ( larg / 2 ) ) larg2 = larg / 2 + 1 tab_out ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) rr = 1.e6_R8 do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) cycle ! The correlation length is exceeded. ! The angle corresponding to the position (i,j) is calculated theta = atan2 ( y , x ) ; if ( theta < 0. ) theta = theta + 2 * Pi_R8 t = tan ( theta ) ! According the location of (i,j) (right, top, left or bottom) the line that begin at the surface center, passing by (i,j), ! ends on one of the four borders. if ( theta > 2 * Pi_R8 - theta_diag . or . theta <= + theta_diag ) then ; x = ( long - long2 ) * PARAM % surf_dx ; y = x * t ; endif if ( theta > + theta_diag . and . theta <= PI_R8 - theta_diag ) then ; y = ( larg - larg2 ) * PARAM % surf_dy ; x = y / t ; endif if ( theta > PI_R8 - theta_diag . and . theta <= PI_R8 + theta_diag ) then ; x = ( 1 - long2 ) * PARAM % surf_dx ; y = x * t ; endif if ( theta > PI_R8 + theta_diag . and . theta <= 2 * Pi_R8 - theta_diag ) then ; y = ( 1 - larg2 ) * PARAM % surf_dy ; x = y / t ; endif ! The same distance as above is calculated, from the center to the surface edge, then ... rd = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 rr = min ( rr , sqrt ( rd ) ) enddo enddo rr = 0.99 * rr sum_inn = 0 sum_tab = 0 sum_int = 0 npt_out = 0 n = 2 do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) then sum_inn = sum_inn + tab_in ( i , j ) cycle endif r2 = sqrt ( r2 ) if ( r2 >= rr ) then npt_out = npt_out + 1 cycle endif ! ... the modified Tuckey window can be determined. sum_tab = sum_tab + ( cos ( 0.5_R8 * PI_R8 * ( r2 - 1. ) / ( rr - 1. ) ) ** n ) * tab_in ( i , j ) sum_int = sum_int + ( r2 - 1. ) / ( rr - 1. ) enddo enddo a_min = - ( sum_inn + sum_tab ) / ( npt_out + sum_int ) do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) cycle r2 = sqrt ( r2 ) if ( r2 >= rr ) then tab_out ( i , j ) = a_min cycle endif ! ... the modified Tuckey window can be determined. tab_out ( i , j ) = ( cos ( 0.5_R8 * PI_R8 * ( r2 - 1. ) / ( rr - 1. ) ) ** n ) * tab_in ( i , j ) + a_min * ( r2 - 1. ) / ( rr - 1. ) enddo enddo allocate ( tab_tmp ( 1 : long , 1 : larg ) ) do k = 1 , 10 tab_tmp ( 1 : long , 1 : larg ) = tab_out ( 1 : long , 1 : larg ) do j = 1 + 1 , larg - 1 do i = 1 + 1 , long - 1 x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 r2 = sqrt ( r2 ) if ( r2 <= 0.98_R8 . or . ( r2 >= 1.02_R8 . and . r2 <= 0.98_R8 * rr ) . or . r2 >= 1.02_R8 * rr ) cycle tab_out ( i , j ) = ( 2 * tab_tmp ( i , j ) + tab_tmp ( i + 1 , j ) + tab_tmp ( i - 1 , j ) + & ! tab_tmp ( i , j + 1 ) + tab_tmp ( i , j - 1 ) + ( tab_tmp ( i + 1 , j - 1 ) + tab_tmp ( i - 1 , j - 1 ) + & ! tab_tmp ( i - 1 , j + 1 ) + tab_tmp ( i + 1 , j + 1 ) ) / sqrt ( 2._R8 ) ) / ( 6. + 4. / sqrt ( 2._R8 ) ) enddo enddo enddo deallocate ( tab_tmp ) return endsubroutine apod2 endmodule func_acf","tags":"","loc":"sourcefile/mod_func_acf.f90.html"},{"title":"mod_script.f90 – CREST","text":"This file depends on sourcefile~~mod_script.f90~~EfferentGraph sourcefile~mod_script.f90 mod_script.f90 sourcefile~mod_crest_param.f90 mod_crest_param.f90 sourcefile~mod_script.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_func_acf.f90 mod_func_acf.f90 sourcefile~mod_script.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_skku_profiles.f90 mod_skku_profiles.f90 sourcefile~mod_script.f90->sourcefile~mod_skku_profiles.f90 sourcefile~mod_func_acf.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_skku_profiles.f90->sourcefile~mod_crest_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_script.f90~~AfferentGraph sourcefile~mod_script.f90 mod_script.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_script.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: october, 23 2024 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.2em;\"> !        **Routines to decode the script** !  </span> module script !$ use omp_lib use data_arch , only : I4 , R4 , R8 , UN , PI_R8 , EPS_R8 use skku_profiles , only : calculs_skku_generique , build_heights use crest_param , only : PARAM , JOB , SPY , TER , FCT_TANG , FCT_EXPO use stat_mom , only : moment_stat , calc_moments , scramble use sort_arrays , only : sort_array2 , init_order use miscellaneous , only : get_unit , trans_corner2center , trans_center2corner , progress_bar_terminal use surfile , only : init_scal , write_surf , SCALE_SURF use func_acf , only : calc_imp_acf , acf_wiener use fftw3 , only : tab_init_fftw3_real , calc_fftw3_real_bwd , calc_fftw3_real_fwd , fftw_plan_with_nthreads , end_fftw3 , tab_end_fftw3_real , extend , apod , & ! SINGL_FFTW_ALLOCATED , NB_THREADS_FFT , FFT_DIM , FFTW_ESTIMATE , FFTW_MEASURE , FFTW_EXHAUSTIVE use filter , only : fft_filter , soften use gnufor , only : write_xyy_plots , run_gnuplot use anisotropy , only : ellipse_acf use pikaia_oop , only : pikaia_class use files , only : str_remove_chars implicit none integer ( kind = I4 ) :: LINE_READ , SAVE_LINE_READ integer ( kind = I4 ) :: I_ITER , NB_ITER private public :: read_job contains subroutine read_job ( job_file ) !================================================================================================ !<@note Function that reads a script file. Keywords are identified and corresponding actions are ! triggered. !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 512 ), intent ( in ) :: job_file !! job file with macros to execute integer ( kind = I4 ) :: vide character ( len = 512 ) :: keyword logical ( kind = I4 ) :: first ! script file call get_unit ( JOB ) open ( unit = JOB , file = trim ( job_file ), status = 'old' ) ! witness file call get_unit ( SPY ) open ( unit = SPY , file = \"out/spy.txt\" , status = 'unknown' ) LINE_READ = 0 first = . true . ! determine if calc_z_f has been already used ! default function used: the tangent function PARAM % func_gen = FCT_TANG ! default is 2 bounds when generating profiles PARAM % nparam = 2 o : do keyword = repeat ( ' ' , len ( keyword ) ) read ( JOB , * , iostat = vide ) keyword ; LINE_READ = LINE_READ + 1 ! remove unwanted characters from keyword keyword = str_remove_chars ( string = trim ( keyword ), chars = '- # *' ) write ( SPY , '(a6,I4.4,a)' ) \"line: \" , LINE_READ , ' ' , trim ( keyword ) selectcase ( keyword ( 1 : 8 ) ) case ( 'STA_SCRI' ) ! start script call sta_scri () case ( 'DEF_SIZE' ) ! image size call def_size () case ( 'NB_PROCS' ) ! number of threads call nb_procs () case ( 'STA_THEO' ) ! desired stat moments call sta_theo () case ( 'ACF_THEO' ) ! desired acf call acf_theo () case ( 'CALC_FFH' ) ! deigital filter call calc_ffh ( calc_m_stt = first ) case ( 'CALC_Z_I' ) ! starting heights call calc_z_i () case ( 'DIGI_FIL' ) ! apply digital filter call digi_fil () case ( 'CALC_ORD' ) ! determine heights order call calc_ord () case ( 'CALC_Z_F' ) ! final heights call calc_z_f ( to_be_made = first ) ! now, calc_z_f is considered as already ran first = . false . case ( 'STA_LOOP' ) ! loop start call sta_loop () case ( 'END_LOOP' ) ! loop end call end_loop () case ( 'SUB_SURF' ) ! extract the best surface call sub_surf () case ( 'SMOOTH__' ) ! low-pass filter call smooth__ () case ( 'SAVE_PRF' ) ! save image call save_img ( tab = PARAM % surf ) ! IN case ( 'CALC_ACF' ) ! determine the surface acf call calc_acf () case ( 'PLT__ACF' ) ! print the correlation graphs and/or determine ! if the stop criterion is reached. call plt__acf () case ( 'SAVE_ACF' ) ! save the acf surface call save_img ( tab = PARAM % imp_acf ) ! IN case ( 'END_SCRI' ) ! close the script reading call end_scri () exit o endselect enddo o close ( JOB ) return endsubroutine read_job subroutine plt__acf () !================================================================================================ !<@note Function that calculates the mean absolute difference between the desired Acf and ! the one obtained. ! However, the important zone where both should match is above acf__z - where the correlation ! lengths are determined. ! ! If the mean absolute difference is below the criterion, the loops to improve the acf are ! stopped. ! ! The function can also plot the acfs. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: i , w , h , mw , mh , uplot , ll logical ( kind = I4 ) :: is_x , is_y real ( kind = R8 ) :: lim_crit_acf , crit_acf , dxy , l1 , l2 character ( len = 512 ) :: plt_acf real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp real ( kind = R8 ), dimension ( 1 : 8 ) :: res read ( JOB , * ) lim_crit_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , \"Acf criterion \" , lim_crit_acf read ( JOB , * ) plt_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , trim ( plt_acf ) PARAM % crt_acf = lim_crit_acf ! mean absolute difference limit w = PARAM % width h = PARAM % height ! Mean absolute difference between the calculated acf and the theoretical acf !................................................................................... allocate ( tab_tmp ( 1 : w , 1 : h ) ) tab_tmp ( 1 : w , 1 : h ) = 0 where ( PARAM % imp_acf > PARAM % acf__z ) tab_tmp = abs ( PARAM % acf_surf - PARAM % imp_acf ) crit_acf = 100 * sum ( tab_tmp ( 1 : w , 1 : h ) ) / count ( tab_tmp ( 1 : w , 1 : h ) > 0 ) PARAM % res_acf = crit_acf deallocate ( tab_tmp ) write ( TER , * ) \"acf difference \" , crit_acf write ( SPY , * ) 'acf difference ' , crit_acf ! if the acf criterion is reached, the loops stop: a means is to modify the max number ! of loops, so that the main loop is exited. if ( lim_crit_acf > 0. . and . lim_crit_acf > crit_acf ) NB_ITER = 1 !................................................................................... ! Graphs? !................................................................................... ! if 'x' is present, plot the graph along the principal axis ! if 'y' is present, plot the graph along the secondary axis is_x = ( index ( trim ( plt_acf ), 'x' ) /= 0 ) is_y = ( index ( trim ( plt_acf ), 'y' ) /= 0 ) if ( . not .( is_x . or . is_y ) ) return ! ensure that w and h are odd, or act accordingly mw = w / 2 mh = h / 2 if ( w == 2 * ( w / 2 ) ) mw = w / 2 + 1 if ( h == 2 * ( h / 2 ) ) mh = h / 2 + 1 call ellipse_acf ( tabin = PARAM % acf_surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN p_acv = res ( 1 : 8 ), & ! OUT -> correlation lengths cut = PARAM % acf__z , & ! IN  -> z cut plane scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN  -> lags along x and y omp = . true . ) ! IN  -> use multithread? write ( TER , * ) res ( 1 : 2 ), res ( 4 ) write ( SPY , * ) 'acf lengths and roughness orientation ' , res ( 1 : 2 ), res ( 4 ) ! parameters for the plot ll = 2 * min ( mw , mh ) - 3 dxy = sqrt ( PARAM % surf_dx ** 2 + PARAM % surf_dy ** 2 ) call get_unit ( uplot ) if ( is_x ) call graph ( axis = 1 ) if ( is_y ) call graph ( axis = 2 ) contains subroutine graph ( axis ) !================================================================================================ !<@note Function that plots the graphs to compare the ACF along the primary and/or secondary axes. !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: axis !! *1 or 2 for primary or secondary axis* character ( len = 256 ) :: file_acf , file_gpl , title character ( len = 003 ) :: xlab real ( kind = R8 ) :: angle real ( kind = R8 ), allocatable , dimension (:) :: profile_acf_surf , profile_imp_acf allocate ( profile_acf_surf ( 1 : ll ) ) allocate ( profile_imp_acf ( 1 : ll ) ) if ( axis == 1 ) then angle = PARAM % a_acf file_acf = 'out/gpl/acfx.txt' file_gpl = 'out/gpl/acfx.gpl' title = '\"ACF comparison along primary axis X\"' xlab = '\"X\"' else angle = PARAM % a_acf + 9 0. file_acf = 'out/gpl/acfy.txt' file_gpl = 'out/gpl/acfy.gpl' title = '\"ACF comparison along secondary axis Y\"' xlab = '\"Y\"' endif ! extract the ACF profile along a particular direction call profile_at_angle ( tab = PARAM % acf_surf ( 1 : w , 1 : h ), profile = profile_acf_surf ( 1 : ll ), theta = angle ) call profile_at_angle ( tab = PARAM % imp_acf ( 1 : w , 1 : h ), profile = profile_imp_acf ( 1 : ll ), theta = angle ) open ( uplot , file = trim ( file_acf )) write ( uplot , * ) 'X' , '\"calculated acf\"' , '\"theoretical acf\"' do i = 1 , ll write ( uplot , * ) ( i - ll / 2 ) * dxy , real ( profile_acf_surf ( i ), kind = R4 ), & ! real ( profile_imp_acf ( i ), kind = R4 ) ! if ( i - ll / 2 < 0 ) then if ( profile_acf_surf ( i ) < PARAM % acf__z . and . profile_acf_surf ( i + 1 ) > PARAM % acf__z ) l1 = ( i - ll / 2 ) * dxy endif if ( i - ll / 2 > 0 . and . i < ll ) then if ( profile_acf_surf ( i ) > PARAM % acf__z . and . profile_acf_surf ( i + 1 ) < PARAM % acf__z ) l2 = ( i - ll / 2 ) * dxy endif enddo close ( uplot ) open ( uplot , file = trim ( file_gpl )) write ( uplot , '(a)' ) 'set title ' // trim ( title ) write ( uplot , '(a)' ) 'set xlabel ' // trim ( xlab ) write ( uplot , '(a)' ) 'set ylabel \"ACF\"' write ( uplot , '(a,f4.2,a,f5.2,a)' ) \"set arrow from graph 0, first \" , PARAM % acf__z , & ! \" to graph 1, first \" , PARAM % acf__z , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2,a)' ) \"set arrow from \" , l1 , \", graph 0 to \" , & ! l1 , \",\" , PARAM % acf__z , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2,a)' ) \"set arrow from \" , l2 , \", graph 0 to \" , & ! l2 , \",\" , PARAM % acf__z , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2)' ) 'set label \"L1 = ' , res ( axis ), '\" at ' , l2 , ',' , PARAM % acf__z + 0.1 write ( uplot , '(a,i2,a)' ) 'plot \"' // trim ( file_acf ) // '\" using 1:2 with lines title \"acf real surface\", \"' // trim ( file_acf ) // '\" using 1:3 with lines title \"theoretical acf\"' write ( uplot , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( uplot , '(a)' ) 'q' close ( uplot ) call system ( 'gnuplot \"' // trim ( file_gpl ) // '\"' ) deallocate ( profile_acf_surf ) deallocate ( profile_imp_acf ) return endsubroutine graph subroutine profile_at_angle ( tab , profile , theta ) !================================================================================================ !<@note Function that extract the ACF profile along a particular direction !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: tab real ( kind = R8 ), intent ( in ) :: theta real ( kind = R8 ), intent ( out ), dimension ( 1 : ll ) :: profile integer ( kind = I4 ) :: p , nx , ny real ( kind = R8 ) :: r , x , y , xb , yb , xm , ym , xp , yp , h1 , h2 , h3 , h4 , hh do p = - ll / 2 , ll / 2 !  identifying a point on the diameter r = p !  corresponding algebraic radius !  projection on x and y of the point marked by its radius and angle !  by taking the lower integer, we have the number of the bottom row and left-hand column of the rectangle !  the remainder (x-nx) represents the abscissa of the point in the rectangle with sides=1 !  the 0.9999 coefficient is used to avoid falling right on an existing point x = mw + r * cos ( theta * PI_R8 / 180 ) * 0.9999_R8 ; nx = floor ( x ) ; xb = x - nx y = mh + r * sin ( theta * PI_R8 / 180 ) * 0.9999_R8 ; ny = floor ( y ) ; yb = y - ny xm = UN - xb ; xp = xb ym = UN - yb ; yp = yb if ( nx + 1 <= w . and . ny + 1 <= h . and . & ! nx >= 1 . and . ny >= 1 ) then ! attention r may be greater than lo2 or la2 h1 = tab ( nx , ny ) h2 = tab ( nx + 1 , ny ) h3 = tab ( nx + 1 , ny + 1 ) h4 = tab ( nx , ny + 1 ) hh = h1 * xm * ym + & ! h2 * xp * ym + & ! h3 * xp * yp + & ! h4 * xm * yp ! profile ( p + ll / 2 + 1 ) = hh endif enddo return endsubroutine profile_at_angle endsubroutine plt__acf subroutine calc_acf () !================================================================================================ !<@note Function that returns the autocorrelation function of a surface PARAM%acf_surf ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h w = PARAM % width h = PARAM % height call acf_wiener ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! IN tab_out = PARAM % acf_surf ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h ) ! IN return endsubroutine calc_acf subroutine sta_loop () !! Starting the loop implicit none read ( JOB , * ) NB_ITER ; LINE_READ = LINE_READ + 1 write ( SPY , * ) LINE_READ , I_ITER , '/' , NB_ITER I_ITER = 1 ! the account begins SAVE_LINE_READ = LINE_READ ! remember where to go when rewinding return endsubroutine sta_loop subroutine end_loop () !! The loop ends here implicit none integer ( kind = I4 ) :: i_ligne if ( I_ITER < NB_ITER ) then rewind ( JOB ) ! the maximum number of loops is not reached, ! go to the begining of the script else I_ITER = NB_ITER ! the maximum number of loops is reached return endif ! return to the beginning of the loop LINE_READ = SAVE_LINE_READ do i_ligne = 1 , SAVE_LINE_READ read ( JOB , * ) enddo I_ITER = I_ITER + 1 return endsubroutine end_loop subroutine sub_surf () !================================================================================================ !<@note Function that returns the best subsurface from the final surface. ! ! We are here because a non periodic resulting surface is required. To do that, a wider ! periodic surface is created, and it matches the required moments and acf. ! ! However, sub-sampling the surface into a smaller surface that matches the required size ! will result in degraded moments and acf. Hence, several locations are tested to find the ! best subsurface. ! ! Note that the right moments can always be obtained by substitution, respecting the order of heights. ! However, the acf will be slightly impacted. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: i , w , h , l , we , he , dw , dh , ndw , ndh , idw , jdh , ib , ie , jb , je , best_idw , best_jdh integer ( kind = I4 ) :: n_seek , inc_dw , inc_dh , nn_res , res_ratio real ( kind = R8 ) :: best_acf , res_acf , size_ratio character ( len = 100 ) :: text type ( MOMENT_STAT ) :: m_res integer ( kind = I4 ), dimension ( 1 : 2 ) :: best_ind integer ( kind = I4 ), allocatable , dimension (:) :: order_tmp real ( kind = R8 ), allocatable , dimension (:,:) :: sav_surf , surf_tmp , acf_tmp , tab_res_acf real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp read ( JOB , * ) n_seek ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"n_seek  \" , n_seek ! n_seek is the number of subsurfaces explored if ( PARAM % periodic ) return ! reset the FFTW configuration because from now on, the acf will be calculated on smaller surfaces call end_fftw3 () ! extended surface size we = PARAM % width he = PARAM % height allocate ( sav_surf ( 1 : we , 1 : he ) ) ! save the extended surface sav_surf ( 1 : we , 1 : he ) = PARAM % surf ( 1 : we , 1 : he ) ! reset previous arrays deallocate ( PARAM % surf ) deallocate ( PARAM % imp_acf ) deallocate ( PARAM % acf_surf ) call fftw_plan_with_nthreads ( nthreads = 1 ) NB_THREADS_FFT = omp_get_max_threads () ! the new image size is the one of the subsurface, because it is the size defined by the user w = PARAM % sub_width h = PARAM % sub_height l = PARAM % sub_npts call tab_init_fftw3_real ( long = w , larg = h , plan_flag = FFTW_MEASURE ) PARAM % width = w PARAM % height = h PARAM % npts = l allocate ( PARAM % surf ( 1 : w , 1 : h ) ) allocate ( PARAM % acf_surf ( 1 : w , 1 : h ) ) ! build a smaller set of heights that match the required moments call build_heights ( vec_out = PARAM % vect_h ( 1 : l ), & ! use_fct_expo = ( PARAM % m_end % ku < 1.10 * PARAM % m_end % sk ** 2 + 1. ), & ! stats_in = PARAM % m_end , & ! lg = l ) ! allocate ( PARAM % imp_acf ( 1 : w , 1 : h ) ) ! recalculate the theoretical acf, for the new size surface call calc_imp_acf ( long = w , & ! IN larg = h , & ! IN apod = PARAM % apod , & ! IN tau1 = PARAM % l_acf1 , & ! IN tau2 = PARAM % l_acf2 , & ! IN alpha = log ( PARAM % acf__z ), & ! IN ang = PARAM % a_acf * PI_R8 / 180 , & ! IN tab_acf = PARAM % imp_acf ( 1 : w , 1 : h )) ! OUT ! difference between old and new size: hence, there will be dw*dh possible locations ! for the subsurface dw = we - w dh = he - h ! initialize the best acf result (mean absolute difference) and subsurface locations best_acf = 1.e6_R8 best_idw = 0 best_jdh = 0 size_ratio = dw / dh ! Number of locations along x and y. It respects the total number to be explored, as set ! by the user and the size ratio of the surface ndw = nint ( sqrt ( n_seek / size_ratio ) ) ndh = nint ( real ( n_seek , kind = R8 ) / ndw ) ! ndw and ndh are modified to be mumtiples of the number of threads, but the product ! should not be too far from n_seek if ( size_ratio > 1. ) then ndw = NB_THREADS_FFT * ( int ( ndw / NB_THREADS_FFT ) + 1 ) ndh = NB_THREADS_FFT * ( int ( ndh / NB_THREADS_FFT ) ) else ndw = NB_THREADS_FFT * ( int ( ndw / NB_THREADS_FFT ) ) ndh = NB_THREADS_FFT * ( int ( ndh / NB_THREADS_FFT ) + 1 ) endif ! don't exceed the maximums ndw = min ( ndw , dw ) ndh = min ( ndh , dh ) ! increments for looping inc_dw = dw / ndw inc_dh = dh / ndh ! result storage allocate ( tab_res_acf ( 1 : ndw , 1 : ndh ) ) tab_res_acf ( 1 : ndw , 1 : ndh ) = - 1 allocate ( surf_tmp ( 1 : w , 1 : h ) ) allocate ( acf_tmp ( 1 : w , 1 : h ) ) allocate ( order_tmp ( 1 : l ) ) allocate ( tab_tmp ( 1 : l ) ) call progress_bar_terminal ( val = 0 , max_val = ndw * ndh , init = . true .) !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_THREADS_FFT) !$OMP DO SCHEDULE (STATIC, ndw/NB_THREADS_FFT) PRIVATE(ib, ie, jb, je, jdh, surf_tmp, tab_tmp, order_tmp, acf_tmp, i, m_res, res_acf, nn_res, res_ratio, text) do idw = 1 , ndw ib = idw * inc_dw ie = ib + w - 1 do jdh = 1 , ndh jb = jdh * inc_dh je = jb + h - 1 surf_tmp ( 1 : w , 1 : h ) = sav_surf ( ib : ie , jb : je ) !....................................................................................... tab_tmp ( 1 : l ) = reshape ( surf_tmp ( 1 : w , 1 : h ), [ l ] ) ! store the subsurface height order call init_order ( order = order_tmp ( 1 : l ), & ! OUT n = l ) ! IN call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! INOUT tab0 = order_tmp ( 1 : l ), & ! INOUT n = l ) ! IN ! replace old heights with new ones that matches required moments do i = 1 , l tab_tmp ( order_tmp ( i ) ) = PARAM % vect_h ( i ) enddo surf_tmp ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call calc_moments ( tab = tab_tmp ( 1 : l ), & ! IN mx = m_res , & ! OUT nb_mom = 4 ) ! IN surf_tmp ( 1 : w , 1 : h ) = ( surf_tmp ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si !....................................................................................... ! calculate the acf call acf_wiener ( tab_in = surf_tmp ( 1 : w , 1 : h ), & ! IN tab_out = acf_tmp ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h , & ! IN multi_fft = . true . ) ! IN ! calculate the result (mean absolute difference between theoretical acf and calculated acf) call calc_res_acf ( acf_surf = acf_tmp ( 1 : w , 1 : h ), & ! IN imp_acf = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN acf__z = PARAM % acf__z , & ! IN crit_acf = res_acf , & ! OUT w = w , & ! IN h = h ) ! IN tab_res_acf ( idw , jdh ) = res_acf ! update progressbar !$OMP CRITICAL nn_res = count ( tab_res_acf > 0 ) call progress_bar_terminal ( val = nn_res , max_val = ndw * ndh , init = . false .) !$OMP END CRITICAL enddo enddo !$OMP END DO !$OMP END PARALLEL ! find the best subsurface best_ind ( 1 : 2 ) = minloc ( tab_res_acf ) idw = best_ind ( 1 ) jdh = best_ind ( 2 ) ib = idw * ( dw / ndw ) ie = ib + w - 1 jb = jdh * ( dh / ndh ) je = jb + h - 1 PARAM % surf ( 1 : w , 1 : h ) = sav_surf ( ib : ie , jb : je ) ! redo calculations on the best subsurface !....................................................................................... tab_tmp ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call init_order ( order = PARAM % order ( 1 : l ), & ! n = l ) ! call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! tab0 = PARAM % order ( 1 : l ), & ! n = l ) ! do i = 1 , l tab_tmp ( PARAM % order ( i ) ) = PARAM % vect_h ( i ) enddo PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call calc_moments ( tab = tab_tmp ( 1 : l ), & ! mx = m_res , & ! nb_mom = 4 ) ! PARAM % surf ( 1 : w , 1 : h ) = ( PARAM % surf ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si !....................................................................................... call tab_end_fftw3_real () deallocate ( sav_surf ) deallocate ( tab_tmp ) deallocate ( surf_tmp ) deallocate ( acf_tmp ) deallocate ( order_tmp ) deallocate ( tab_res_acf ) return endsubroutine sub_surf subroutine calc_res_acf ( acf_surf , imp_acf , crit_acf , acf__z , w , h ) !================================================================================================ !<@note Function that returns *crit_acf* the mean absolute difference between theoretical ! and calculated acfs ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: w !! *surface acf width (points)* integer ( kind = I4 ), intent ( in ) :: h !! *surface acf height (points)* real ( kind = R8 ), intent ( in ) :: acf__z !! *plane elevation z where correlation lengths are calculated* real ( kind = R8 ), intent ( out ) :: crit_acf !! *mean absolute difference between theoretical and calculated acfs* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: acf_surf !! *calculated surface acf* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: imp_acf !! *required surface acf* real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp allocate ( tab_tmp ( 1 : w , 1 : h ) ) tab_tmp ( 1 : w , 1 : h ) = 0 where ( imp_acf > acf__z ) tab_tmp = abs ( acf_surf - imp_acf ) crit_acf = 100 * sum ( tab_tmp ( 1 : w , 1 : h ) ) / count ( tab_tmp ( 1 : w , 1 : h ) > 0 ) deallocate ( tab_tmp ) return endsubroutine calc_res_acf subroutine save_img ( tab ) !================================================================================================ !<@note Function that save an array *tab* as a digital surf file. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension (:,:) :: tab !! *a surface to save as a .sur file* integer ( kind = I4 ) :: w ! image width integer ( kind = I4 ) :: h ! image height integer ( kind = I4 ), dimension ( 1 : 2 ) :: shape_tab character ( len = 512 ) :: nom_surf type ( SCALE_SURF ) :: scale_img shape_tab = shape ( tab ) w = shape_tab ( 1 ) h = shape_tab ( 2 ) nom_surf = repeat ( \" \" , len ( nom_surf ) ) read ( JOB , * ) nom_surf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , trim ( nom_surf ) call init_scal ( scal = scale_img , & ! out; creates a surface type, containing ... nx = w , & !  in; ... the number of points along x ... ny = h , & !  in; ... the number of points along y ... lx = PARAM % surf_width , & !  in; ... the length (default unit : m) ... ly = PARAM % surf_height , & !  in; ... the width ... unit_z = 'm' ) !  in; ... and the unit along z. call write_surf ( nom_fic = trim ( nom_surf ), & ! tab_s = tab ( 1 : w , 1 : h ), & ! scal = scale_img ) ! return endsubroutine save_img subroutine smooth__ () !================================================================================================ !<@note Function that applies a low-pass filter to the surface PARAM%surf ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp type ( MOMENT_STAT ) :: m_res real ( kind = R8 ) :: cutoff read ( JOB , * ) cutoff ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"cutoff \" , cutoff PARAM % cutoff = cutoff w = PARAM % width h = PARAM % height allocate ( tab_tmp ( 1 : w , 1 : h ) ) call fft_filter ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN cutoff = PARAM % cutoff , & ! IN bf_tab = tab_tmp ( 1 : w , 1 : h ), & ! OUT multi_fft = . false ., & ! IN pad = - 1._R8 , & ! IN ext = 'constant' ) ! IN call calc_moments ( tab = tab_tmp ( 1 : w , 1 : h ), & ! IN mx = m_res , & ! OUT nb_mom = 2 ) ! IN ! the surface has been modified, so recenter and rescale PARAM % surf ( 1 : w , 1 : h ) = ( tab_tmp ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si deallocate ( tab_tmp ) return endsubroutine smooth__ subroutine calc_z_f ( to_be_made ) !================================================================================================ !<@note Function that returns PARAM%surf, the surface made of heights with the required statistical ! moments, in the right order. ! ! - The heights come from the vector PARAM%vect_h ! - the heights order is stored in the vector PARAM%order ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none logical ( kind = I4 ), intent ( in ) :: to_be_made !! *whether to determine the heights, or reuse them* integer ( kind = I4 ) :: i integer ( kind = I4 ) :: w , h , l real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp type ( MOMENT_STAT ) :: m_res w = PARAM % width h = PARAM % height l = PARAM % npts ! final set of heights are generated to meet the desired statistical moments ! It is done once. if ( to_be_made ) then write ( SPY , * ) 'calc_z_f -> final set of heights are generated to meet the desired statistical moments' call build_heights ( vec_out = PARAM % vect_h ( 1 : l ), & ! OUT use_fct_expo = ( PARAM % m_end % ku < 1.10 * PARAM % m_end % sk ** 2 + 1. ), & ! IN stats_in = PARAM % m_end , & ! IN lg = l ) ! IN endif ! The heights stored in PARAM%vect_h(1:lg) are reinjected in PARAM%surf, with respect to the order PARAM%order write ( SPY , * ) 'calc_z_f -> substitution of PARAM%surf with PARAM%vect_h with respect to PARAM%order' allocate ( tab_tmp ( 1 : l ) ) do i = 1 , l tab_tmp ( PARAM % order ( i ) ) = PARAM % vect_h ( i ) enddo PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call calc_moments ( tab = tab_tmp ( 1 : l ), & ! IN mx = m_res , & ! OUT nb_mom = 2 ) ! IN PARAM % surf ( 1 : w , 1 : h ) = ( PARAM % surf ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si deallocate ( tab_tmp ) return endsubroutine calc_z_f subroutine calc_ord () !================================================================================================ !<@note Function that returns the vector PARAM%order that contains the heights order. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: l , w , h real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( tab_tmp ( 1 : l ) ) tab_tmp ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call init_order ( order = PARAM % order ( 1 : l ), & ! OUT n = l ) ! IN call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! IN tab0 = PARAM % order ( 1 : l ), & ! OUT n = l ) ! IN deallocate ( tab_tmp ) return endsubroutine calc_ord subroutine digi_fil () !================================================================================================ !<@note Function that applies the digital filter to the random heights ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h complex ( kind = R8 ), dimension (:,:), allocatable :: cmple complex ( kind = R8 ), dimension (:,:), allocatable :: ftab ! FFT(tab_prf) type ( MOMENT_STAT ) :: m_res write ( SPY , * ) 'digi_fil -> 1 - extends then windows PARAM%surf to calculate its FFT ftab' write ( SPY , * ) 'digi_fil -> 2 - multiplies ftab and the digital filter PARAM%fhi, then FFT-1' write ( SPY , * ) 'digi_fil -> 3 - retrieves PARAM%surf by removing the padded extension' w = PARAM % width h = PARAM % height allocate ( cmple ( 1 : w , 1 : h ) ) ! allocate ( ftab ( 1 : w , 1 : h ) ) ! cmple ( 1 : w , 1 : h ) = cmplx ( PARAM % surf ( 1 : w , 1 : h ), 0 , kind = R8 ) call calc_fftw3_real_fwd ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! IN tab_ou = cmple ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN ftab ( 1 : w , 1 : h ) = cmple ( 1 : w , 1 : h ) where ( abs ( cmple ( 1 : w , 1 : h )) > 100 * EPS_R8 ) ftab ( 1 : w , 1 : h ) = cmple ( 1 : w , 1 : h ) / abs ( cmple ( 1 : w , 1 : h ) ) elsewhere ftab ( 1 : w , 1 : h ) = cmplx ( UN , 0._R8 , kind = R8 ) endwhere write ( SPY , * ) 'ftab normalized' !-------------------------------------------------------------------- ! FFT of the filter * FFT of the random heights !-------------------------------------------------------------------- cmple ( 1 : w , 1 : h ) = PARAM % fhi ( 1 : w , 1 : h ) * ftab ( 1 : w , 1 : h ) call calc_fftw3_real_bwd ( tab_in = cmple ( 1 : w , 1 : h ), & ! IN tab_ou = PARAM % surf ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN ! signal centré et normé call calc_moments ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN mx = m_res , & ! OUT nb_mom = 4 ) ! IN PARAM % surf ( 1 : w , 1 : h ) = ( PARAM % surf ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si write ( SPY , * ) 'sk ku fin ' , m_res % sk , m_res % ku deallocate ( cmple ) deallocate ( ftab ) return endsubroutine digi_fil subroutine calc_z_i () !================================================================================================ !<@note Function that returns the starting surface of random heights ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp type ( MOMENT_STAT ) :: m_res w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( tab_tmp ( 1 : l ) ) ! starting set of heights are generated to meet the statistical moments prescribed by calc_ffh write ( SPY , * ) 'calc_z_i -> starting set of heights are generated to meet the prescribed statistical moments by calc_ffh' call build_heights ( vec_out = tab_tmp ( 1 : l ), & ! OUT use_fct_expo = ( PARAM % m_stt % ku < 1.34 * PARAM % m_stt % sk ** 2 + 1. ), & ! IN stats_in = PARAM % m_stt , & ! IN lg = l ) ! IN call calc_moments ( tab = tab_tmp ( 1 : l ), & ! IN mx = m_res , & ! OUT nb_mom = 4 ) ! IN write ( TER , * ) 'starting statistical moments ' , m_res % mu , m_res % va , m_res % sk , m_res % ku tab_tmp ( 1 : l ) = ( tab_tmp ( 1 : l ) - m_res % mu ) / m_res % si call scramble ( tab = tab_tmp ( 1 : l ), & ! INOUT lg = l ) ! IN PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) deallocate ( tab_tmp ) return endsubroutine calc_z_i subroutine calc_ffh ( calc_m_stt ) !================================================================================================ !<@note Function that returns ... ! ! - the digital filter to apply to the height distribution  \\text{PARAM%fhi} = \\sqrt{ \\left| FFT(\\text{PARAM%imp_acf}) \\right| }  ! - the starting statistical moments PARAM%m_stt%sk, PARAM%m_stt%ku ! - whether the exponential function will be used, PARAM%reajust_skku ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none logical ( kind = I4 ), intent ( inout ) :: calc_m_stt !! *compute starting moments ?* integer ( kind = I4 ) :: w , h , l complex ( kind = R8 ), dimension (:,:), allocatable :: cmple real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp type ( MOMENT_STAT ) :: m_h w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( cmple ( 1 : w , 1 : h ) ) write ( SPY , * ) 'calc_ffh -> PARAM%fhi = sqrt( abs( FFT(PARAM%imp_acf) ) )' call calc_fftw3_real_fwd ( tab_in = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN tab_ou = cmple ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN PARAM % fhi ( 1 : w , 1 : h ) = sqrt ( abs ( cmple ( 1 : w , 1 : h ) ) ) if ( calc_m_stt ) then ! determine starting statistical moments, if not already done !....................................................................... write ( SPY , * ) 'calc_ffh -> PARAM%m_stt calculated' cmple ( 1 : w , 1 : h ) = cmplx ( PARAM % fhi ( 1 : w , 1 : h ), 0 , kind = R8 ) allocate ( tab_tmp ( 1 : w , 1 : h ) ) call calc_fftw3_real_bwd ( tab_in = cmple ( 1 : w , 1 : h ), & ! IN tab_ou = tab_tmp ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN call calc_moments ( tab = tab_tmp ( 1 : w , 1 : h ), & ! IN mx = m_h , & ! OUT nb_mom = 4 ) ! IN PARAM % m_stt % mu = 0 PARAM % m_stt % va = 1 PARAM % m_end % mu = 0 PARAM % m_end % va = m_h % va PARAM % m_stt % sk = sqrt ( UN * l ) * PARAM % m_end % sk / m_h % sk PARAM % m_stt % ku = l * ( PARAM % m_end % ku - 3. ) / ( m_h % ku - 3. ) + 3. PARAM % reajust_skku = . false . if ( PARAM % m_stt % ku < PARAM % m_stt % sk ** 2 + 1. ) then PARAM % m_stt % ku = PARAM % m_stt % sk ** 2 + 1. PARAM % reajust_skku = . true . endif deallocate ( tab_tmp ) !....................................................................... else write ( SPY , * ) 'calc_ffh -> PARAM%m_stt NOT calculated, set to PARAM%m_end' PARAM % m_stt % sk = PARAM % m_end % sk PARAM % m_stt % ku = PARAM % m_end % ku endif deallocate ( cmple ) return endsubroutine calc_ffh subroutine sta_scri () !! Start the script reading implicit none ! Initializes the state of the pseudorandom number generator used by RANDOM_NUMBER. call random_init ( repeatable = . false ., image_distinct = . true .) return endsubroutine sta_scri subroutine def_size () !! Geometrical characteristics of the numerical surface implicit none integer ( kind = I4 ) :: w , h logical ( kind = I4 ) :: period real ( kind = R8 ) :: lw , lh read ( JOB , * ) w , h ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"width, height  \" , w , h read ( JOB , * ) lw , lh ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"img width and height (m) \" , lw , lh read ( JOB , * ) period ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"periodic surface? \" , period PARAM % periodic = period PARAM % width = w PARAM % height = h PARAM % npts = w * h PARAM % surf_width = lw PARAM % surf_height = lh PARAM % surf_dx = lw / w PARAM % surf_dy = lh / h return endsubroutine def_size subroutine acf_theo () !================================================================================================ !<@note Function that returns the theoretical acf PARAM%imp_acf. ! ! If the surface to generate is non periodic, the starting surface is extended. The final surface ! will be a part of it. Indeed the extended surface will be periodic, because the use of FFTs. ! If a roughness orientation is chosen, in addition with long correlation lengths, a windowing ! should be applied to the acf to prevent from artifacts (vertical and horizontal lines) ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h logical ( kind = I4 ) :: with_apod real ( kind = R8 ) :: ratio , a , b , c , s , lx , ly real ( kind = R8 ), dimension ( 1 : 8 ) :: res read ( JOB , * ) PARAM % l_acf1 , PARAM % l_acf2 , PARAM % acf__z ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"l_acf \" , PARAM % l_acf1 , PARAM % l_acf2 , PARAM % acf__z if ( PARAM % l_acf1 < PARAM % l_acf2 ) stop \"inverser l_acf1, l_acf2\" read ( JOB , * ) PARAM % a_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"a_acf \" , PARAM % a_acf write ( SPY , * ) 'acf_theo -> determines the theoretical acf with a padded size, so correlation lengths are adjusted accordingly' read ( JOB , * ) with_apod ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"apod \" , with_apod PARAM % apod = with_apod w = PARAM % width h = PARAM % height if ( . not . PARAM % periodic ) then PARAM % sub_width = w PARAM % sub_height = h PARAM % sub_npts = w * h PARAM % sub_surf_width = PARAM % surf_width PARAM % sub_surf_height = PARAM % surf_height ! the surface must be extended a = PARAM % l_acf1 b = PARAM % l_acf2 c = cos ( PARAM % a_acf * PI_R8 / 180 ) s = sin ( PARAM % a_acf * PI_R8 / 180 ) lx = sqrt ( ( a * c ) ** 2 + ( b * s ) ** 2 ) ly = sqrt ( ( a * s ) ** 2 + ( b * c ) ** 2 ) w = w + nint ( lx / PARAM % surf_dx ) h = h + nint ( ly / PARAM % surf_dy ) ! update sizes PARAM % width = w PARAM % height = h PARAM % npts = w * h PARAM % surf_width = w * PARAM % surf_dx PARAM % surf_height = h * PARAM % surf_dy endif allocate ( PARAM % surf ( 1 : w , 1 : h ) ) allocate ( PARAM % fhi ( 1 : w , 1 : h ) ) allocate ( PARAM % imp_acf ( 1 : w , 1 : h ) ) allocate ( PARAM % order ( 1 : w * h ) ) allocate ( PARAM % vect_h ( 1 : w * h ) ) allocate ( PARAM % acf_surf ( 1 : w , 1 : h ) ) ratio = PARAM % l_acf2 / PARAM % l_acf1 ! acf_theo is the theoretical acf for the normal surface call calc_imp_acf ( long = w , & ! IN larg = h , & ! IN apod = with_apod , & ! IN tau1 = PARAM % l_acf1 , & ! IN tau2 = PARAM % l_acf2 , & ! IN alpha = log ( PARAM % acf__z ), & ! IN ang = PARAM % a_acf * PI_R8 / 180 , & ! IN tab_acf = PARAM % imp_acf ( 1 : w , 1 : h )) ! OUT call ellipse_acf ( tabin = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN p_acv = res ( 1 : 8 ), & ! OUT cut = PARAM % acf__z , & ! IN scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN omp = . true . ) ! IN return endsubroutine acf_theo subroutine nb_procs () !! Number of concurrent threads implicit none integer ( kind = I4 ) :: nb_th read ( JOB , * ) nb_th ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , 'nb_procs' , nb_th select case ( nb_th ) case ( 0 ) ! no multihreading PARAM % nb_threads = 1 NB_THREADS_FFT = 1 case ( - 1 ) ! determined by system PARAM % nb_threads = omp_get_num_procs () NB_THREADS_FFT = PARAM % nb_threads case default stop 'Bad choice \"nb_procs\" in \"mod_script\"' endselect return endsubroutine nb_procs subroutine sta_theo () !! Required statistical moments implicit none read ( JOB , * ) PARAM % m_end % sk , PARAM % m_end % ku ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"m_end \" , PARAM % m_end % sk , PARAM % m_end % ku return endsubroutine sta_theo subroutine end_scri () !! End of script implicit none close ( SPY ) if ( allocated ( PARAM % imp_acf ) ) deallocate ( PARAM % imp_acf ) if ( allocated ( PARAM % acf_surf ) ) deallocate ( PARAM % acf_surf ) if ( allocated ( PARAM % surf ) ) deallocate ( PARAM % surf ) if ( allocated ( PARAM % vect_h ) ) deallocate ( PARAM % vect_h ) if ( allocated ( PARAM % fhi ) ) deallocate ( PARAM % fhi ) if ( allocated ( PARAM % order ) ) deallocate ( PARAM % order ) call end_fftw3 () return endsubroutine end_scri endmodule script","tags":"","loc":"sourcefile/mod_script.f90.html"}]}
var tipuesearch = {"pages":[{"title":" CREST ","text":"CREST Table of Contents Brief description Building CREST Dependencies Third party components Typical use Full description Documentation License Brief description CREST - C omputational R esource for E roded S urface T opology - is designed to generate numerical rough surfaces that respect: size: regular grid statistical moments: Skewness and Kurtosis principal correlation lengths: and asperity orientation: angle periodicity: with/without The programs are written in recent Fortran (2003+) top Building CREST Make sure that the dependencies described below are built. Debug mode: make debug Normal mode: make Dependencies CREST needs some components that are available through the following packages: TOOLIB … Some general tools like FFT, file handling, minimization, sorting, etc. TPGLIB … Some more specific programs like filtering, anisotropy analysis, derivation, etc. As a consequence the three packages have to be downloaded. top Third party components TOOLIB also uses external codes such as: FFTW3.3 … Fastest Fourier Transform in the West … GNU General Public License Pikaia_oop … Modern Fortran Edition of the Pikaia Genetic Algorithm … BSD like GNUFOR … Gnuplot Fortran … GNU General Public License Bspline-fortran … Multidimensional B-Spline Interpolation of Data on a Regular Grid … BSD like .sur surface files can be visualized and analyzed with Gwyddion software , a modular program for SPM (scanning probe microscopy) data visualization and analysis. Typical use The program main reads a script file my_script.md where the following parameters are defined: image size (pix) surface size (m) periodicity correlation lengths roughness orientation number of available threads statistical parameters output surface name … as well as the algorithm for rough surface generation. Run: ./main cfg/my_script.md top Full description Test 1 size m size n width (m) height (m) periodic? Ssk Sku 1024 512 200.e-6 100.e-6 True 30.e-6 10.e-6 -3. 15. Run: ./main cfg/test01.md Result: test01_img Test 2 size m size n width (m) height (m) periodic? Ssk Sku 1024 512 200.e-6 100.e-6 False 30.e-6 10.e-6 -3. 15. Run: ./main cfg/test02.md Result: test02_img top Documentation The documentation is automatically generated with FORD , an automatic documentation generator for modern Fortran programs. top License This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but without any warrenty; without even the implied warranty of merchantability or fitness for a particular purpose. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see the GNU website . Developer Info Arthur Francisco","tags":"home","loc":"index.html"},{"title":"acf_param – CREST ","text":"type, public :: acf_param Inherited by type~~acf_param~~InheritedByGraph type~acf_param acf_param type~param_crest param_crest type~param_crest->type~acf_param orig_surf, curr_surf Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=R8), public :: ang roughness orientation real(kind=R8), public :: cl1 correlation principal length at z=acf__z real(kind=R8), public :: cl2 correlation secondary length at z=acf__z real(kind=R8), public :: cut acf cutting plane z, for correlation lengths determination Source Code type acf_param real ( kind = R8 ) :: cl1 !! *correlation principal length at z=acf__z* real ( kind = R8 ) :: cl2 !! *correlation secondary length at z=acf__z* real ( kind = R8 ) :: cut !! *acf cutting plane z, for correlation lengths determination* real ( kind = R8 ) :: ang !! *roughness orientation* endtype acf_param","tags":"","loc":"type/acf_param.html"},{"title":"param_crest – CREST ","text":"type, public :: param_crest Inherits type~~param_crest~~InheritsGraph type~param_crest param_crest moment_stat moment_stat type~param_crest->moment_stat m_ini, m__LF, m__HF, m_end, m_inp, m_stt pikaia_class pikaia_class type~param_crest->pikaia_class pik_class type~acf_param acf_param type~param_crest->type~acf_param orig_surf, curr_surf Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=R8), public, allocatable, dimension(:,:) :: acf_surf calculated autocorrelation logical(kind=I4), public :: apod apodize imposed acf? logical(kind=I4), public :: calc_mstt calculate starting moments? logical(kind=I4), public :: calc_zf calculate final heights? real(kind=R8), public :: crt_acf acf criterion: mean absolute difference between imposed and calculated acf allowed type( acf_param ), public :: curr_surf current  surface ACF properties real(kind=R8), public :: cutoff Gaussian filter cutoff real(kind=R8), public, allocatable, dimension(:,:) :: fhi digital filter integer(kind=I4), public :: func_gen mathematical function used to generate the heights integer(kind=I4), public :: height surface nb points along y real(kind=R8), public, allocatable, dimension(:,:) :: imp_acf imposed autocorrelation type( moment_stat ), public :: m__HF surface to be reproduced stat moments, high frequencies type( moment_stat ), public :: m__LF surface to be reproduced stat moments, low  frequencies type( moment_stat ), public :: m_end final stat moments type( moment_stat ), public :: m_ini surface to be reproduced stat moments type( moment_stat ), public :: m_inp input stat moments for genetic algo optimizer type( moment_stat ), public :: m_stt starting stat moments integer(kind=I4), public :: nb_threads number of concurrent threads integer(kind=I4), public :: nparam number of parameters for the mathematical function integer(kind=I4), public :: npts surface nb points integer(kind=I4), public, allocatable, dimension(:) :: order vector that stores heights order type( acf_param ), public :: orig_surf original surface ACF properties logical(kind=I4), public :: periodic is the surface periodic? type( pikaia_class ), public :: pik_class PIKAIA class instanciation logical(kind=I4), public :: reajust_skku if Ssk 2 +1 > Sku, modify Sku real(kind=R8), public :: res_acf store mean absolute difference between imposed and calculated acf integer(kind=I4), public :: sub_height subsurface nb points along y integer(kind=I4), public :: sub_npts subsurface nb points real(kind=R8), public :: sub_surf_height subsurface height (m) real(kind=R8), public :: sub_surf_width subsurface width (m) integer(kind=I4), public :: sub_width subsurface nb points along x real(kind=R8), public, allocatable, dimension(:,:) :: surf surface array real(kind=R8), public, allocatable, dimension(:,:) :: surf_HF surface high frequencies real(kind=R8), public, allocatable, dimension(:,:) :: surf_LF surface low frequencies real(kind=R8), public, allocatable, dimension(:,:) :: surf_copy surface array copy real(kind=R8), public :: surf_dx surface increment along x (m) real(kind=R8), public :: surf_dy surface increment along y (m) real(kind=R8), public :: surf_height surface height (m) logical(kind=I4), public, allocatable, dimension(:,:) :: surf_msk surface high frequencies real(kind=R8), public :: surf_width surface width (m) real(kind=R8), public, allocatable, dimension(:) :: vect_h vector used to store the heights that meet the stat moments integer(kind=I4), public :: width surface nb points along x Source Code type param_crest real ( kind = R8 ), allocatable , dimension (:) :: vect_h !! *vector used to store the heights that meet the stat moments* real ( kind = R8 ), allocatable , dimension (:,:) :: surf !! *surface array* real ( kind = R8 ), allocatable , dimension (:,:) :: surf_copy !! *surface array copy* real ( kind = R8 ), allocatable , dimension (:,:) :: surf_LF !! *surface low frequencies* real ( kind = R8 ), allocatable , dimension (:,:) :: surf_HF !! *surface high frequencies* real ( kind = R8 ), allocatable , dimension (:,:) :: imp_acf !! *imposed autocorrelation* real ( kind = R8 ), allocatable , dimension (:,:) :: fhi !! *digital filter* real ( kind = R8 ), allocatable , dimension (:,:) :: acf_surf !! *calculated autocorrelation* integer ( kind = I4 ), allocatable , dimension (:) :: order !! *vector that stores heights order* logical ( kind = I4 ), allocatable , dimension (:,:) :: surf_msk !! *surface high frequencies* type ( MOMENT_STAT ) :: m_ini !! *surface to be reproduced stat moments* type ( MOMENT_STAT ) :: m__LF !! *surface to be reproduced stat moments, low  frequencies* type ( MOMENT_STAT ) :: m__HF !! *surface to be reproduced stat moments, high frequencies* type ( MOMENT_STAT ) :: m_end !! *final stat moments* type ( MOMENT_STAT ) :: m_inp !! *input stat moments for genetic algo optimizer* type ( MOMENT_STAT ) :: m_stt !! *starting stat moments* type ( pikaia_class ) :: pik_class !! **PIKAIA** *class instanciation* type ( ACF_PARAM ) :: orig_surf !! *original surface ACF properties* type ( ACF_PARAM ) :: curr_surf !! *current  surface ACF properties* integer ( kind = I4 ) :: func_gen !! *mathematical function used to generate the heights* integer ( kind = I4 ) :: nparam !! *number of parameters for the mathematical function* integer ( kind = I4 ) :: nb_threads !! *number of concurrent threads* integer ( kind = I4 ) :: width !! *surface nb points along x* integer ( kind = I4 ) :: height !! *surface nb points along y* integer ( kind = I4 ) :: npts !! *surface nb points* integer ( kind = I4 ) :: sub_width !! *subsurface nb points along x* integer ( kind = I4 ) :: sub_height !! *subsurface nb points along y* integer ( kind = I4 ) :: sub_npts !! *subsurface nb points* logical ( kind = I4 ) :: reajust_skku !! *if Ssk**2 +1 > Sku, modify Sku* logical ( kind = I4 ) :: periodic !! *is the surface periodic?* logical ( kind = I4 ) :: apod !! *apodize imposed acf?* logical ( kind = I4 ) :: calc_mstt !! *calculate starting moments?* logical ( kind = I4 ) :: calc_zf !! *calculate final heights?* real ( kind = R8 ) :: cutoff !! *Gaussian filter cutoff* real ( kind = R8 ) :: surf_width !! *surface width (m)* real ( kind = R8 ) :: surf_height !! *surface height (m)* real ( kind = R8 ) :: sub_surf_width !! *subsurface width (m)* real ( kind = R8 ) :: sub_surf_height !! *subsurface height (m)* real ( kind = R8 ) :: surf_dx !! *surface increment along x (m)* real ( kind = R8 ) :: surf_dy !! *surface increment along y (m)* real ( kind = R8 ) :: crt_acf !! *acf criterion: mean absolute difference between imposed and calculated acf allowed* real ( kind = R8 ) :: res_acf !! *store mean absolute difference between imposed and calculated acf* endtype param_crest","tags":"","loc":"type/param_crest.html"},{"title":"autocov_impo – CREST","text":"private  function autocov_impo(xi, xj, tau1, tau2, alpha, ang) Note Function that returns Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi coordinate real(kind=R8), intent(in) :: xj coordinate real(kind=R8), intent(in) :: tau1 correlation length along real(kind=R8), intent(in) :: tau2 correlation length along real(kind=R8), intent(in) :: alpha log(z) where z is often 0.2 real(kind=R8), intent(in) :: ang angle (rad) Return Value real(kind=r8) Called by proc~~autocov_impo~~CalledByGraph proc~autocov_impo autocov_impo proc~calc_imp_acf calc_imp_acf proc~calc_imp_acf->proc~autocov_impo proc~acf_theo acf_theo proc~acf_theo->proc~calc_imp_acf proc~sub_surf sub_surf proc~sub_surf->proc~calc_imp_acf proc~read_job read_job proc~read_job->proc~acf_theo proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autocov_impo.html"},{"title":"acf_wiener – CREST","text":"public  subroutine acf_wiener(tab_in, tab_out, w, h, multi_fft) Note Function that returns the acf of an array. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:w, 1:h) :: tab_in input array real(kind=R8), intent(out), dimension(1:w, 1:h) :: tab_out acf of the input array integer(kind=I4), intent(in) :: w 2D array length integer(kind=I4), intent(in) :: h 2D array width logical(kind=I4), intent(in), optional :: multi_fft run parallel acfs? Calls proc~~acf_wiener~~CallsGraph proc~acf_wiener acf_wiener calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~acf_wiener~~CalledByGraph proc~acf_wiener acf_wiener proc~calc_acf calc_acf proc~calc_acf->proc~acf_wiener proc~repr_img repr_img proc~repr_img->proc~acf_wiener proc~surface_analysis surface_analysis proc~repr_img->proc~surface_analysis proc~stat_sur stat_sur proc~stat_sur->proc~acf_wiener proc~stat_sur->proc~surface_analysis proc~sub_surf sub_surf proc~sub_surf->proc~acf_wiener proc~surface_analysis->proc~acf_wiener proc~read_job read_job proc~read_job->proc~calc_acf proc~read_job->proc~repr_img proc~read_job->proc~stat_sur proc~read_job->proc~sub_surf proc~read_job->proc~surface_analysis proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine acf_wiener ( tab_in , tab_out , w , h , multi_fft ) !================================================================================================ !<@note Function that returns the *acf* of an array. !<  !< \\begin{align*} !<    acf(i,j) &= (z \\ast z)(i,j) = \\sum_{k,l}&#94;{n,n} z(k+1-i,l+1-j)z(k,l)  \\\\ !<    TF(acf)  &= ACF = Z \\cdot Z                                          \\\\ !<    acf      &= TF&#94;{-1}(ACF) = TF&#94;{-1}(Z&#94;2) !< \\end{align*} !<  !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: w !! *2D array length* integer ( kind = I4 ), intent ( in ) :: h !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: tab_in !! *input array* real ( kind = R8 ), intent ( out ), dimension ( 1 : w , 1 : h ) :: tab_out !! *acf of the input array* logical ( kind = I4 ), intent ( in ), optional :: multi_fft !! *run parallel acfs?* integer ( kind = I4 ) :: lo2 , la2 real ( kind = R8 ) :: tmp logical ( kind = I4 ) :: parallel_fft integer ( kind = I4 ), dimension ( 1 : 2 ) :: loc_max complex ( kind = R8 ), dimension (:,:), allocatable :: tab_cmpl real ( kind = R8 ), dimension (:,:), allocatable :: tab_real allocate ( tab_cmpl ( 1 : w , 1 : h ) ) allocate ( tab_real ( 1 : w , 1 : h ) ) ! check for simultaneous fftw calculations !......................................... parallel_fft = . false . if ( present ( multi_fft ) ) parallel_fft = multi_fft !......................................... ! DFFT real -> complex !......................................... if ( parallel_fft ) then call tab_calc_fftw3_real_fwd ( tab_in = tab_in ( 1 : w , 1 : h ), & ! IN tab_ou = tab_cmpl ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN else call calc_fftw3_real_fwd ( tab_in = tab_in ( 1 : w , 1 : h ), & ! IN tab_ou = tab_cmpl ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h , & ! IN planner_flag = FFTW_MEASURE ) ! IN endif !......................................... tab_cmpl ( 1 : w , 1 : h ) = cmplx ( abs ( tab_cmpl ( 1 : w , 1 : h ) ) ** 2 , 0 , kind = R8 ) ! IFFT complex -> real !......................................... if ( parallel_fft ) then call tab_calc_fftw3_real_bwd ( tab_in = tab_cmpl ( 1 : w , 1 : h ), & ! IN tab_ou = tab_real ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN else call calc_fftw3_real_bwd ( tab_in = tab_cmpl ( 1 : w , 1 : h ), & ! IN tab_ou = tab_real ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h , & ! IN planner_flag = FFTW_MEASURE ) ! IN endif !......................................... ! the maximum is placed in the array center !......................................... call trans_corner2center ( tab_in = tab_real ( 1 : w , 1 : h ), & ! IN tab_out = tab_out ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN !......................................... ! the maximum is 1 !......................................... loc_max ( 1 : 2 ) = maxloc ( tab_out ( 1 : w , 1 : h ) ) lo2 = loc_max ( 1 ) la2 = loc_max ( 2 ) tmp = tab_out ( lo2 , la2 ) tab_out ( 1 : w , 1 : h ) = tab_out ( 1 : w , 1 : h ) / tmp !......................................... deallocate ( tab_cmpl ) deallocate ( tab_real ) return endsubroutine acf_wiener","tags":"","loc":"proc/acf_wiener.html"},{"title":"apod2 – CREST","text":"public  subroutine apod2(tab_in, tab_out, long, larg, tau1, tau2, ang) Note Function that returns an apodized array. To prevent gaps from appearing after FFT (because of non periodic waves), the surface must\n be transformed, but not too much. Here a modified Tukey window is determined. The starting\n surface is not modified below the “correlation lengths”. Above the correlation lengths, a\n smooth decrease is forced with a cosine squared. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in input acf real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out apodized acf integer(kind=I4), intent(in) :: long surface acf length integer(kind=I4), intent(in) :: larg surface acf width real(kind=R8), intent(in) :: tau1 surface first correlation length real(kind=R8), intent(in) :: tau2 surface second correlation length real(kind=R8), intent(in) :: ang ellipsis angle Called by proc~~apod2~~CalledByGraph proc~apod2 apod2 proc~apod_acf apod_acf proc~apod_acf->proc~apod2 proc~calc_imp_acf calc_imp_acf proc~calc_imp_acf->proc~apod2 proc~acf_theo acf_theo proc~acf_theo->proc~calc_imp_acf proc~read_job read_job proc~read_job->proc~apod_acf proc~read_job->proc~acf_theo proc~sub_surf sub_surf proc~read_job->proc~sub_surf proc~sub_surf->proc~calc_imp_acf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine apod2 ( tab_in , tab_out , long , larg , tau1 , tau2 , ang ) !================================================================================================ !<@note Function that returns an apodized array.<br/> !< To prevent gaps from appearing after FFT (because of non periodic waves), the surface must !< be transformed, but not too much. Here a modified Tukey window is determined. The starting !< surface is not modified below the \"correlation lengths\". Above the correlation lengths, a !< smooth decrease is forced with a cosine squared. !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface acf length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface acf width* real ( kind = R8 ), intent ( in ) :: tau1 !! *surface first correlation length* real ( kind = R8 ), intent ( in ) :: tau2 !! *surface second correlation length* real ( kind = R8 ), intent ( in ) :: ang !! *ellipsis angle* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *input acf* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *apodized acf* real ( kind = R8 ) :: r2 , c0 , s0 , rd , rr , theta , theta_diag , x , y , t , a_min , sum_inn , sum_tab , sum_int integer ( kind = I4 ) :: i , j , k , long2 , larg2 , npt_out , n real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp ! first bissector angle (rad) theta_diag = atan2 ( PARAM % surf_height , PARAM % surf_width ) ! sine and cosine of the ellipsis angle c0 = cos ( ang ) ; s0 = sin ( ang ) long2 = long / 2 larg2 = larg / 2 if ( long == 2 * ( long / 2 ) ) long2 = long / 2 + 1 if ( larg == 2 * ( larg / 2 ) ) larg2 = larg / 2 + 1 tab_out ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) rr = 1.e6_R8 do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) cycle ! The correlation length is exceeded. ! The angle corresponding to the position (i,j) is calculated theta = atan2 ( y , x ) ; if ( theta < 0. ) theta = theta + 2 * Pi_R8 t = tan ( theta ) ! According the location of (i,j) (right, top, left or bottom) the line that begin at the surface center, passing by (i,j), ! ends on one of the four borders. if ( theta > 2 * Pi_R8 - theta_diag . or . theta <= + theta_diag ) then ; x = ( long - long2 ) * PARAM % surf_dx ; y = x * t ; endif if ( theta > + theta_diag . and . theta <= PI_R8 - theta_diag ) then ; y = ( larg - larg2 ) * PARAM % surf_dy ; x = y / t ; endif if ( theta > PI_R8 - theta_diag . and . theta <= PI_R8 + theta_diag ) then ; x = ( 1 - long2 ) * PARAM % surf_dx ; y = x * t ; endif if ( theta > PI_R8 + theta_diag . and . theta <= 2 * Pi_R8 - theta_diag ) then ; y = ( 1 - larg2 ) * PARAM % surf_dy ; x = y / t ; endif ! The same distance as above is calculated, from the center to the surface edge, then ... rd = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 rr = min ( rr , sqrt ( rd ) ) enddo enddo rr = 0.99 * rr sum_inn = 0 sum_tab = 0 sum_int = 0 npt_out = 0 n = 2 do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) then sum_inn = sum_inn + tab_in ( i , j ) cycle endif r2 = sqrt ( r2 ) if ( r2 >= rr ) then npt_out = npt_out + 1 cycle endif ! ... the modified Tuckey window can be determined. sum_tab = sum_tab + ( cos ( 0.5_R8 * PI_R8 * ( r2 - 1. ) / ( rr - 1. ) ) ** n ) * tab_in ( i , j ) sum_int = sum_int + ( r2 - 1. ) / ( rr - 1. ) enddo enddo a_min = - ( sum_inn + sum_tab ) / ( npt_out + sum_int ) do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) cycle r2 = sqrt ( r2 ) if ( r2 >= rr ) then tab_out ( i , j ) = a_min cycle endif ! ... the modified Tuckey window can be determined. tab_out ( i , j ) = ( cos ( 0.5_R8 * PI_R8 * ( r2 - 1. ) / ( rr - 1. ) ) ** n ) * tab_in ( i , j ) + a_min * ( r2 - 1. ) / ( rr - 1. ) enddo enddo allocate ( tab_tmp ( 1 : long , 1 : larg ) ) do k = 1 , 10 tab_tmp ( 1 : long , 1 : larg ) = tab_out ( 1 : long , 1 : larg ) do j = 1 + 1 , larg - 1 do i = 1 + 1 , long - 1 x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 r2 = sqrt ( r2 ) if ( r2 <= 0.98_R8 . or . ( r2 >= 1.02_R8 . and . r2 <= 0.98_R8 * rr ) . or . r2 >= 1.02_R8 * rr ) cycle tab_out ( i , j ) = ( 2 * tab_tmp ( i , j ) + tab_tmp ( i + 1 , j ) + tab_tmp ( i - 1 , j ) + & ! tab_tmp ( i , j + 1 ) + tab_tmp ( i , j - 1 ) + ( tab_tmp ( i + 1 , j - 1 ) + tab_tmp ( i - 1 , j - 1 ) + & ! tab_tmp ( i - 1 , j + 1 ) + tab_tmp ( i + 1 , j + 1 ) ) / sqrt ( 2._R8 ) ) / ( 6. + 4. / sqrt ( 2._R8 ) ) enddo enddo enddo deallocate ( tab_tmp ) return endsubroutine apod2","tags":"","loc":"proc/apod2.html"},{"title":"calc_imp_acf – CREST","text":"public  subroutine calc_imp_acf(long, larg, tau1, tau2, alpha, ang, tab_acf, apod) Note Function that returns the theoretical autocorrelation function in an array. The autocorrelation function is supposed to be obtained from a real surface which must be periodic\n or nearly periodic (because of the use of FFTs).\n In addition, the surface is supposed to be 0 mean and normalized ( ),\n therefore acf is zero-mean and normalized so that its max value is 1. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long surface acf width integer(kind=I4), intent(in) :: larg surface acf height real(kind=R8), intent(in) :: tau1 first correlation length real(kind=R8), intent(in) :: tau2 surface second correlation length real(kind=R8), intent(in) :: alpha parameter that controls the expondential decrease real(kind=R8), intent(in) :: ang acf ellipsis angle real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_acf resulting acf logical(kind=I4), intent(in) :: apod apodization? Calls proc~~calc_imp_acf~~CallsGraph proc~calc_imp_acf calc_imp_acf proc~apod2 apod2 proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_imp_acf~~CalledByGraph proc~calc_imp_acf calc_imp_acf proc~acf_theo acf_theo proc~acf_theo->proc~calc_imp_acf proc~sub_surf sub_surf proc~sub_surf->proc~calc_imp_acf proc~read_job read_job proc~read_job->proc~acf_theo proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_imp_acf ( long , larg , tau1 , tau2 , alpha , ang , tab_acf , apod ) !================================================================================================ !<@note Function that returns the theoretical autocorrelation function in an array.<br/> !< The autocorrelation function is supposed to be obtained from a real surface which must be periodic !< or nearly periodic (because of the use of FFTs). !< In addition, the surface is supposed to be 0 mean and normalized (\\sigma = 1 ), !< therefore *acf* is zero-mean and normalized so that its max value is 1.<br/> !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface acf width* integer ( kind = I4 ), intent ( in ) :: larg !! *surface acf height* logical ( kind = I4 ), intent ( in ) :: apod !! *apodization?* real ( kind = R8 ), intent ( in ) :: tau1 !! *first correlation length* real ( kind = R8 ), intent ( in ) :: tau2 !! *surface second correlation length* real ( kind = R8 ), intent ( in ) :: alpha !! *parameter that controls the expondential decrease* real ( kind = R8 ), intent ( in ) :: ang !! *acf ellipsis angle* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_acf !! *resulting acf* integer ( kind = I4 ) :: i , j , long2 , larg2 real ( kind = R8 ) :: xi , xj , s , c , coeff real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp ! acf array, centered and normalized !......................................... c = cos ( ang ) ; s = sin ( ang ) long2 = long / 2 + 1 larg2 = larg / 2 + 1 do j = 1 , larg do i = 1 , long xi = real ( i - long2 , kind = R8 ) * PARAM % surf_dx ! dimensioned coordinate x xj = real ( j - larg2 , kind = R8 ) * PARAM % surf_dy ! dimensioned coordinate y tab_acf ( i , j ) = autocov_impo ( xi = xi , & ! IN xj = xj , & ! IN tau1 = tau1 , & ! IN tau2 = tau2 , & ! IN alpha = alpha , & ! IN ang = ang ) ! IN enddo enddo !......................................... ! For long correlation lengths and roughness orientation, the acf is far from periodic ! Furthermore, far from the center, respecting the acf becomes less important. A windowing ! can be determined so that at a given distance from the center, the acf is lessened. !......................................... if ( apod ) then allocate ( tab_tmp ( 1 : long , 1 : larg ) ) coeff = 0.4 * PARAM % surf_width * c / tau1 ! along the primary axis (longest correlation length) the acf is reduce beyond ! 0.4 * image width * cos(ang) ! (0.4 * image width is less than half width) call apod2 ( tab_in = tab_acf ( 1 : long , 1 : larg ), & ! IN tab_out = tab_tmp ( 1 : long , 1 : larg ), & ! OUT long = long , & ! IN larg = larg , & ! IN tau1 = coeff * tau1 , & ! IN tau2 = coeff * tau2 , & ! IN ang = ang ) ! IN tab_acf ( 1 : long , 1 : larg ) = tab_tmp ( 1 : long , 1 : larg ) deallocate ( tab_tmp ) endif !......................................... ! acf centered tab_acf ( 1 : long , 1 : larg ) = tab_acf ( 1 : long , 1 : larg ) - sum ( tab_acf ( 1 : long , 1 : larg ) ) / ( long * larg ) ! acf scaled (maximum = 1) tab_acf ( 1 : long , 1 : larg ) = tab_acf ( 1 : long , 1 : larg ) / tab_acf ( long2 , larg2 ) return endsubroutine calc_imp_acf","tags":"","loc":"proc/calc_imp_acf.html"},{"title":"acf_theo – CREST","text":"private  subroutine acf_theo() Note Function that returns the theoretical acf PARAM%imp_acf. If the surface to generate is non periodic, the starting surface is extended. The final surface\n will be a part of it. Indeed the extended surface will be periodic, because the use of FFTs. If a roughness orientation is chosen, in addition with long correlation lengths, a windowing\n should be applied to the acf to prevent from artifacts (vertical and horizontal lines) Arguments None Calls proc~~acf_theo~~CallsGraph proc~acf_theo acf_theo ellipse_acf ellipse_acf proc~acf_theo->ellipse_acf proc~calc_imp_acf calc_imp_acf proc~acf_theo->proc~calc_imp_acf proc~apod2 apod2 proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~acf_theo~~CalledByGraph proc~acf_theo acf_theo proc~read_job read_job proc~read_job->proc~acf_theo proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine acf_theo () !================================================================================================ !<@note Function that returns the theoretical acf PARAM%imp_acf. !< !< If the surface to generate is non periodic, the starting surface is extended. The final surface !< will be a part of it. Indeed the extended surface will be periodic, because the use of FFTs. !< !< If a roughness orientation is chosen, in addition with long correlation lengths, a windowing !< should be applied to the acf to prevent from artifacts (vertical and horizontal lines) !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h logical ( kind = I4 ) :: with_apod real ( kind = R8 ) :: ratio , a , b , c , s , lx , ly real ( kind = R8 ), dimension ( 1 : 8 ) :: res read ( JOB , * ) PARAM % curr_surf % cl1 , PARAM % curr_surf % cl2 , PARAM % curr_surf % cut ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"l_acf \" , PARAM % curr_surf % cl1 , PARAM % curr_surf % cl2 , PARAM % curr_surf % cut if ( PARAM % curr_surf % cl1 < PARAM % curr_surf % cl2 ) stop \"inverser cl1, cl2\" read ( JOB , * ) PARAM % curr_surf % ang ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"ang \" , PARAM % curr_surf % ang write ( SPY , * ) 'acf_theo -> determines the theoretical acf with a padded size, so correlation lengths are adjusted accordingly' read ( JOB , * ) with_apod ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"apod \" , with_apod PARAM % apod = with_apod w = PARAM % width h = PARAM % height if ( . not . PARAM % periodic ) then PARAM % sub_width = w PARAM % sub_height = h PARAM % sub_npts = w * h PARAM % sub_surf_width = PARAM % surf_width PARAM % sub_surf_height = PARAM % surf_height ! the surface must be extended a = PARAM % curr_surf % cl1 b = PARAM % curr_surf % cl2 c = cos ( PARAM % curr_surf % ang * PI_R8 / 180 ) s = sin ( PARAM % curr_surf % ang * PI_R8 / 180 ) lx = sqrt ( ( a * c ) ** 2 + ( b * s ) ** 2 ) ly = sqrt ( ( a * s ) ** 2 + ( b * c ) ** 2 ) w = w + nint ( lx / PARAM % surf_dx ) h = h + nint ( ly / PARAM % surf_dy ) ! update sizes PARAM % width = w PARAM % height = h PARAM % npts = w * h PARAM % surf_width = w * PARAM % surf_dx PARAM % surf_height = h * PARAM % surf_dy endif allocate ( PARAM % surf ( 1 : w , 1 : h ) ) allocate ( PARAM % fhi ( 1 : w , 1 : h ) ) allocate ( PARAM % imp_acf ( 1 : w , 1 : h ) ) allocate ( PARAM % order ( 1 : w * h ) ) allocate ( PARAM % vect_h ( 1 : w * h ) ) allocate ( PARAM % acf_surf ( 1 : w , 1 : h ) ) ratio = PARAM % curr_surf % cl2 / PARAM % curr_surf % cl1 ! acf_theo is the theoretical acf for the normal surface call calc_imp_acf ( long = w , & ! IN larg = h , & ! IN apod = with_apod , & ! IN tau1 = PARAM % curr_surf % cl1 , & ! IN tau2 = PARAM % curr_surf % cl2 , & ! IN alpha = log ( PARAM % curr_surf % cut ), & ! IN ang = PARAM % curr_surf % ang * PI_R8 / 180 , & ! IN tab_acf = PARAM % imp_acf ( 1 : w , 1 : h )) ! OUT call ellipse_acf ( tabin = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN p_acv = res ( 1 : 8 ), & ! OUT cut = PARAM % curr_surf % cut , & ! IN scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN omp = . true . ) ! IN return endsubroutine acf_theo","tags":"","loc":"proc/acf_theo.html"},{"title":"add_nois – CREST","text":"private  subroutine add_nois() Note Function that returns the starting surface of random heights Arguments None Calls proc~~add_nois~~CallsGraph proc~add_nois add_nois proc~build_heights build_heights proc~add_nois->proc~build_heights scramble scramble proc~add_nois->scramble std_array std_array proc~add_nois->std_array proc~build_heights->std_array proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d sort_array2 sort_array2 proc~build_heights->sort_array2 init pikaia_class%init proc~pikaia_skku_solver->init solve pikaia_class%solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_nois~~CalledByGraph proc~add_nois add_nois proc~read_job read_job proc~read_job->proc~add_nois proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_nois () !================================================================================================ !<@note Function that returns the starting surface of random heights !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l real ( kind = R8 ) :: size_noise real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp type ( MOMENT_STAT ) :: mx read ( JOB , * ) mx % sk , mx % ku , size_noise ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"ssk, sku, size \" , mx % sk , mx % ku , size_noise w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( tab_tmp ( 1 : l ) ) call build_heights ( vec_out = tab_tmp ( 1 : l ), & ! OUT use_fct_expo = ( mx % ku < 1.34 * mx % sk ** 2 + 1.8 ), & ! IN stats_in = mx , & ! IN lg = l ) ! IN call std_array ( tab = tab_tmp ( 1 : l ) ) call scramble ( tab = tab_tmp ( 1 : l ), & ! INOUT lg = l ) ! IN PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) + size_noise * reshape ( tab_tmp ( 1 : l ), [ w , h ] ) deallocate ( tab_tmp ) return endsubroutine add_nois","tags":"","loc":"proc/add_nois.html"},{"title":"alloc_tabs – CREST","text":"private  subroutine alloc_tabs() Note Function that allocates arrays in global variable PARAM Arguments None Called by proc~~alloc_tabs~~CalledByGraph proc~alloc_tabs alloc_tabs proc~read_job read_job proc~read_job->proc~alloc_tabs proc~repr_img repr_img proc~read_job->proc~repr_img proc~repr_img->proc~alloc_tabs proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine alloc_tabs () !================================================================================================ !<@note Function that allocates arrays in global variable [[PARAM]] !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h w = PARAM % width h = PARAM % height allocate ( PARAM % fhi ( 1 : w , 1 : h ) ) ; PARAM % fhi ( 1 : w , 1 : h ) = 0 ! *digital filter* allocate ( PARAM % imp_acf ( 1 : w , 1 : h ) ) ; PARAM % imp_acf ( 1 : w , 1 : h ) = 0 ! *imposed autocorrelation* allocate ( PARAM % order ( 1 : w * h ) ) ; PARAM % order ( 1 : w * h ) = 0 ! *vector that stores heights order* allocate ( PARAM % vect_h ( 1 : w * h ) ) ; PARAM % vect_h ( 1 : w * h ) = 0 ! *vector used to store the heights that meet the stat moments* allocate ( PARAM % acf_surf ( 1 : w , 1 : h ) ) ; PARAM % acf_surf ( 1 : w , 1 : h ) = 0 ! *calculated autocorrelation* allocate ( PARAM % surf_copy ( 1 : w , 1 : h ) ) ; PARAM % surf_copy ( 1 : w , 1 : h ) = 0 ! *surface array copy* allocate ( PARAM % surf_LF ( 1 : w , 1 : h ) ) ; PARAM % surf_LF ( 1 : w , 1 : h ) = 0 ! *surface low frequencies* allocate ( PARAM % surf_HF ( 1 : w , 1 : h ) ) ; PARAM % surf_HF ( 1 : w , 1 : h ) = 0 ! *surface high frequencies* return endsubroutine alloc_tabs","tags":"","loc":"proc/alloc_tabs.html"},{"title":"apod_acf – CREST","text":"private  subroutine apod_acf() Note Function that apodize the acf to prevent spectral leakage Arguments None Calls proc~~apod_acf~~CallsGraph proc~apod_acf apod_acf ellipse_acf ellipse_acf proc~apod_acf->ellipse_acf proc~apod2 apod2 proc~apod_acf->proc~apod2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~apod_acf~~CalledByGraph proc~apod_acf apod_acf proc~read_job read_job proc~read_job->proc~apod_acf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine apod_acf () !================================================================================================ !<@note Function that apodize the acf to prevent spectral leakage !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h real ( kind = R8 ) :: tau1 , tau2 , ang , coeff , c , s , R1 , R2 real ( kind = R8 ), dimension ( 1 : 8 ) :: ana_res real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp logical ( kind = I4 ) :: set_acf read ( JOB , * ) set_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , \"Set ACF \" , set_acf w = PARAM % width h = PARAM % height call ellipse_acf ( tabin = PARAM % acf_surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN p_acv = ana_res ( 1 : 8 ), & ! OUT -> correlation lengths cut = 0.5_R8 , & ! IN  -> z cut plane scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN  -> lags along x and y omp = . true . ) ! IN  -> use multithread? tau1 = ana_res ( 1 ) tau2 = ana_res ( 2 ) ang = ana_res ( 4 ) * PI_R8 / 180 c = cos ( ang ) s = sin ( ang ) ! ellipsis bounding box (half dimensions) R1 = sqrt ( ( c * tau1 ) ** 2 + ( s * tau2 ) ** 2 ) R2 = sqrt ( ( s * tau1 ) ** 2 + ( c * tau2 ) ** 2 ) ! scale factor for the apodization to take place within the surface ! 0.4 * image width is less than half width coeff = min ( 0.4 * PARAM % surf_width / R1 , 0.4 * PARAM % surf_height / R2 ) allocate ( tab_tmp ( 1 : w , 1 : h ) ) ! modified Tuckey windowing call apod2 ( tab_in = PARAM % acf_surf ( 1 : w , 1 : h ), & ! IN tab_out = tab_tmp ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h , & ! IN tau1 = coeff * tau1 , & ! IN tau2 = coeff * tau2 , & ! IN ang = ang ) ! IN if ( set_acf ) then ! acf calculated becomes prescribed acf PARAM % imp_acf ( 1 : w , 1 : h ) = tab_tmp ( 1 : w , 1 : h ) else PARAM % acf_surf ( 1 : w , 1 : h ) = tab_tmp ( 1 : w , 1 : h ) endif deallocate ( tab_tmp ) return endsubroutine apod_acf","tags":"","loc":"proc/apod_acf.html"},{"title":"apod_sur – CREST","text":"private  subroutine apod_sur() Note Function that apodize the reference surface for acf calculus purposes Arguments None Calls proc~~apod_sur~~CallsGraph proc~apod_sur apod_sur apod apod proc~apod_sur->apod std_array std_array proc~apod_sur->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~apod_sur~~CalledByGraph proc~apod_sur apod_sur proc~read_job read_job proc~read_job->proc~apod_sur proc~spct_sur spct_sur proc~read_job->proc~spct_sur proc~stat_sur stat_sur proc~read_job->proc~stat_sur proc~spct_sur->proc~apod_sur proc~stat_sur->proc~apod_sur proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine apod_sur () !================================================================================================ !<@note Function that apodize the reference surface for acf calculus purposes !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp w = PARAM % width h = PARAM % height allocate ( tab_tmp ( 1 : w , 1 : h ) ) call apod ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & !  IN tab_out = tab_tmp ( 1 : w , 1 : h ), & !  OUT long = w , & !  IN larg = h , & !  IN type_apo = 'tuckey' ) !  IN ! standardize surface call std_array ( tab_tmp ( 1 : w , 1 : h ) ) PARAM % surf ( 1 : w , 1 : h ) = tab_tmp ( 1 : w , 1 : h ) deallocate ( tab_tmp ) return endsubroutine apod_sur","tags":"","loc":"proc/apod_sur.html"},{"title":"calc_acf – CREST","text":"private  subroutine calc_acf() Note Function that returns the autocorrelation function of a surface in PARAM%acf_surf Arguments None Calls proc~~calc_acf~~CallsGraph proc~calc_acf calc_acf proc~acf_wiener acf_wiener proc~calc_acf->proc~acf_wiener calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_acf~~CalledByGraph proc~calc_acf calc_acf proc~read_job read_job proc~read_job->proc~calc_acf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_acf () !================================================================================================ !<@note Function that returns the autocorrelation function of a surface in PARAM%acf_surf !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h logical ( kind = I4 ) :: set_acf ! if set_acf is true, the acf becomes the prescribed one read ( JOB , * ) set_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , \"Set ACF \" , set_acf w = PARAM % width h = PARAM % height call acf_wiener ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! IN tab_out = PARAM % acf_surf ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h ) ! IN if ( set_acf ) PARAM % imp_acf ( 1 : w , 1 : h ) = PARAM % acf_surf ( 1 : w , 1 : h ) return endsubroutine calc_acf","tags":"","loc":"proc/calc_acf.html"},{"title":"calc_ffh – CREST","text":"private  subroutine calc_ffh() Note Function that returns … the digital filter to apply to the height distribution the starting statistical moments PARAM%m_stt%sk, PARAM%m_stt%ku whether the exponential function will be used, PARAM%reajust_skku Arguments None Calls proc~~calc_ffh~~CallsGraph proc~calc_ffh calc_ffh calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_ffh->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_ffh->calc_fftw3_real_fwd calc_moments calc_moments proc~calc_ffh->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_ffh~~CalledByGraph proc~calc_ffh calc_ffh proc~read_job read_job proc~read_job->proc~calc_ffh proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_ffh () !================================================================================================ !<@note Function that returns ... !< !< - the digital filter to apply to the height distribution  \\text{PARAM%fhi} = \\sqrt{ \\left| FFT(\\text{PARAM%imp_acf}) \\right| }  !< - the starting statistical moments PARAM%m_stt%sk, PARAM%m_stt%ku !< - whether the exponential function will be used, PARAM%reajust_skku !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l complex ( kind = R8 ), dimension (:,:), allocatable :: cmple real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp type ( MOMENT_STAT ) :: m_h read ( JOB , * ) PARAM % calc_mstt ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"PARAM%calc_mstt \" , PARAM % calc_mstt w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( cmple ( 1 : w , 1 : h ) ) write ( SPY , * ) 'calc_ffh -> PARAM%fhi = sqrt( abs( FFT(PARAM%imp_acf) ) )' call calc_fftw3_real_fwd ( tab_in = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN tab_ou = cmple ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN PARAM % fhi ( 1 : w , 1 : h ) = sqrt ( abs ( cmple ( 1 : w , 1 : h ) ) ) if ( PARAM % calc_mstt ) then ! determine starting statistical moments, if not already done !....................................................................... write ( SPY , * ) 'calc_ffh -> PARAM%m_stt calculated' cmple ( 1 : w , 1 : h ) = cmplx ( PARAM % fhi ( 1 : w , 1 : h ), 0 , kind = R8 ) allocate ( tab_tmp ( 1 : w , 1 : h ) ) call calc_fftw3_real_bwd ( tab_in = cmple ( 1 : w , 1 : h ), & ! IN tab_ou = tab_tmp ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN call calc_moments ( tab = tab_tmp ( 1 : w , 1 : h ), & ! IN mx = m_h , & ! OUT nb_mom = 4 ) ! IN PARAM % m_stt % mu = 0 PARAM % m_stt % va = 1 PARAM % m_end % mu = 0 PARAM % m_end % va = m_h % va PARAM % m_stt % sk = sqrt ( UN * l ) * PARAM % m_end % sk / m_h % sk PARAM % m_stt % ku = l * ( PARAM % m_end % ku - 3. ) / ( m_h % ku - 3. ) + 3. PARAM % reajust_skku = . false . if ( PARAM % m_stt % ku < PARAM % m_stt % sk ** 2 + 1. ) then PARAM % m_stt % ku = PARAM % m_stt % sk ** 2 + 1. PARAM % reajust_skku = . true . endif deallocate ( tab_tmp ) !....................................................................... else write ( SPY , * ) 'calc_ffh -> PARAM%m_stt NOT calculated, set to PARAM%m_end' PARAM % m_stt % sk = PARAM % m_end % sk PARAM % m_stt % ku = PARAM % m_end % ku endif deallocate ( cmple ) return endsubroutine calc_ffh","tags":"","loc":"proc/calc_ffh.html"},{"title":"calc_ord – CREST","text":"private  subroutine calc_ord() Note Function that returns the vector PARAM%order that contains the heights order. Arguments None Calls proc~~calc_ord~~CallsGraph proc~calc_ord calc_ord init_order init_order proc~calc_ord->init_order sort_array2 sort_array2 proc~calc_ord->sort_array2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_ord~~CalledByGraph proc~calc_ord calc_ord proc~read_job read_job proc~read_job->proc~calc_ord proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_ord () !================================================================================================ !<@note Function that returns the vector PARAM%order that contains the heights order. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: l , w , h real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( tab_tmp ( 1 : l ) ) tab_tmp ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call init_order ( order = PARAM % order ( 1 : l ), & ! OUT n = l ) ! IN call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! IN tab0 = PARAM % order ( 1 : l ), & ! OUT n = l ) ! IN deallocate ( tab_tmp ) return endsubroutine calc_ord","tags":"","loc":"proc/calc_ord.html"},{"title":"calc_res_acf – CREST","text":"private  subroutine calc_res_acf(acf_surf, imp_acf, crit_acf, acf__z, w, h) Note Function that returns crit_acf the mean absolute difference between theoretical\n and calculated acfs, above z (usually 0.2 as recommended by iso 25178) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:w, 1:h) :: acf_surf calculated surface acf real(kind=R8), intent(in), dimension(1:w, 1:h) :: imp_acf required surface acf real(kind=R8), intent(out) :: crit_acf mean absolute difference between theoretical and calculated acfs real(kind=R8), intent(in) :: acf__z plane elevation z where correlation lengths are calculated integer(kind=I4), intent(in) :: w surface acf width (points) integer(kind=I4), intent(in) :: h surface acf height (points) Called by proc~~calc_res_acf~~CalledByGraph proc~calc_res_acf calc_res_acf proc~sub_surf sub_surf proc~sub_surf->proc~calc_res_acf proc~read_job read_job proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_res_acf ( acf_surf , imp_acf , crit_acf , acf__z , w , h ) !================================================================================================ !<@note Function that returns *crit_acf* the mean absolute difference between theoretical !< and calculated acfs, above *z* (usually 0.2 as recommended by iso 25178) !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: w !! *surface acf width (points)* integer ( kind = I4 ), intent ( in ) :: h !! *surface acf height (points)* real ( kind = R8 ), intent ( in ) :: acf__z !! *plane elevation z where correlation lengths are calculated* real ( kind = R8 ), intent ( out ) :: crit_acf !! *mean absolute difference between theoretical and calculated acfs* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: acf_surf !! *calculated surface acf* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: imp_acf !! *required surface acf* real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp allocate ( tab_tmp ( 1 : w , 1 : h ) ) tab_tmp ( 1 : w , 1 : h ) = 0 where ( imp_acf > acf__z ) tab_tmp = abs ( acf_surf - imp_acf ) crit_acf = 100 * sum ( tab_tmp ( 1 : w , 1 : h ) ) / count ( tab_tmp ( 1 : w , 1 : h ) > 0 ) deallocate ( tab_tmp ) return endsubroutine calc_res_acf","tags":"","loc":"proc/calc_res_acf.html"},{"title":"calc_z_f – CREST","text":"private  subroutine calc_z_f() Note Function that returns PARAM%surf, the surface made of heights with the required statistical\n moments, in the right order. The heights come from the vector PARAM%vect_h the heights order is stored in the vector PARAM%order Arguments None Calls proc~~calc_z_f~~CallsGraph proc~calc_z_f calc_z_f proc~build_heights build_heights proc~calc_z_f->proc~build_heights std_array std_array proc~calc_z_f->std_array proc~build_heights->std_array proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d sort_array2 sort_array2 proc~build_heights->sort_array2 init pikaia_class%init proc~pikaia_skku_solver->init solve pikaia_class%solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_z_f~~CalledByGraph proc~calc_z_f calc_z_f proc~read_job read_job proc~read_job->proc~calc_z_f proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_z_f () !================================================================================================ !<@note Function that returns PARAM%surf, the surface made of heights with the required statistical !< moments, in the right order. !< !< - The heights come from the vector PARAM%vect_h !< - the heights order is stored in the vector PARAM%order !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: i integer ( kind = I4 ) :: w , h , l real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp read ( JOB , * ) PARAM % calc_zf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"PARAM%calc_zf \" , PARAM % calc_zf w = PARAM % width h = PARAM % height l = PARAM % npts ! final set of heights are generated to meet the desired statistical moments ! It is done once. if ( PARAM % calc_zf ) then write ( SPY , * ) 'calc_z_f -> final set of heights are generated to meet the desired statistical moments' call build_heights ( vec_out = PARAM % vect_h ( 1 : l ), & ! OUT use_fct_expo = ( PARAM % m_end % ku < 1.34 * PARAM % m_end % sk ** 2 + 1.8 ), & ! IN stats_in = PARAM % m_end , & ! IN lg = l ) ! IN endif ! The heights stored in PARAM%vect_h(1:lg) are reinjected in PARAM%surf, with respect to the order PARAM%order write ( SPY , * ) 'calc_z_f -> substitution of PARAM%surf with PARAM%vect_h with respect to PARAM%order' allocate ( tab_tmp ( 1 : l ) ) do i = 1 , l tab_tmp ( PARAM % order ( i ) ) = PARAM % vect_h ( i ) enddo PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call std_array ( tab = tab_tmp ( 1 : l ) ) deallocate ( tab_tmp ) return endsubroutine calc_z_f","tags":"","loc":"proc/calc_z_f.html"},{"title":"calc_z_i – CREST","text":"private  subroutine calc_z_i() Note Function that returns the starting surface of random heights Arguments None Calls proc~~calc_z_i~~CallsGraph proc~calc_z_i calc_z_i proc~build_heights build_heights proc~calc_z_i->proc~build_heights scramble scramble proc~calc_z_i->scramble std_array std_array proc~calc_z_i->std_array proc~build_heights->std_array proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d sort_array2 sort_array2 proc~build_heights->sort_array2 init pikaia_class%init proc~pikaia_skku_solver->init solve pikaia_class%solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_z_i~~CalledByGraph proc~calc_z_i calc_z_i proc~read_job read_job proc~read_job->proc~calc_z_i proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_z_i () !================================================================================================ !<@note Function that returns the starting surface of random heights !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp type ( MOMENT_STAT ) :: m_res w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( tab_tmp ( 1 : l ) ) ! starting set of heights are generated to meet the statistical moments prescribed by calc_ffh write ( SPY , * ) 'calc_z_i -> starting set of heights are generated to meet the prescribed statistical moments by calc_ffh' call build_heights ( vec_out = tab_tmp ( 1 : l ), & ! OUT use_fct_expo = ( PARAM % m_stt % ku < 1.34 * PARAM % m_stt % sk ** 2 + 1.8 ), & ! IN stats_in = PARAM % m_stt , & ! IN lg = l ) ! IN call std_array ( tab = tab_tmp ( 1 : l ), mx = m_res ) write ( TER , * ) 'starting statistical moments ' , m_res % mu , m_res % va , m_res % sk , m_res % ku call scramble ( tab = tab_tmp ( 1 : l ), & ! INOUT lg = l ) ! IN PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) deallocate ( tab_tmp ) return endsubroutine calc_z_i","tags":"","loc":"proc/calc_z_i.html"},{"title":"def_size – CREST","text":"private  subroutine def_size() Geometrical characteristics of the numerical surface Arguments None Called by proc~~def_size~~CalledByGraph proc~def_size def_size proc~read_job read_job proc~read_job->proc~def_size proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine def_size () !! Geometrical characteristics of the numerical surface implicit none integer ( kind = I4 ) :: w , h logical ( kind = I4 ) :: period real ( kind = R8 ) :: lw , lh read ( JOB , * ) w , h ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"width, height  \" , w , h read ( JOB , * ) lw , lh ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"img width and height (m) \" , lw , lh read ( JOB , * ) period ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"periodic surface? \" , period PARAM % periodic = period PARAM % width = w PARAM % height = h PARAM % npts = w * h PARAM % surf_width = lw PARAM % surf_height = lh PARAM % surf_dx = lw / w PARAM % surf_dy = lh / h return endsubroutine def_size","tags":"","loc":"proc/def_size.html"},{"title":"digi_fil – CREST","text":"private  subroutine digi_fil() Note Function that applies the digital filter to the random heights Arguments None Calls proc~~digi_fil~~CallsGraph proc~digi_fil digi_fil calc_fftw3_real_bwd calc_fftw3_real_bwd proc~digi_fil->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~digi_fil->calc_fftw3_real_fwd std_array std_array proc~digi_fil->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~digi_fil~~CalledByGraph proc~digi_fil digi_fil proc~read_job read_job proc~read_job->proc~digi_fil proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine digi_fil () !================================================================================================ !<@note Function that applies the digital filter to the random heights !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h complex ( kind = R8 ), dimension (:,:), allocatable :: cmple complex ( kind = R8 ), dimension (:,:), allocatable :: ftab ! FFT(tab_prf) type ( MOMENT_STAT ) :: m_res write ( SPY , * ) 'digi_fil -> 1 - extends then windows PARAM%surf to calculate its FFT ftab' write ( SPY , * ) 'digi_fil -> 2 - multiplies ftab and the digital filter PARAM%fhi, then FFT-1' write ( SPY , * ) 'digi_fil -> 3 - retrieves PARAM%surf by removing the padded extension' w = PARAM % width h = PARAM % height allocate ( cmple ( 1 : w , 1 : h ) ) ! allocate ( ftab ( 1 : w , 1 : h ) ) ! cmple ( 1 : w , 1 : h ) = cmplx ( PARAM % surf ( 1 : w , 1 : h ), 0 , kind = R8 ) call calc_fftw3_real_fwd ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! IN tab_ou = cmple ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN ftab ( 1 : w , 1 : h ) = cmple ( 1 : w , 1 : h ) where ( abs ( cmple ( 1 : w , 1 : h )) > 100 * EPS_R8 ) ftab ( 1 : w , 1 : h ) = cmple ( 1 : w , 1 : h ) / abs ( cmple ( 1 : w , 1 : h ) ) elsewhere ftab ( 1 : w , 1 : h ) = cmplx ( UN , 0._R8 , kind = R8 ) endwhere write ( SPY , * ) 'ftab normalized' !-------------------------------------------------------------------- ! FFT of the filter * FFT of the random heights !-------------------------------------------------------------------- cmple ( 1 : w , 1 : h ) = PARAM % fhi ( 1 : w , 1 : h ) * ftab ( 1 : w , 1 : h ) call calc_fftw3_real_bwd ( tab_in = cmple ( 1 : w , 1 : h ), & ! IN tab_ou = PARAM % surf ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN call std_array ( tab = PARAM % surf ( 1 : w , 1 : h ), mx = m_res ) write ( SPY , * ) 'sk ku fin ' , m_res % sk , m_res % ku deallocate ( cmple ) deallocate ( ftab ) return endsubroutine digi_fil","tags":"","loc":"proc/digi_fil.html"},{"title":"end_loop – CREST","text":"private  subroutine end_loop() The loop ends here Arguments None Called by proc~~end_loop~~CalledByGraph proc~end_loop end_loop proc~read_job read_job proc~read_job->proc~end_loop proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine end_loop () !! The loop ends here implicit none integer ( kind = I4 ) :: i_ligne if ( I_ITER < NB_ITER ) then rewind ( JOB ) ! the maximum number of loops is not reached, ! go to the begining of the script else I_ITER = NB_ITER ! the maximum number of loops is reached return endif ! return to the beginning of the loop LINE_READ = SAVE_LINE_READ do i_ligne = 1 , SAVE_LINE_READ read ( JOB , * ) enddo I_ITER = I_ITER + 1 return endsubroutine end_loop","tags":"","loc":"proc/end_loop.html"},{"title":"end_scri – CREST","text":"private  subroutine end_scri() End of script Arguments None Calls proc~~end_scri~~CallsGraph proc~end_scri end_scri end_fftw3 end_fftw3 proc~end_scri->end_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~end_scri~~CalledByGraph proc~end_scri end_scri proc~read_job read_job proc~read_job->proc~end_scri proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine end_scri () !! End of script implicit none close ( SPY ) close ( STA ) if ( allocated ( PARAM % imp_acf ) ) deallocate ( PARAM % imp_acf ) if ( allocated ( PARAM % acf_surf ) ) deallocate ( PARAM % acf_surf ) if ( allocated ( PARAM % surf_LF ) ) deallocate ( PARAM % surf_LF ) if ( allocated ( PARAM % surf_HF ) ) deallocate ( PARAM % surf_HF ) if ( allocated ( PARAM % surf_msk ) ) deallocate ( PARAM % surf_msk ) if ( allocated ( PARAM % surf ) ) deallocate ( PARAM % surf ) if ( allocated ( PARAM % surf_copy ) ) deallocate ( PARAM % surf_copy ) if ( allocated ( PARAM % vect_h ) ) deallocate ( PARAM % vect_h ) if ( allocated ( PARAM % fhi ) ) deallocate ( PARAM % fhi ) if ( allocated ( PARAM % order ) ) deallocate ( PARAM % order ) call end_fftw3 () return endsubroutine end_scri","tags":"","loc":"proc/end_scri.html"},{"title":"make_msk – CREST","text":"private  subroutine make_msk() Note Function that reads a digital surf file and turns it into a mask Arguments None Called by proc~~make_msk~~CalledByGraph proc~make_msk make_msk proc~read_job read_job proc~read_job->proc~make_msk proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine make_msk () !================================================================================================ !<@note Function that reads a digital surf file and turns it into a mask !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h w = PARAM % width h = PARAM % height allocate ( PARAM % surf_msk ( 1 : w , 1 : h )) PARAM % surf_msk ( 1 : w , 1 : h ) = nint ( PARAM % surf ( 1 : w , 1 : h ) ) return endsubroutine make_msk","tags":"","loc":"proc/make_msk.html"},{"title":"make_scratches – CREST","text":"private  subroutine make_scratches() Note This subroutine initializes a real matrix tab of dimensions nx by ny with ones Arguments None Called by proc~~make_scratches~~CalledByGraph proc~make_scratches make_scratches proc~read_job read_job proc~read_job->proc~make_scratches proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine make_scratches () !================================================================================================ !< @note This subroutine initializes a real matrix `tab` of dimensions `nx` by `ny` with ones !        and adds `sn` linear scratches with value 0. Each scratch has a random length up to `sl`, !        a constant width `sw`, and a random orientation. Scratches can touch the matrix boundaries. ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: nx ! Number of rows integer ( kind = I4 ) :: ny ! Number of columns integer ( kind = I4 ) :: sn ! Number of scratches integer ( kind = I4 ) :: sw ! Scratch width integer ( kind = I4 ) :: sl ! Maximum scratch length integer ( kind = I4 ) :: i , j , n real ( kind = R8 ) :: theta , length , depth , x0 , y0 , x1 , y1 real ( kind = R8 ) :: rand , r1 , r2 nx = PARAM % width ny = PARAM % height read ( JOB , * ) sn , sw , sl ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"sn, sw, sl  \" , sn , sw , sl ! Initialize matrix with ones PARAM % surf ( 1 : nx , 1 : ny ) = 1.0_R8 ! Seed random number generator call random_seed () ! Generate each scratch do n = 1 , sn ! Random starting point call random_number ( rand ) x0 = rand * nx call random_number ( rand ) y0 = rand * ny ! Random depth ! Génération de deux variables gamma call gamma_random ( shape = 3._R8 , output = r1 ) call gamma_random ( shape = 1._R8 , output = r2 ) ! Transformation pour obtenir la loi bêta depth = r1 / ( r1 + r2 ) ! Random orientation (angle in radians) call random_number ( rand ) theta = rand * 2.0 * PI_R8 ! Random length up to sl call random_number ( rand ) length = ( 2 * ( rand - 0.5_R8 ) / 10 + 0.9_R8 ) * sl ! Calculate end point of the scratch x1 = x0 + length * cos ( theta ) y1 = y0 + length * sin ( theta ) ! Draw the scratch with width sw do i = max ( 1 , floor ( min ( x0 , x1 )) - sw ), min ( nx , ceiling ( max ( x0 , x1 )) + sw ) do j = max ( 1 , floor ( min ( y0 , y1 )) - sw ), min ( ny , ceiling ( max ( y0 , y1 )) + sw ) ! Check if point (i,j) is within sw/2 distance from the line segment if ( point_to_line_distance ( real ( i , kind = R8 ), real ( j , kind = R8 ), x0 , y0 , x1 , y1 ) <= sw / 2.0 ) then PARAM % surf ( i , j ) = depth endif enddo enddo enddo contains subroutine gamma_random ( shape , output ) implicit none real ( kind = R8 ), intent ( in ) :: shape real ( kind = R8 ), intent ( out ) :: output real ( kind = R8 ) :: b , c real ( kind = R8 ) :: u , v , w , y ! algorithme de marsaglia pour générer une variable gamma b = shape - 1.0 / 3.0 c = 1.0 / sqrt ( 9.0 * b ) do call random_number ( u ) call random_number ( v ) v = 1.0 + c * log ( v ) / sqrt ( u ) if ( v <= 0.0 ) cycle w = v * v * v call random_number ( y ) if ( y < 1.0 - 0.0331 * ( log ( v ) ** 4 )) exit if ( log ( y ) < 0.5 * log ( v ) * log ( v ) + b * ( 1.0 - v + log ( v ))) exit enddo output = b * w return endsubroutine gamma_random !----------------------------------------- real ( kind = R8 ) function point_to_line_distance ( px , py , x0 , y0 , x1 , y1 ) !! Calculate the shortest distance from a point to a line segment. implicit none real ( kind = R8 ), intent ( in ) :: px !! x-coordinate of the point real ( kind = R8 ), intent ( in ) :: py !! y-coordinate of the point real ( kind = R8 ), intent ( in ) :: x0 !! x-coordinate of the line segment start real ( kind = R8 ), intent ( in ) :: y0 !! y-coordinate of the line segment start real ( kind = R8 ), intent ( in ) :: x1 !! x-coordinate of the line segment end real ( kind = R8 ), intent ( in ) :: y1 !! y-coordinate of the line segment end real ( kind = R8 ) :: dx , dy , t , proj_x , proj_y dx = x1 - x0 dy = y1 - y0 ! Handle case where start and end points are the same if ( ( dx ** 2 + dy ** 2 ) < 1.e-12 ) then point_to_line_distance = sqrt (( px - x0 ) ** 2 + ( py - y0 ) ** 2 ) return endif ! Project point onto the line t = max ( 0.0_R8 , min ( 1.0_R8 , (( px - x0 ) * dx + ( py - y0 ) * dy ) / ( dx * dx + dy * dy ))) proj_x = x0 + t * dx proj_y = y0 + t * dy ! Calculate distance point_to_line_distance = sqrt ( ( px - proj_x ) ** 2 + ( py - proj_y ) ** 2 ) return endfunction point_to_line_distance !----------------------------------------- endsubroutine make_scratches","tags":"","loc":"proc/make_scratches.html"},{"title":"make_tex – CREST","text":"private  subroutine make_tex() Note Function that creates a periodic macro-texture: knowing the FFT of an analytical texture Arguments None Calls proc~~make_tex~~CallsGraph proc~make_tex make_tex calc_fftw3 calc_fftw3 proc~make_tex->calc_fftw3 calc_moments calc_moments proc~make_tex->calc_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~make_tex~~CalledByGraph proc~make_tex make_tex proc~read_job read_job proc~read_job->proc~make_tex proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine make_tex () !================================================================================================ !< @note Function that creates a periodic macro-texture: knowing the FFT of an analytical texture !        a surface is created and then transformed by a FFT. As a result it is periodic. !  @endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), allocatable , dimension (:) :: xloc , yloc , haut real ( kind = R8 ) :: ca , sa , a , b , c , x0 , y0 , h0 integer ( kind = I4 ) :: kk , w2 , h2 complex ( kind = R8 ) :: eix , eiy , ftmp real ( kind = R8 ) :: x1 , y1 , ax , ay , sx , sy , coeff integer ( kind = I4 ) :: ksi , eta complex ( kind = R8 ), allocatable , dimension (:,:) :: cmpl_in , cmpl_ou , ft real ( kind = R8 ) :: alpha ! texture orientation real ( kind = R8 ) :: sigmax , sigmay ! texture stdv integer ( kind = I4 ) :: texture ! number of texture elements character ( len = 016 ) :: dimples ! texture elementar shapes: \"circle\" or \"square\" real ( kind = R8 ) :: dx , dy integer ( kind = I4 ) :: w , h , l type ( MOMENT_STAT ) :: m_res w = PARAM % width h = PARAM % height l = PARAM % npts dx = PARAM % surf_dx dy = PARAM % surf_dy read ( JOB , * ) dimples ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"dimples \" , dimples read ( JOB , * ) texture ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"texture \" , texture sigmax = PARAM % curr_surf % cl1 / dx / w * 2 sigmay = PARAM % curr_surf % cl2 / dx / h * 2 alpha = PARAM % curr_surf % ang w2 = w / 2 h2 = h / 2 if ( w == 2 * ( w / 2 ) + 1 ) w2 = w / 2 + 1 if ( h == 2 * ( h / 2 ) + 1 ) h2 = h / 2 + 1 allocate ( cmpl_in ( 1 : w , 1 : h ), & ! cmpl_ou ( 1 : w , 1 : h ) ) ! allocate ( ft ( - w / 2 : w2 - 1 , & ! - h / 2 : h2 - 1 ) ) ! allocate ( xloc ( 1 : TEXTURE ), & ! yloc ( 1 : TEXTURE ), & ! haut ( 1 : TEXTURE ) ) ! ca = cos ( alpha * PI_R8 / 180 ) sa = sin ( alpha * PI_R8 / 180 ) ! Gaussian coefficients a = 0.5 * ( ( ca / sigmax ) * ( ca / sigmax ) + ( sa / sigmay ) * ( sa / sigmay ) ) c = 0.5 * ( ( sa / sigmax ) * ( sa / sigmax ) + ( ca / sigmay ) * ( ca / sigmay ) ) b = 1.0 * ( ( sa / sigmax ) * ( ca / sigmax ) - ( sa / sigmay ) * ( ca / sigmay ) ) call random_number ( xloc ( 1 : TEXTURE ) ) ! localisation in [0,1]x[0,1] call random_number ( yloc ( 1 : TEXTURE ) ) call random_number ( haut ( 1 : TEXTURE ) ) haut ( 1 : TEXTURE ) = 2 * haut ( 1 : TEXTURE ) - 1._R8 coeff = 2 * pi_R8 do ksi = - w / 2 , w2 - 1 do eta = - h / 2 , h2 - 1 x1 = ( + ksi * ca + eta * sa ) * coeff y1 = ( - ksi * sa + eta * ca ) * coeff ftmp = 0 sx = sigmax sy = sigmay do kk = 1 , TEXTURE ! nombre de pics sur le niveau niv x0 = xloc ( kk ) y0 = yloc ( kk ) h0 = haut ( kk ) ! d'un niveau à l'autre, on atténue les pics d'un facteur \"per_tex\" ax = - x1 * x0 ay = - y1 * y0 eix = cmplx ( cos ( ax ), sin ( ax ), kind = R8 ) eiy = cmplx ( cos ( ay ), sin ( ay ), kind = R8 ) select case ( DIMPLES ( 1 : 6 ) ) case ( \"square\" ) ftmp = ftmp + 2 * h0 * pi_R8 * sx * sy * sinc ( sx * x1 ) * eix & ! * sinc ( sy * y1 ) * eiy case ( \"circle\" ) ftmp = ftmp + 2 * h0 * pi_R8 * sx * sy * exp ( - 0.5 * ( sx ** 2 ) * ( x1 ** 2 ) ) * eix & ! * exp ( - 0.5 * ( sy ** 2 ) * ( y1 ** 2 ) ) * eiy case default stop \"make_terra, no dimple type selected\" endselect enddo ft ( ksi , eta ) = ftmp enddo enddo cmpl_in ( 1 : w2 , 1 : h2 ) = ft ( 0 : w2 - 1 , 0 : h2 - 1 ) ! SO = NE cmpl_in ( 1 : w2 , h2 + 1 : h ) = ft ( 0 : w2 - 1 , - h / 2 : - 1 ) ! SE = NO cmpl_in ( w2 + 1 : w , 1 : h2 ) = ft ( - w / 2 : - 1 , 0 : h2 - 1 ) ! NO = SE cmpl_in ( w2 + 1 : w , h2 + 1 : h ) = ft ( - w / 2 : - 1 , - h / 2 : - 1 ) ! NE = SO FFT_DIM = 0 ! forces fftw desalloc and reinit call calc_fftw3 ( sens = BACKWARD , & ! tab_in = cmpl_in ( 1 : w , 1 : h ), & ! tab_ou = cmpl_ou ( 1 : w , 1 : h ), & ! long = w , & ! larg = h ) ! FFT_DIM = 0 ! forces fftw desalloc and reinit PARAM % surf ( 1 : w , 1 : h ) = real ( cmpl_ou ( 1 : w , 1 : h ), kind = R8 ) * sqrt ( real ( w * h , kind = R8 )) call calc_moments ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN mx = m_res , & ! OUT nb_mom = 3 ) ! IN if ( m_res % sk > 0. ) PARAM % surf ( 1 : w , 1 : h ) = - PARAM % surf ( 1 : w , 1 : h ) deallocate ( xloc , yloc , haut ) deallocate ( cmpl_in , cmpl_ou ) contains !----------------------------------------- function sinc ( x ) implicit none real ( kind = R8 ) :: sinc real ( kind = R8 ), intent ( in ) :: x if ( abs ( x ) > 1.0e-8 ) then sinc = sin ( x ) / x else sinc = UN endif return endfunction sinc !----------------------------------------- endsubroutine make_tex","tags":"","loc":"proc/make_tex.html"},{"title":"nb_procs – CREST","text":"private  subroutine nb_procs() Number of concurrent threads Arguments None Calls proc~~nb_procs~~CallsGraph proc~nb_procs nb_procs omp_get_num_procs omp_get_num_procs proc~nb_procs->omp_get_num_procs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nb_procs~~CalledByGraph proc~nb_procs nb_procs proc~read_job read_job proc~read_job->proc~nb_procs proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine nb_procs () !! Number of concurrent threads implicit none integer ( kind = I4 ) :: nb_th read ( JOB , * ) nb_th ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , 'nb_procs' , nb_th select case ( nb_th ) case ( 0 ) ! no multihreading PARAM % nb_threads = 1 NB_THREADS_FFT = 1 case ( - 1 ) ! determined by system PARAM % nb_threads = omp_get_num_procs () NB_THREADS_FFT = PARAM % nb_threads case default stop 'Bad choice \"nb_procs\" in \"mod_script\"' endselect return endsubroutine nb_procs","tags":"","loc":"proc/nb_procs.html"},{"title":"plt__acf – CREST","text":"private  subroutine plt__acf() Note Function that calculates the mean absolute difference between the desired Acf and\n the one obtained.\n However, the important zone where both should match is above the cut - where the correlation\n lengths are determined. If the mean absolute difference is below the criterion, the loops to improve the acf are\n stopped. The function can also plot the acfs. Arguments None Calls proc~~plt__acf~~CallsGraph proc~plt__acf plt__acf dir_separator dir_separator proc~plt__acf->dir_separator ellipse_acf ellipse_acf proc~plt__acf->ellipse_acf get_unit get_unit proc~plt__acf->get_unit mkdir mkdir proc~plt__acf->mkdir Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~plt__acf~~CalledByGraph proc~plt__acf plt__acf proc~read_job read_job proc~read_job->proc~plt__acf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine plt__acf () !================================================================================================ !<@note Function that calculates the mean absolute difference between the desired Acf and !< the one obtained. !< However, the important zone where both should match is above the cut - where the correlation !< lengths are determined. !< !< If the mean absolute difference is below the criterion, the loops to improve the acf are !< stopped. !< !< The function can also plot the acfs. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: i , w , h , mw , mh , uplot , ll logical ( kind = I4 ) :: is_x , is_y real ( kind = R8 ) :: lim_crit_acf , crit_acf , dxy , l1 , l2 character ( len = 512 ) :: plt_acf real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp real ( kind = R8 ), dimension ( 1 : 8 ) :: res read ( JOB , * ) lim_crit_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , \"Acf criterion \" , lim_crit_acf read ( JOB , * ) plt_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , trim ( plt_acf ) PARAM % crt_acf = lim_crit_acf ! mean absolute difference limit w = PARAM % width h = PARAM % height ! Mean absolute difference between the calculated acf and the theoretical acf !................................................................................... if ( PARAM % curr_surf % cut > 0 ) then allocate ( tab_tmp ( 1 : w , 1 : h ) ) tab_tmp ( 1 : w , 1 : h ) = 0 where ( PARAM % imp_acf > PARAM % curr_surf % cut ) tab_tmp = abs ( PARAM % acf_surf - PARAM % imp_acf ) crit_acf = 100 * sum ( tab_tmp ( 1 : w , 1 : h ) ) / count ( tab_tmp ( 1 : w , 1 : h ) > 0 ) PARAM % res_acf = crit_acf deallocate ( tab_tmp ) write ( TER , * ) \"acf difference \" , crit_acf write ( SPY , * ) 'acf difference ' , crit_acf ! if the acf criterion is reached, the loops stop: a means is to modify the max number ! of loops, so that the main loop is exited. if ( lim_crit_acf > 0. . and . lim_crit_acf > crit_acf ) NB_ITER = 1 endif !................................................................................... ! Graphs? !................................................................................... ! if 'x' is present, plot the graph along the principal axis ! if 'y' is present, plot the graph along the secondary axis is_x = ( index ( trim ( plt_acf ), 'x' ) /= 0 ) is_y = ( index ( trim ( plt_acf ), 'y' ) /= 0 ) if ( . not .( is_x . or . is_y ) ) return mw = w / 2 + 1 mh = h / 2 + 1 call ellipse_acf ( tabin = PARAM % acf_surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN p_acv = res ( 1 : 8 ), & ! OUT -> correlation lengths cut = PARAM % curr_surf % cut , & ! IN  -> z cut plane scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN  -> lags along x and y omp = . true . ) ! IN  -> use multithread? write ( TER , * ) res ( 1 : 2 ), res ( 4 ) write ( SPY , * ) 'acf lengths and roughness orientation ' , res ( 1 : 2 ), res ( 4 ) ! parameters for the plot ll = 2 * min ( mw , mh ) - 3 dxy = sqrt ( PARAM % surf_dx ** 2 + PARAM % surf_dy ** 2 ) call get_unit ( uplot ) if ( is_x ) call graph ( axis = 1 ) if ( is_y ) call graph ( axis = 2 ) contains subroutine graph ( axis ) !================================================================================================ !<@note Function that plots the graphs to compare the ACF along the primary and/or secondary axes. !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: axis !! *1 or 2 for primary or secondary axis* integer ( kind = I4 ) :: exit_status logical ( kind = I4 ) :: dir_exists character ( len = 256 ) :: file_acf , file_gpl , title , cwd character ( len = 003 ) :: xlab character ( len = 1 ) :: os_sep real ( kind = R8 ) :: angle real ( kind = R8 ), allocatable , dimension (:) :: profile_acf_surf , profile_imp_acf allocate ( profile_acf_surf ( 1 : ll ) ) allocate ( profile_imp_acf ( 1 : ll ) ) ! if \"out/gpl\" does not exist, create it inquire ( file = \"out/gpl\" , exist = dir_exists ) if ( . not . dir_exists ) then os_sep = dir_separator () call getcwd ( cwd ) call mkdir ( wkd = trim ( cwd ), directory = \"out/gpl\" , sep = os_sep , exit_status = exit_status ) endif if ( axis == 1 ) then angle = PARAM % curr_surf % ang file_acf = 'out/gpl/acfx.txt' file_gpl = 'out/gpl/acfx.gpl' title = '\"ACF comparison along primary axis X\"' xlab = '\"X\"' else angle = PARAM % curr_surf % ang + 9 0. file_acf = 'out/gpl/acfy.txt' file_gpl = 'out/gpl/acfy.gpl' title = '\"ACF comparison along secondary axis Y\"' xlab = '\"Y\"' endif ! extract the ACF profile along a particular direction call profile_at_angle ( tab = PARAM % acf_surf ( 1 : w , 1 : h ), profile = profile_acf_surf ( 1 : ll ), theta = angle ) call profile_at_angle ( tab = PARAM % imp_acf ( 1 : w , 1 : h ), profile = profile_imp_acf ( 1 : ll ), theta = angle ) open ( uplot , file = trim ( file_acf )) write ( uplot , * ) 'X' , '\"calculated acf\"' , '\"theoretical acf\"' do i = 1 , ll write ( uplot , * ) ( i - ll / 2 ) * dxy , real ( profile_acf_surf ( i ), kind = R4 ), & ! real ( profile_imp_acf ( i ), kind = R4 ) ! if ( i - ll / 2 < 0 ) then if ( profile_acf_surf ( i ) < PARAM % curr_surf % cut . and . profile_acf_surf ( i + 1 ) > PARAM % curr_surf % cut ) l1 = ( i - ll / 2 ) * dxy endif if ( i - ll / 2 > 0 . and . i < ll ) then if ( profile_acf_surf ( i ) > PARAM % curr_surf % cut . and . profile_acf_surf ( i + 1 ) < PARAM % curr_surf % cut ) l2 = ( i - ll / 2 ) * dxy endif enddo close ( uplot ) open ( uplot , file = trim ( file_gpl )) write ( uplot , '(a)' ) 'set title ' // trim ( title ) write ( uplot , '(a)' ) 'set xlabel ' // trim ( xlab ) write ( uplot , '(a)' ) 'set ylabel \"ACF\"' write ( uplot , '(a,f4.2,a,f5.2,a)' ) \"set arrow from graph 0, first \" , PARAM % curr_surf % cut , & ! \" to graph 1, first \" , PARAM % curr_surf % cut , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2,a)' ) \"set arrow from \" , l1 , \", graph 0 to \" , & ! l1 , \",\" , PARAM % curr_surf % cut , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2,a)' ) \"set arrow from \" , l2 , \", graph 0 to \" , & ! l2 , \",\" , PARAM % curr_surf % cut , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2)' ) 'set label \"L1 = ' , res ( axis ), '\" at ' , l2 , ',' , PARAM % curr_surf % cut + 0.1 write ( uplot , '(a,i2,a)' ) 'plot \"' // trim ( file_acf ) // '\" using 1:2 with lines title \"acf real surface\", \"' // trim ( file_acf ) // '\" using 1:3 with lines title \"theoretical acf\"' write ( uplot , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( uplot , '(a)' ) 'q' close ( uplot ) call system ( 'gnuplot \"' // trim ( file_gpl ) // '\"' ) deallocate ( profile_acf_surf ) deallocate ( profile_imp_acf ) return endsubroutine graph subroutine profile_at_angle ( tab , profile , theta ) !================================================================================================ !<@note Function that extract the ACF profile along a particular direction !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: tab real ( kind = R8 ), intent ( in ) :: theta real ( kind = R8 ), intent ( out ), dimension ( 1 : ll ) :: profile integer ( kind = I4 ) :: p , nx , ny real ( kind = R8 ) :: r , x , y , xb , yb , xm , ym , xp , yp , h1 , h2 , h3 , h4 , hh do p = - ll / 2 , ll / 2 !  identifying a point on the diameter r = p !  corresponding algebraic radius !  projection on x and y of the point marked by its radius and angle !  by taking the lower integer, we have the number of the bottom row and left-hand column of the rectangle !  the remainder (x-nx) represents the abscissa of the point in the rectangle with sides=1 !  the 0.9999 coefficient is used to avoid falling right on an existing point x = mw + r * cos ( theta * PI_R8 / 180 ) * 0.9999_R8 ; nx = floor ( x ) ; xb = x - nx y = mh + r * sin ( theta * PI_R8 / 180 ) * 0.9999_R8 ; ny = floor ( y ) ; yb = y - ny xm = UN - xb ; xp = xb ym = UN - yb ; yp = yb if ( nx + 1 <= w . and . ny + 1 <= h . and . & ! nx >= 1 . and . ny >= 1 ) then ! attention r may be greater than lo2 or la2 h1 = tab ( nx , ny ) h2 = tab ( nx + 1 , ny ) h3 = tab ( nx + 1 , ny + 1 ) h4 = tab ( nx , ny + 1 ) hh = h1 * xm * ym + & ! h2 * xp * ym + & ! h3 * xp * yp + & ! h4 * xm * yp ! profile ( p + ll / 2 + 1 ) = hh endif enddo return endsubroutine profile_at_angle endsubroutine plt__acf","tags":"","loc":"proc/plt__acf.html"},{"title":"read_img – CREST","text":"private  subroutine read_img() Note Function that reads a digital surf file and returns the surface in PARAM%surf Arguments None Calls proc~~read_img~~CallsGraph proc~read_img read_img read_surf read_surf proc~read_img->read_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_img~~CalledByGraph proc~read_img read_img proc~read_job read_job proc~read_job->proc~read_img proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine read_img () !================================================================================================ !<@note Function that reads a digital surf file and returns the surface in PARAM%surf !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 512 ) :: nom_surf nom_surf = repeat ( \" \" , len ( nom_surf ) ) read ( JOB , * ) nom_surf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , trim ( nom_surf ) ! read the surface, no scaling, no centering call read_surf ( nom_fic = trim ( nom_surf ), & ! IN tab_s = PARAM % surf , & ! OUT scal = SCALE_IMG ) ! OUT PARAM % width = SCALE_IMG % xres PARAM % height = SCALE_IMG % yres PARAM % npts = SCALE_IMG % xres * SCALE_IMG % yres PARAM % surf_dx = SCALE_IMG % lx / SCALE_IMG % xres PARAM % surf_dy = SCALE_IMG % ly / SCALE_IMG % yres PARAM % surf_width = SCALE_IMG % lx PARAM % surf_height = SCALE_IMG % ly write ( * , * ) \"width \" , PARAM % width , \" height \" , PARAM % height , \" npts \" , PARAM % npts write ( * , * ) \"surf dx \" , PARAM % surf_dx , \" dy \" , PARAM % surf_dy write ( * , * ) \"width \" , PARAM % surf_width , \" height \" , PARAM % surf_height return endsubroutine read_img","tags":"","loc":"proc/read_img.html"},{"title":"read_job – CREST","text":"public  subroutine read_job(job_file) Note Function that reads a script file. Keywords are identified and corresponding actions are\n triggered. Arguments Type Intent Optional Attributes Name character(len=512), intent(in) :: job_file job file with macros to execute Calls proc~~read_job~~CallsGraph proc~read_job read_job get_unit get_unit proc~read_job->get_unit proc~acf_theo acf_theo proc~read_job->proc~acf_theo proc~add_nois add_nois proc~read_job->proc~add_nois proc~alloc_tabs alloc_tabs proc~read_job->proc~alloc_tabs proc~apod_acf apod_acf proc~read_job->proc~apod_acf proc~apod_sur apod_sur proc~read_job->proc~apod_sur proc~calc_acf calc_acf proc~read_job->proc~calc_acf proc~calc_ffh calc_ffh proc~read_job->proc~calc_ffh proc~calc_ord calc_ord proc~read_job->proc~calc_ord proc~calc_z_f calc_z_f proc~read_job->proc~calc_z_f proc~calc_z_i calc_z_i proc~read_job->proc~calc_z_i proc~def_size def_size proc~read_job->proc~def_size proc~digi_fil digi_fil proc~read_job->proc~digi_fil proc~end_loop end_loop proc~read_job->proc~end_loop proc~end_scri end_scri proc~read_job->proc~end_scri proc~make_msk make_msk proc~read_job->proc~make_msk proc~make_scratches make_scratches proc~read_job->proc~make_scratches proc~make_tex make_tex proc~read_job->proc~make_tex proc~nb_procs nb_procs proc~read_job->proc~nb_procs proc~plt__acf plt__acf proc~read_job->proc~plt__acf proc~read_img read_img proc~read_job->proc~read_img proc~repr_img repr_img proc~read_job->proc~repr_img proc~save_img save_img proc~read_job->proc~save_img proc~smooth__ smooth__ proc~read_job->proc~smooth__ proc~spct_sur spct_sur proc~read_job->proc~spct_sur proc~sta_loop sta_loop proc~read_job->proc~sta_loop proc~sta_scri sta_scri proc~read_job->proc~sta_scri proc~sta_theo sta_theo proc~read_job->proc~sta_theo proc~stat_sur stat_sur proc~read_job->proc~stat_sur proc~sub_surf sub_surf proc~read_job->proc~sub_surf proc~surface_analysis surface_analysis proc~read_job->proc~surface_analysis selectcase selectcase proc~read_job->selectcase str_remove_chars str_remove_chars proc~read_job->str_remove_chars ellipse_acf ellipse_acf proc~acf_theo->ellipse_acf proc~calc_imp_acf calc_imp_acf proc~acf_theo->proc~calc_imp_acf proc~build_heights build_heights proc~add_nois->proc~build_heights scramble scramble proc~add_nois->scramble std_array std_array proc~add_nois->std_array proc~apod_acf->ellipse_acf proc~apod2 apod2 proc~apod_acf->proc~apod2 apod apod proc~apod_sur->apod proc~apod_sur->std_array proc~acf_wiener acf_wiener proc~calc_acf->proc~acf_wiener calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_ffh->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_ffh->calc_fftw3_real_fwd calc_moments calc_moments proc~calc_ffh->calc_moments init_order init_order proc~calc_ord->init_order sort_array2 sort_array2 proc~calc_ord->sort_array2 proc~calc_z_f->proc~build_heights proc~calc_z_f->std_array proc~calc_z_i->proc~build_heights proc~calc_z_i->scramble proc~calc_z_i->std_array proc~digi_fil->calc_fftw3_real_bwd proc~digi_fil->calc_fftw3_real_fwd proc~digi_fil->std_array end_fftw3 end_fftw3 proc~end_scri->end_fftw3 calc_fftw3 calc_fftw3 proc~make_tex->calc_fftw3 proc~make_tex->calc_moments omp_get_num_procs omp_get_num_procs proc~nb_procs->omp_get_num_procs proc~plt__acf->get_unit dir_separator dir_separator proc~plt__acf->dir_separator proc~plt__acf->ellipse_acf mkdir mkdir proc~plt__acf->mkdir read_surf read_surf proc~read_img->read_surf proc~repr_img->proc~alloc_tabs proc~repr_img->proc~surface_analysis proc~repr_img->apod proc~repr_img->calc_moments fft_filter fft_filter proc~repr_img->fft_filter init_scal init_scal proc~repr_img->init_scal proc~repr_img->proc~acf_wiener proc~repr_img->scramble proc~repr_img->sort_array2 proc~repr_img->std_array write_surf write_surf proc~repr_img->write_surf proc~save_img->init_scal proc~save_img->write_surf proc~smooth__->fft_filter proc~smooth__->std_array proc~spct_sur->get_unit proc~spct_sur->proc~apod_sur proc~spct_sur->calc_fftw3 trans_corner2center trans_corner2center proc~spct_sur->trans_corner2center random_init random_init proc~sta_scri->random_init proc~stat_sur->proc~apod_sur proc~stat_sur->proc~surface_analysis proc~stat_sur->proc~acf_wiener proc~stat_sur->sort_array2 proc~stat_sur->std_array proc~sub_surf->calc_moments proc~sub_surf->end_fftw3 fftw_plan_with_nthreads fftw_plan_with_nthreads proc~sub_surf->fftw_plan_with_nthreads proc~sub_surf->init_order omp_get_max_threads omp_get_max_threads proc~sub_surf->omp_get_max_threads proc~sub_surf->proc~acf_wiener proc~sub_surf->proc~build_heights proc~sub_surf->proc~calc_imp_acf proc~calc_res_acf calc_res_acf proc~sub_surf->proc~calc_res_acf progress_bar_terminal progress_bar_terminal proc~sub_surf->progress_bar_terminal proc~sub_surf->sort_array2 tab_end_fftw3_real tab_end_fftw3_real proc~sub_surf->tab_end_fftw3_real tab_init_fftw3_real tab_init_fftw3_real proc~sub_surf->tab_init_fftw3_real proc~surface_analysis->get_unit abbott_param abbott_param proc~surface_analysis->abbott_param calc_median calc_median proc~surface_analysis->calc_median proc~surface_analysis->calc_moments calcul_asfc_hermite calcul_asfc_hermite proc~surface_analysis->calcul_asfc_hermite calcul_normales calcul_normales proc~surface_analysis->calcul_normales proc~surface_analysis->ellipse_acf proc~surface_analysis->fft_filter indice_fractal indice_fractal proc~surface_analysis->indice_fractal multiple_anisotropy multiple_anisotropy proc~surface_analysis->multiple_anisotropy peaks_and_pits_curvatures peaks_and_pits_curvatures proc~surface_analysis->peaks_and_pits_curvatures proc~surface_analysis->proc~acf_wiener surf_area surf_area proc~surface_analysis->surf_area topology topology proc~surface_analysis->topology proc~acf_wiener->calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_fwd proc~acf_wiener->trans_corner2center tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd proc~build_heights->sort_array2 proc~build_heights->std_array proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo init pikaia_class%init proc~pikaia_skku_solver->init solve pikaia_class%solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_job~~CalledByGraph proc~read_job read_job proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine read_job ( job_file ) !================================================================================================ !<@note Function that reads a script file. Keywords are identified and corresponding actions are !< triggered. !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 512 ), intent ( in ) :: job_file !! *job file with macros to execute* integer ( kind = I4 ) :: vide character ( len = 512 ) :: keyword logical ( kind = I4 ) :: first ! script file call get_unit ( JOB ) open ( unit = JOB , file = trim ( job_file ), status = 'old' ) call check_empty_lines () ! witness file call get_unit ( SPY ) open ( unit = SPY , file = \"out/spy.txt\" , status = 'unknown' ) LINE_READ = 0 first = . true . ! determine if calc_z_f has been already used ! default function used: the tangent function PARAM % func_gen = FCT_TANG ! default is 2 bounds when generating profiles PARAM % nparam = 2 PARAM % calc_mstt = . true . PARAM % calc_zf = . true . ! default cutting plane for correlation lengths PARAM % orig_surf % cut = 0.5 PARAM % curr_surf % cut = 0.5 o : do keyword = repeat ( ' ' , len ( keyword ) ) read ( JOB , * , iostat = vide ) keyword ; LINE_READ = LINE_READ + 1 ! remove unwanted characters from keyword keyword = str_remove_chars ( string = trim ( keyword ), chars = '- # *' ) write ( SPY , '(a6,I4.4,a)' ) \"line: \" , LINE_READ , ' ' , trim ( keyword ) selectcase ( keyword ( 1 : 8 ) ) case ( 'ACF_THEO' ) ! desired acf call acf_theo () case ( 'ADD_NOIS' ) ! add noise to current surface call add_nois () case ( 'ALLOCATE' ) ! allocate tabs in PARAM type call alloc_tabs () case ( 'ANALYSIS' ) call surface_analysis () case ( 'APOD_ACF' ) ! apodize acf call apod_acf () case ( 'APOD_SUR' ) ! apodize surface call apod_sur () case ( 'CALC_ACF' ) ! determine the surface acf call calc_acf () case ( 'CALC_FFH' ) ! deigital filter call calc_ffh () case ( 'CALC_ORD' ) ! determine height order call calc_ord () case ( 'CALC_Z_F' ) ! final heights call calc_z_f () case ( 'CALC_Z_I' ) ! starting heights call calc_z_i () case ( 'DEF_SIZE' ) ! image size call def_size () case ( 'DIGI_FIL' ) ! apply digital filter call digi_fil () case ( 'END_LOOP' ) ! loop end call end_loop () case ( 'END_SCRI' ) ! close the script reading call end_scri () exit o case ( 'MAKE_MSK' ) ! turn image into mask call make_msk () case ( 'MAKE_SCR' ) ! make secratches call make_scratches () case ( 'MAKE_TEX' ) ! build a texture call make_tex () case ( 'NB_PROCS' ) ! number of threads call nb_procs () case ( 'PLT__ACF' ) ! print the correlation graphs and/or determine ! if the stop criterion is reached. call plt__acf () case ( 'READ_PRF' ) ! read image call read_img () case ( 'REPR_IMG' ) ! reproduce image call repr_img () case ( 'SAVE_ACF' ) ! save the acf surface if ( sum ( PARAM % imp_acf ) == 0 ) then call save_img ( tab = PARAM % acf_surf ) ! IN: real acf else call save_img ( tab = PARAM % imp_acf ) ! IN: wanted acf endif case ( 'SAVE_PRF' ) ! save image call save_img ( tab = PARAM % surf ) ! IN: surface to save case ( 'SMOOTH__' ) ! low-pass filter call smooth__ () case ( 'SPCT_SUR' ) ! surface spectrum frequencies call spct_sur () case ( 'STA_LOOP' ) ! loop start call sta_loop () case ( 'STA_SCRI' ) ! start script call sta_scri () case ( 'STA_THEO' ) ! desired stat moments call sta_theo () case ( 'STAT_SUR' ) ! surface moments as reference call stat_sur () case ( 'SUB_SURF' ) ! extract the best surface call sub_surf () endselect enddo o close ( JOB ) contains subroutine check_empty_lines () !! Check for empty lines in the script implicit none do read ( JOB , '(A)' , iostat = vide ) keyword if ( vide < 0 ) then rewind ( JOB ) return endif if ( len_trim ( keyword ) == 0 ) stop 'Empty line in script file' enddo return endsubroutine check_empty_lines endsubroutine read_job","tags":"","loc":"proc/read_job.html"},{"title":"repr_img – CREST","text":"private  subroutine repr_img() Note Function that set parameters for image reproduction Arguments None Calls proc~~repr_img~~CallsGraph proc~repr_img repr_img apod apod proc~repr_img->apod calc_moments calc_moments proc~repr_img->calc_moments fft_filter fft_filter proc~repr_img->fft_filter init_scal init_scal proc~repr_img->init_scal proc~acf_wiener acf_wiener proc~repr_img->proc~acf_wiener proc~alloc_tabs alloc_tabs proc~repr_img->proc~alloc_tabs proc~surface_analysis surface_analysis proc~repr_img->proc~surface_analysis scramble scramble proc~repr_img->scramble sort_array2 sort_array2 proc~repr_img->sort_array2 std_array std_array proc~repr_img->std_array write_surf write_surf proc~repr_img->write_surf calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center proc~surface_analysis->calc_moments proc~surface_analysis->fft_filter proc~surface_analysis->proc~acf_wiener abbott_param abbott_param proc~surface_analysis->abbott_param calc_median calc_median proc~surface_analysis->calc_median calcul_asfc_hermite calcul_asfc_hermite proc~surface_analysis->calcul_asfc_hermite calcul_normales calcul_normales proc~surface_analysis->calcul_normales ellipse_acf ellipse_acf proc~surface_analysis->ellipse_acf get_unit get_unit proc~surface_analysis->get_unit indice_fractal indice_fractal proc~surface_analysis->indice_fractal multiple_anisotropy multiple_anisotropy proc~surface_analysis->multiple_anisotropy peaks_and_pits_curvatures peaks_and_pits_curvatures proc~surface_analysis->peaks_and_pits_curvatures surf_area surf_area proc~surface_analysis->surf_area topology topology proc~surface_analysis->topology Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~repr_img~~CalledByGraph proc~repr_img repr_img proc~read_job read_job proc~read_job->proc~repr_img proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine repr_img () !================================================================================================ !<@note Function that set parameters for image reproduction !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp , surf_tmp integer ( kind = I4 ) :: reproduction_step real ( kind = R8 ) :: cutoff , dx , dy type ( SCALE_SURF ) :: scale_img_tmp type ( MOMENT_STAT ) :: m_res read ( JOB , * ) reproduction_step ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"reproduction_step \" , reproduction_step w = PARAM % width h = PARAM % height l = PARAM % npts dx = PARAM % surf_dx dy = PARAM % surf_dy allocate ( tab_tmp ( 1 : w , 1 : h ) ) allocate ( surf_tmp ( 1 : w , 1 : h ) ) select case ( reproduction_step ) case ( 0 : 1 ) PARAM % orig_surf % cut = 0.5_R8 PARAM % curr_surf % cut = 0.5_R8 call alloc_tabs () PARAM % surf_copy ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) call calc_moments ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN mx = PARAM % m_ini , & ! OUT nb_mom = 4 ) ! IN call apod ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! tab_out = tab_tmp ( 1 : w , 1 : h ), & ! long = w , & ! larg = h , & ! type_apo = 'tuckey' ) ! call std_array ( tab_tmp ( 1 : w , 1 : h ) ) call acf_wiener ( tab_in = tab_tmp ( 1 : w , 1 : h ), & ! IN tab_out = PARAM % acf_surf ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h ) ! IN call surface_analysis ( app = 0 ) !-------------- NORMALIZATION ------------------------ call std_array ( PARAM % surf ( 1 : w , 1 : h ), PARAM % m_ini ) case ( 2 ) !------------ SAVE LOW FREQ SURF --------------------- PARAM % surf_LF ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) !------------ REPRODUCE HIGH FREQ --------------------- PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf_HF ( 1 : w , 1 : h ) PARAM % m_end = PARAM % m__HF PARAM % vect_h ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call sort_array2 ( tab_inout = PARAM % vect_h ( 1 : l ), n = l ) surf_tmp ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) case ( 3 ) !------------ SAVE HIGH FREQ SURF --------------------- PARAM % surf_HF ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf_LF ( 1 : w , 1 : h ) + PARAM % surf_HF ( 1 : w , 1 : h ) * PARAM % m__HF % si / PARAM % m__LF % si call std_array ( PARAM % surf ( 1 : w , 1 : h ) ) PARAM % vect_h ( 1 : l ) = reshape ( PARAM % surf_copy ( 1 : w , 1 : h ), [ l ] ) ! heights are sorted call sort_array2 ( tab_inout = PARAM % vect_h ( 1 : l ), n = l ) call calc_moments ( tab = PARAM % vect_h ( 1 : l ), & ! IN mx = m_res , & ! OUT nb_mom = 2 ) ! IN PARAM % vect_h ( 1 : l ) = ( PARAM % vect_h ( 1 : l ) - m_res % mu ) / m_res % si surf_tmp ( 1 : w , 1 : h ) = PARAM % surf_copy ( 1 : w , 1 : h ) call std_array ( surf_tmp ( 1 : w , 1 : h ) ) case ( 4 ) call std_array ( PARAM % surf ( 1 : w , 1 : h ) ) PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) * PARAM % m_ini % si + PARAM % m_ini % mu call surface_analysis ( app = 1 ) endselect select case ( reproduction_step ) case ( 0 ) PARAM % imp_acf ( 1 : w , 1 : h ) = PARAM % acf_surf ( 1 : w , 1 : h ) ! the calculated moments become the prescribed ones PARAM % m_end = PARAM % m_ini ! heights are stored because they are the prescribed ones PARAM % vect_h ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) ! shuffle the set, then ... call scramble ( tab = PARAM % vect_h ( 1 : l ), & ! INOUT lg = l ) ! IN ! ... define an initial random surface ... PARAM % surf ( 1 : w , 1 : h ) = reshape ( PARAM % vect_h ( 1 : l ), [ w , h ] ) ! and sort heights call sort_array2 ( tab_inout = PARAM % vect_h ( 1 : l ), n = l ) case ( 1 ) !------------ SUBTRACT LOW FREQ ---------------------- read ( JOB , * ) cutoff ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"cutoff \" , cutoff call fft_filter ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN cutoff = cutoff , & ! IN bf_tab = PARAM % surf_LF ( 1 : w , 1 : h ), & ! OUT multi_fft = . false ., & ! IN ext = 'constant' ) ! IN PARAM % surf_HF ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) - PARAM % surf_LF ( 1 : w , 1 : h ) !------------ MOMENTS LF & HF  ---------------------- call std_array ( tab = PARAM % surf_HF ( 1 : w , 1 : h ), mx = PARAM % m__HF ) call std_array ( tab = PARAM % surf_LF ( 1 : w , 1 : h ), mx = PARAM % m__LF ) !------------ PRINT LF & HF SURFS ---------------------- call init_scal ( scal = scale_img_tmp , & ! out; creates a surface type, containing ... nx = w , & !  in; ... the number of points along x ... ny = h , & !  in; ... the number of points along y ... lx = PARAM % surf_width , & !  in; ... the length (default unit : m) ... ly = PARAM % surf_height , & !  in; ... the width ... unit_z = 'm' ) !  in; ... and the unit along z. call write_surf ( nom_fic = \"out/BF.sur\" , & ! tab_s = PARAM % surf_LF ( 1 : w , 1 : h ), & ! scal = scale_img_tmp ) ! call write_surf ( nom_fic = \"out/HF.sur\" , & ! tab_s = PARAM % surf_HF ( 1 : w , 1 : h ), & ! scal = scale_img_tmp ) ! !------------ REPRODUCE LOW FREQ ---------------------- PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf_LF ( 1 : w , 1 : h ) PARAM % m_end = PARAM % m__LF PARAM % vect_h ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call sort_array2 ( tab_inout = PARAM % vect_h ( 1 : l ), n = l ) surf_tmp ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) case default continue endselect if ( reproduction_step > 0 . and . reproduction_step < 4 ) then !------------ DESIRED ACF: PARAM%imp_acf ------------- call apod ( tab_in = surf_tmp ( 1 : w , 1 : h ), & ! tab_out = tab_tmp ( 1 : w , 1 : h ), & ! long = w , & ! larg = h , & ! type_apo = 'tuckey' ) ! call std_array ( tab_tmp ( 1 : w , 1 : h ) ) call acf_wiener ( tab_in = tab_tmp ( 1 : w , 1 : h ), & ! IN tab_out = PARAM % imp_acf ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h ) ! IN endif deallocate ( tab_tmp ) deallocate ( surf_tmp ) return endsubroutine repr_img","tags":"","loc":"proc/repr_img.html"},{"title":"save_img – CREST","text":"private  subroutine save_img(tab) Note Function that save an array tab as a digital surf file. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(:,:) :: tab a surface to save as a .sur file Calls proc~~save_img~~CallsGraph proc~save_img save_img init_scal init_scal proc~save_img->init_scal write_surf write_surf proc~save_img->write_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~save_img~~CalledByGraph proc~save_img save_img proc~read_job read_job proc~read_job->proc~save_img proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine save_img ( tab ) !================================================================================================ !<@note Function that save an array *tab* as a digital surf file. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension (:,:) :: tab !! *a surface to save as a .sur file* integer ( kind = I4 ) :: w ! image width integer ( kind = I4 ) :: h ! image height integer ( kind = I4 ), dimension ( 1 : 2 ) :: shape_tab character ( len = 512 ) :: nom_surf type ( SCALE_SURF ) :: scale_img_tmp shape_tab = shape ( tab ) w = shape_tab ( 1 ) h = shape_tab ( 2 ) nom_surf = repeat ( \" \" , len ( nom_surf ) ) read ( JOB , * ) nom_surf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , trim ( nom_surf ) call init_scal ( scal = scale_img_tmp , & ! out; creates a surface type, containing ... nx = w , & !  in; ... the number of points along x ... ny = h , & !  in; ... the number of points along y ... lx = PARAM % surf_width , & !  in; ... the length (default unit : m) ... ly = PARAM % surf_height , & !  in; ... the width ... unit_z = 'm' ) !  in; ... and the unit along z. call write_surf ( nom_fic = trim ( nom_surf ), & ! tab_s = tab ( 1 : w , 1 : h ), & ! scal = scale_img_tmp ) ! return endsubroutine save_img","tags":"","loc":"proc/save_img.html"},{"title":"smooth__ – CREST","text":"private  subroutine smooth__() Note Function that applies a low-pass filter to the surface PARAM%surf Arguments None Calls proc~~smooth__~~CallsGraph proc~smooth__ smooth__ fft_filter fft_filter proc~smooth__->fft_filter std_array std_array proc~smooth__->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~smooth__~~CalledByGraph proc~smooth__ smooth__ proc~read_job read_job proc~read_job->proc~smooth__ proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine smooth__ () !================================================================================================ !<@note Function that applies a low-pass filter to the surface PARAM%surf !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp real ( kind = R8 ) :: cutoff read ( JOB , * ) cutoff ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"cutoff \" , cutoff PARAM % cutoff = cutoff w = PARAM % width h = PARAM % height ! forces FFT reinitialization FFT_DIM = 0 allocate ( tab_tmp ( 1 : w , 1 : h ) ) ! remark: if cutoff is negative, the filter is a top-hat instead of Gaussian call fft_filter ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN cutoff = PARAM % cutoff , & ! IN bf_tab = tab_tmp ( 1 : w , 1 : h ), & ! OUT multi_fft = . false ., & ! IN pad = - 1._R8 , & ! IN ext = 'constant' ) ! IN ! standardize surface call std_array ( tab = tab_tmp ( 1 : w , 1 : h ) ) PARAM % surf ( 1 : w , 1 : h ) = tab_tmp ( 1 : w , 1 : h ) deallocate ( tab_tmp ) FFT_DIM = 0 return endsubroutine smooth__","tags":"","loc":"proc/smooth__.html"},{"title":"spct_sur – CREST","text":"private  subroutine spct_sur(file_spct, apod) Note Returns the default surface spectrum Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: file_spct txt file containing the surface FFT module logical(kind=I4), intent(in), optional :: apod window applied to surface? Calls proc~~spct_sur~~CallsGraph proc~spct_sur spct_sur calc_fftw3 calc_fftw3 proc~spct_sur->calc_fftw3 get_unit get_unit proc~spct_sur->get_unit proc~apod_sur apod_sur proc~spct_sur->proc~apod_sur trans_corner2center trans_corner2center proc~spct_sur->trans_corner2center apod apod proc~apod_sur->apod std_array std_array proc~apod_sur->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~spct_sur~~CalledByGraph proc~spct_sur spct_sur proc~read_job read_job proc~read_job->proc~spct_sur proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine spct_sur ( file_spct , apod ) !================================================================================================ !<@note Returns the default surface spectrum !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len =* ), intent ( in ), optional :: file_spct !! *txt file containing the surface FFT module* logical ( kind = I4 ), intent ( in ), optional :: apod !! *window applied to surface?* integer ( kind = I4 ) :: w , h , ww , hh , i , j , np , txt_file logical ( kind = I4 ) :: apod_surf character ( len = 512 ) :: str real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp , tab_freq1 , tab_freq2 , tab_spc complex ( kind = R8 ), dimension (:,:), allocatable :: tab_cmpl , cmpl1 w = PARAM % width h = PARAM % height if ( present ( file_spct ) ) then ! use in the program -> arguments passed to subroutine str = file_spct apod_surf = apod else ! use in script -> arguments passed to batch file read ( JOB , * ) str ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , 'file_spct: ' , trim ( str ) read ( JOB , * ) apod_surf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , 'apod surf: ' , apod_surf endif allocate ( tab_tmp ( 1 : w , 1 : h ) ) allocate ( tab_freq1 ( 1 : w , 1 : h ), tab_freq2 ( 1 : w , 1 : h ) ) allocate ( tab_cmpl ( 1 : w , 1 : h ), cmpl1 ( 1 : w , 1 : h ) ) if ( apod_surf ) then tab_tmp ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) call apod_sur () endif cmpl1 ( 1 : w , 1 : h ) = cmplx ( PARAM % surf ( 1 : w , 1 : h ), 0 , kind = R8 ) call calc_fftw3 ( sens = FORWARD , & ! IN tab_in = cmpl1 ( 1 : w , 1 : h ), & ! IN tab_ou = tab_cmpl ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN tab_freq1 ( 1 : w , 1 : h ) = log10 ( abs ( tab_cmpl ( 1 : w , 1 : h ) ) + UN ) call trans_corner2center ( tab_in = tab_freq1 ( 1 : w , 1 : h ), & ! IN tab_out = tab_freq2 ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN np = 50 ! reduce image size ww = w / np hh = h / np allocate ( tab_spc ( 1 : ww , 1 : hh ) ) do i = 1 , ww do j = 1 , hh tab_spc ( i , j ) = sum ( tab_freq2 ( ( i - 1 ) * np + 1 : i * np , & ! ( j - 1 ) * np + 1 : j * np ) ) ! enddo enddo call get_unit ( txt_file ) ! Ouvrir un fichier binaire open ( newunit = txt_file , file = trim ( str ), action = \"write\" ) ! Écrire les dimensions (pour Python) write ( txt_file , * ) ww , hh ! Écrire les données en mémoire contiguë write ( txt_file , * ) tab_spc ( 1 : ww , 1 : hh ) close ( txt_file ) if ( apod_surf ) PARAM % surf ( 1 : w , 1 : h ) = tab_tmp ( 1 : w , 1 : h ) deallocate ( tab_tmp , tab_freq1 , tab_freq2 , tab_spc ) deallocate ( tab_cmpl , cmpl1 ) return endsubroutine spct_sur","tags":"","loc":"proc/spct_sur.html"},{"title":"sta_loop – CREST","text":"private  subroutine sta_loop() Starting the loop Arguments None Called by proc~~sta_loop~~CalledByGraph proc~sta_loop sta_loop proc~read_job read_job proc~read_job->proc~sta_loop proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sta_loop () !! Starting the loop implicit none read ( JOB , * ) NB_ITER ; LINE_READ = LINE_READ + 1 write ( SPY , * ) LINE_READ , I_ITER , '/' , NB_ITER I_ITER = 1 ! the account begins SAVE_LINE_READ = LINE_READ ! remember where to go when rewinding return endsubroutine sta_loop","tags":"","loc":"proc/sta_loop.html"},{"title":"sta_scri – CREST","text":"private  subroutine sta_scri() Start the script reading Arguments None Calls proc~~sta_scri~~CallsGraph proc~sta_scri sta_scri random_init random_init proc~sta_scri->random_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sta_scri~~CalledByGraph proc~sta_scri sta_scri proc~read_job read_job proc~read_job->proc~sta_scri proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sta_scri () !! Start the script reading implicit none ! Initializes the state of the pseudorandom number generator used by RANDOM_NUMBER. call random_init ( repeatable = . false ., image_distinct = . true .) return endsubroutine sta_scri","tags":"","loc":"proc/sta_scri.html"},{"title":"sta_theo – CREST","text":"private  subroutine sta_theo() Required statistical moments Arguments None Called by proc~~sta_theo~~CalledByGraph proc~sta_theo sta_theo proc~read_job read_job proc~read_job->proc~sta_theo proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sta_theo () !! Required statistical moments implicit none read ( JOB , * ) PARAM % m_end % sk , PARAM % m_end % ku ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"m_end \" , PARAM % m_end % sk , PARAM % m_end % ku return endsubroutine sta_theo","tags":"","loc":"proc/sta_theo.html"},{"title":"stat_sur – CREST","text":"private  subroutine stat_sur() Note Define surface statistical moments as reference Arguments None Calls proc~~stat_sur~~CallsGraph proc~stat_sur stat_sur proc~acf_wiener acf_wiener proc~stat_sur->proc~acf_wiener proc~apod_sur apod_sur proc~stat_sur->proc~apod_sur proc~surface_analysis surface_analysis proc~stat_sur->proc~surface_analysis sort_array2 sort_array2 proc~stat_sur->sort_array2 std_array std_array proc~stat_sur->std_array calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center proc~apod_sur->std_array apod apod proc~apod_sur->apod proc~surface_analysis->proc~acf_wiener abbott_param abbott_param proc~surface_analysis->abbott_param calc_median calc_median proc~surface_analysis->calc_median calc_moments calc_moments proc~surface_analysis->calc_moments calcul_asfc_hermite calcul_asfc_hermite proc~surface_analysis->calcul_asfc_hermite calcul_normales calcul_normales proc~surface_analysis->calcul_normales ellipse_acf ellipse_acf proc~surface_analysis->ellipse_acf fft_filter fft_filter proc~surface_analysis->fft_filter get_unit get_unit proc~surface_analysis->get_unit indice_fractal indice_fractal proc~surface_analysis->indice_fractal multiple_anisotropy multiple_anisotropy proc~surface_analysis->multiple_anisotropy peaks_and_pits_curvatures peaks_and_pits_curvatures proc~surface_analysis->peaks_and_pits_curvatures surf_area surf_area proc~surface_analysis->surf_area topology topology proc~surface_analysis->topology Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~stat_sur~~CalledByGraph proc~stat_sur stat_sur proc~read_job read_job proc~read_job->proc~stat_sur proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine stat_sur () !================================================================================================ !<@note Define surface statistical moments as reference !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l logical ( kind = I4 ) :: apodize read ( JOB , * ) apodize ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , 'apod? ' , apodize w = PARAM % width h = PARAM % height l = PARAM % npts PARAM % surf_copy ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) if ( apodize ) then ! apodize surface for the acf call apod_sur () call acf_wiener ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! IN tab_out = PARAM % acf_surf ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h ) ! IN ! retrieve original surface PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf_copy ( 1 : w , 1 : h ) endif ! do not append to result file, make new one call surface_analysis ( app = 0 ) ! calculate statistical moments that become prescribed call std_array ( tab = PARAM % surf ( 1 : w , 1 : h ), mx = PARAM % m_end ) ! determine final heights PARAM % vect_h ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) ! determine height order call sort_array2 ( tab_inout = PARAM % vect_h ( 1 : l ), n = l ) ! prescribe moments PARAM % m_ini = PARAM % m_end ! prescribe acf PARAM % imp_acf ( 1 : w , 1 : h ) = PARAM % acf_surf ( 1 : w , 1 : h ) return endsubroutine stat_sur","tags":"","loc":"proc/stat_sur.html"},{"title":"sub_surf – CREST","text":"private  subroutine sub_surf() Note Function that returns the best subsurface from the final surface. We are here because a non periodic resulting surface is required. To do that, a wider\n periodic surface is created, and it matches the required moments and acf. However, sub-sampling the surface into a smaller surface that matches the required size\n will result in degraded moments and acf. Hence, several locations are tested to find the\n best subsurface. Note that the right moments can always be obtained by substitution, respecting the order of heights.\n However, the acf will be slightly impacted. Arguments None Calls proc~~sub_surf~~CallsGraph proc~sub_surf sub_surf calc_moments calc_moments proc~sub_surf->calc_moments end_fftw3 end_fftw3 proc~sub_surf->end_fftw3 fftw_plan_with_nthreads fftw_plan_with_nthreads proc~sub_surf->fftw_plan_with_nthreads init_order init_order proc~sub_surf->init_order omp_get_max_threads omp_get_max_threads proc~sub_surf->omp_get_max_threads proc~acf_wiener acf_wiener proc~sub_surf->proc~acf_wiener proc~build_heights build_heights proc~sub_surf->proc~build_heights proc~calc_imp_acf calc_imp_acf proc~sub_surf->proc~calc_imp_acf proc~calc_res_acf calc_res_acf proc~sub_surf->proc~calc_res_acf progress_bar_terminal progress_bar_terminal proc~sub_surf->progress_bar_terminal sort_array2 sort_array2 proc~sub_surf->sort_array2 tab_end_fftw3_real tab_end_fftw3_real proc~sub_surf->tab_end_fftw3_real tab_init_fftw3_real tab_init_fftw3_real proc~sub_surf->tab_init_fftw3_real calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center proc~build_heights->sort_array2 proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d std_array std_array proc~build_heights->std_array proc~apod2 apod2 proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo init pikaia_class%init proc~pikaia_skku_solver->init solve pikaia_class%solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sub_surf~~CalledByGraph proc~sub_surf sub_surf proc~read_job read_job proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sub_surf () !================================================================================================ !<@note Function that returns the best subsurface from the final surface. !< !< We are here because a non periodic resulting surface is required. To do that, a wider !< periodic surface is created, and it matches the required moments and acf. !< !< However, sub-sampling the surface into a smaller surface that matches the required size !< will result in degraded moments and acf. Hence, several locations are tested to find the !< best subsurface. !< !< Note that the right moments can always be obtained by substitution, respecting the order of heights. !< However, the acf will be slightly impacted. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: i , w , h , l , we , he , dw , dh , ndw , ndh , idw , jdh , ib , ie , jb , je , best_idw , best_jdh integer ( kind = I4 ) :: n_seek , inc_dw , inc_dh , nn_res , res_ratio real ( kind = R8 ) :: best_acf , res_acf , size_ratio character ( len = 100 ) :: text type ( MOMENT_STAT ) :: m_res integer ( kind = I4 ), dimension ( 1 : 2 ) :: best_ind integer ( kind = I4 ), allocatable , dimension (:) :: order_tmp real ( kind = R8 ), allocatable , dimension (:,:) :: sav_surf , surf_tmp , acf_tmp , tab_res_acf real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp read ( JOB , * ) n_seek ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"n_seek  \" , n_seek ! n_seek is the number of subsurfaces explored if ( PARAM % periodic ) return ! reset the FFTW configuration because from now on, the acf will be calculated on smaller surfaces call end_fftw3 () ! extended surface size we = PARAM % width he = PARAM % height allocate ( sav_surf ( 1 : we , 1 : he ) ) ! save the extended surface sav_surf ( 1 : we , 1 : he ) = PARAM % surf ( 1 : we , 1 : he ) ! reset previous arrays deallocate ( PARAM % surf ) deallocate ( PARAM % imp_acf ) deallocate ( PARAM % acf_surf ) call fftw_plan_with_nthreads ( nthreads = 1 ) NB_THREADS_FFT = omp_get_max_threads () ! the new image size is the one of the subsurface, because it is the size defined by the user w = PARAM % sub_width h = PARAM % sub_height l = PARAM % sub_npts call tab_init_fftw3_real ( long = w , larg = h , plan_flag = FFTW_MEASURE ) PARAM % width = w PARAM % height = h PARAM % npts = l allocate ( PARAM % surf ( 1 : w , 1 : h ) ) allocate ( PARAM % acf_surf ( 1 : w , 1 : h ) ) ! build a smaller set of heights that match the required moments call build_heights ( vec_out = PARAM % vect_h ( 1 : l ), & ! use_fct_expo = ( PARAM % m_end % ku < 1.34 * PARAM % m_end % sk ** 2 + 1.8 ), & ! stats_in = PARAM % m_end , & ! lg = l ) ! allocate ( PARAM % imp_acf ( 1 : w , 1 : h ) ) ! recalculate the theoretical acf, for the new size surface call calc_imp_acf ( long = w , & ! IN larg = h , & ! IN apod = PARAM % apod , & ! IN tau1 = PARAM % curr_surf % cl1 , & ! IN tau2 = PARAM % curr_surf % cl2 , & ! IN alpha = log ( PARAM % curr_surf % cut ), & ! IN ang = PARAM % curr_surf % ang * PI_R8 / 180 , & ! IN tab_acf = PARAM % imp_acf ( 1 : w , 1 : h )) ! OUT ! difference between old and new size: hence, there will be dw*dh possible locations ! for the subsurface dw = we - w dh = he - h ! initialize the best acf result (mean absolute difference) and subsurface locations best_acf = 1.e6_R8 best_idw = 0 best_jdh = 0 size_ratio = dw / dh ! Number of locations along x and y. It respects the total number to be explored, as set ! by the user and the size ratio of the surface ndw = nint ( sqrt ( n_seek / size_ratio ) ) ndh = nint ( real ( n_seek , kind = R8 ) / ndw ) ! ndw and ndh are modified to be mumtiples of the number of threads, but the product ! should not be too far from n_seek if ( size_ratio > 1. ) then ndw = NB_THREADS_FFT * ( int ( ndw / NB_THREADS_FFT ) + 1 ) ndh = NB_THREADS_FFT * ( int ( ndh / NB_THREADS_FFT ) ) else ndw = NB_THREADS_FFT * ( int ( ndw / NB_THREADS_FFT ) ) ndh = NB_THREADS_FFT * ( int ( ndh / NB_THREADS_FFT ) + 1 ) endif ! don't exceed the maximums ndw = min ( ndw , dw ) ndh = min ( ndh , dh ) ! increments for looping inc_dw = dw / ndw inc_dh = dh / ndh ! result storage allocate ( tab_res_acf ( 1 : ndw , 1 : ndh ) ) tab_res_acf ( 1 : ndw , 1 : ndh ) = - 1 allocate ( surf_tmp ( 1 : w , 1 : h ) ) allocate ( acf_tmp ( 1 : w , 1 : h ) ) allocate ( order_tmp ( 1 : l ) ) allocate ( tab_tmp ( 1 : l ) ) call progress_bar_terminal ( val = 0 , max_val = ndw * ndh , init = . true .) !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_THREADS_FFT) !$OMP DO SCHEDULE (STATIC, ndw/NB_THREADS_FFT) PRIVATE(ib, ie, jb, je, jdh, surf_tmp, tab_tmp, order_tmp, acf_tmp, i, m_res, res_acf, nn_res, res_ratio, text) do idw = 1 , ndw ib = idw * inc_dw ie = ib + w - 1 do jdh = 1 , ndh jb = jdh * inc_dh je = jb + h - 1 surf_tmp ( 1 : w , 1 : h ) = sav_surf ( ib : ie , jb : je ) !....................................................................................... tab_tmp ( 1 : l ) = reshape ( surf_tmp ( 1 : w , 1 : h ), [ l ] ) ! store the subsurface height order call init_order ( order = order_tmp ( 1 : l ), & ! OUT n = l ) ! IN call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! INOUT tab0 = order_tmp ( 1 : l ), & ! INOUT n = l ) ! IN ! replace old heights with new ones that matches required moments do i = 1 , l tab_tmp ( order_tmp ( i ) ) = PARAM % vect_h ( i ) enddo surf_tmp ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call calc_moments ( tab = tab_tmp ( 1 : l ), & ! IN mx = m_res , & ! OUT nb_mom = 4 ) ! IN surf_tmp ( 1 : w , 1 : h ) = ( surf_tmp ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si !....................................................................................... ! calculate the acf call acf_wiener ( tab_in = surf_tmp ( 1 : w , 1 : h ), & ! IN tab_out = acf_tmp ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h , & ! IN multi_fft = . true . ) ! IN ! calculate the result (mean absolute difference between theoretical acf and calculated acf) call calc_res_acf ( acf_surf = acf_tmp ( 1 : w , 1 : h ), & ! IN imp_acf = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN acf__z = PARAM % curr_surf % cut , & ! IN crit_acf = res_acf , & ! OUT w = w , & ! IN h = h ) ! IN tab_res_acf ( idw , jdh ) = res_acf ! update progressbar !$OMP CRITICAL nn_res = count ( tab_res_acf > 0 ) call progress_bar_terminal ( val = nn_res , max_val = ndw * ndh , init = . false .) !$OMP END CRITICAL enddo enddo !$OMP END DO !$OMP END PARALLEL ! find the best subsurface best_ind ( 1 : 2 ) = minloc ( tab_res_acf ) idw = best_ind ( 1 ) jdh = best_ind ( 2 ) ib = idw * ( dw / ndw ) ie = ib + w - 1 jb = jdh * ( dh / ndh ) je = jb + h - 1 PARAM % surf ( 1 : w , 1 : h ) = sav_surf ( ib : ie , jb : je ) ! redo calculations on the best subsurface !....................................................................................... tab_tmp ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call init_order ( order = PARAM % order ( 1 : l ), & ! n = l ) ! call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! tab0 = PARAM % order ( 1 : l ), & ! n = l ) ! do i = 1 , l tab_tmp ( PARAM % order ( i ) ) = PARAM % vect_h ( i ) enddo PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call calc_moments ( tab = tab_tmp ( 1 : l ), & ! mx = m_res , & ! nb_mom = 4 ) ! PARAM % surf ( 1 : w , 1 : h ) = ( PARAM % surf ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si !....................................................................................... call tab_end_fftw3_real () deallocate ( sav_surf ) deallocate ( tab_tmp ) deallocate ( surf_tmp ) deallocate ( acf_tmp ) deallocate ( order_tmp ) deallocate ( tab_res_acf ) return endsubroutine sub_surf","tags":"","loc":"proc/sub_surf.html"},{"title":"surface_analysis – CREST","text":"public  subroutine surface_analysis(app) Note The function analyses determinates ISO 25178 parameters of the current surface. The analysis is always performed on the whole surface.\nThe results are written in the file which unit is STA . Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in), optional :: app append results to csv Calls proc~~surface_analysis~~CallsGraph proc~surface_analysis surface_analysis abbott_param abbott_param proc~surface_analysis->abbott_param calc_median calc_median proc~surface_analysis->calc_median calc_moments calc_moments proc~surface_analysis->calc_moments calcul_asfc_hermite calcul_asfc_hermite proc~surface_analysis->calcul_asfc_hermite calcul_normales calcul_normales proc~surface_analysis->calcul_normales ellipse_acf ellipse_acf proc~surface_analysis->ellipse_acf fft_filter fft_filter proc~surface_analysis->fft_filter get_unit get_unit proc~surface_analysis->get_unit indice_fractal indice_fractal proc~surface_analysis->indice_fractal multiple_anisotropy multiple_anisotropy proc~surface_analysis->multiple_anisotropy peaks_and_pits_curvatures peaks_and_pits_curvatures proc~surface_analysis->peaks_and_pits_curvatures proc~acf_wiener acf_wiener proc~surface_analysis->proc~acf_wiener surf_area surf_area proc~surface_analysis->surf_area topology topology proc~surface_analysis->topology calc_fftw3_real_bwd calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~acf_wiener->calc_fftw3_real_fwd tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd trans_corner2center trans_corner2center proc~acf_wiener->trans_corner2center Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~surface_analysis~~CalledByGraph proc~surface_analysis surface_analysis proc~read_job read_job proc~read_job->proc~surface_analysis proc~repr_img repr_img proc~read_job->proc~repr_img proc~stat_sur stat_sur proc~read_job->proc~stat_sur proc~repr_img->proc~surface_analysis proc~stat_sur->proc~surface_analysis proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine surface_analysis ( app ) !================================================================================================ !< @note !< !< The function *analyses* determinates ISO 25178 parameters of the current surface. !< !< The analysis is always performed on the whole surface. !< The results are written in the file which unit is *STA*. !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ), optional :: app !! *append results to csv* integer ( kind = I4 ) :: i , ib , ie , nn , pp , append real ( kind = R8 ) :: ra_t , md real ( kind = R8 ) :: dx , dy , si , fft_cutoff type ( MOMENT_STAT ) :: mx real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp real ( kind = R8 ), dimension (:), allocatable :: vec_heights , tab_results real ( kind = R8 ), dimension ( 1 : 20 ) :: ana_res character ( len = :), allocatable :: result_str , head character ( len = 18 ) :: str if ( . not . present ( app ) ) then read ( JOB , * ) append ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"append \" , append else append = app endif ! result file call get_unit ( STA ) if ( append == 1 ) then open ( unit = STA , file = \"out/res.csv\" , status = 'unknown' , position = 'append' ) else open ( unit = STA , file = \"out/res.csv\" , status = 'unknown' ) endif !--------------------------------------------------------- ana_res = 0 nn = PARAM % width pp = PARAM % height dx = PARAM % surf_dx dy = PARAM % surf_dy si = 1 allocate ( tab_results ( 1 : 100 ) ) allocate ( vec_heights ( 1 : nn * pp ) ) vec_heights ( 1 : nn * pp ) = reshape ( PARAM % surf ( 1 : nn , 1 : pp ), [ nn * pp ] ) !----------------------------------- head = 'smrk1,smrk2,spk,svk,Sk,pente,residus,coeffa_tan,coeffb_tan,' call abbott_param ( tab = vec_heights ( 1 : nn * pp ), & ! lg = nn * pp , & ! nom = \"out/abbott_res.txt\" , & ! curves = [. false ., . false ., . false .], & ! results = ana_res ( 1 : 11 ), & ! omp = . true . ) ! ib = 1 ie = ib + 9 - 1 tab_results ( ib : ie ) = [ ana_res ( 1 ), & ! smrk1, iso 25178 ana_res ( 2 ), & ! smrk2, iso 25178 ana_res ( 3 ), & ! spk  , iso 25178 ana_res ( 4 ), & ! svk  , iso 25178 ! 5 et 6 pour off1 et off2 ana_res ( 7 ), & ! sk   , iso 25178 ana_res ( 8 ), & ! core slope ana_res ( 9 ), & ! adjustment factor (tangent fit) ana_res ( 10 ), & ! coeffa_tan        (tangent fit) ana_res ( 11 ) ] ! coeffb_tan        (tangent fit) deallocate ( vec_heights ) !----------------------------------- head = head // 'Snb1,Smc1,Sk1,Snb2,Smc2,Sk2,Sdq,Scq,Sh3z,Sv3z,' call topology ( tab = PARAM % surf ( 1 : nn , 1 : pp ), & ! long = nn , & ! larg = pp , & ! res = ana_res ( 1 : 6 ) ) ! fft_cutoff = dx / 5.e-6 ! 5.e-6 = 5 µm allocate ( tab_tmp ( 1 : nn , 1 : pp ) ) call fft_filter ( tab = PARAM % surf ( 1 : nn , 1 : pp ), & ! in long = nn , & ! in larg = pp , & ! in cutoff = fft_cutoff , & ! in bf_tab = tab_tmp ( 1 : nn , 1 : pp ), & ! out multi_fft = . false .) ! in call peaks_and_pits_curvatures ( heights = tab_tmp ( 1 : nn , 1 : pp ), & ! nx = nn , & ! ny = pp , & ! dx = dx , & ! dy = dy , & ! S_param_grad = ana_res ( 07 ), & ! S_param_curv = ana_res ( 08 ), & ! peak_curv = ana_res ( 09 ), & ! pits_curv = ana_res ( 10 ) ) ! deallocate ( tab_tmp ) ib = ie + 1 ie = ib + 10 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 10 ) !----------------------------------- head = head // 'Sv,Sp,Smd,Sa,Sm,Sq,Ssk,Sku,Sks,' call calc_moments ( tab = reshape ( PARAM % surf ( 1 : nn , 1 : pp ), [ nn * pp ] ), & ! mx = mx , & ! nb_mom = 4 ) ! call calc_median ( tab = reshape ( PARAM % surf ( 1 : nn , 1 : pp ), [ nn * pp ] ), & ! md = md ) ! ra_t = sum ( abs ( PARAM % surf ( 1 : nn , 1 : pp ) - mx % mu ) / ( nn * pp ) ) ana_res ( 1 : 8 ) = [ minval ( PARAM % surf ( 1 : nn , 1 : pp ) ) - mx % mu , & ! maxval ( PARAM % surf ( 1 : nn , 1 : pp ) ) - mx % mu , & ! md - mx % mu , & ! ra_t , mx % mu , mx % si , mx % sk , mx % ku ] ! ib = ie + 1 ie = ib + 8 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 8 ) ib = ie + 1 ie = ib tab_results ( ib ) = ana_res ( 8 ) / ( ana_res ( 7 ) ** 2 + 1 ) ! kind of kurtosis excess !----------------------------------- head = head // 'Smbd,ordorig,R2adj,' call indice_fractal ( tab_in = PARAM % surf ( 1 : nn , 1 : pp ), & ! long = nn , & ! larg = pp , & ! indf = ana_res ( 1 : 3 ) ) ! ib = ie + 1 ie = ib + 3 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 3 ) !----------------------------------- head = head // 'Sh,Sdr,' call calcul_normales ( tab_in = PARAM % surf ( 1 : nn , 1 : pp ), & ! long = nn , & ! larg = pp , & ! scale_xyz = [ dx , dy , si ], & ! cone_angle = 5._R8 , & ! hori = ana_res ( 1 ) ) ! call surf_area ( tab_in = PARAM % surf ( 1 : nn , 1 : pp ), & ! long = nn , & ! larg = pp , & ! scale_xyz = [ dx , dy , si ], & ! aire = ana_res ( 2 ) ) ! ib = ie + 1 ie = ib + 2 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 2 ) !----------------------------------- head = head // 'Sasfc,R2adj,' call calcul_asfc_hermite ( tab_in = PARAM % surf ( 1 : nn , 1 : pp ), & ! scal = SCALE_IMG , & ! asfc_res = ana_res ( 1 : 2 ), & ! omp = . true . ) ! ib = ie + 1 ie = ib + 2 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 2 ) !----------------------------------- head = head // 'Rmax,Sal,Stri,Std,d.sl,b.sl,r.sl,r.cv,bmp,smp,rmp,bml,sml,rml,bms,sms,rms' if ( sum ( PARAM % acf_surf ( 1 : nn , 1 : pp )) == 0 ) then call acf_wiener ( tab_in = PARAM % surf ( 1 : nn , 1 : pp ), & ! IN tab_out = PARAM % acf_surf ( 1 : nn , 1 : pp ), & ! OUT w = nn , & ! IN h = pp ) ! IN endif call ellipse_acf ( tabin = PARAM % acf_surf ( 1 : nn , 1 : pp ), & ! IN long = nn , & ! IN larg = pp , & ! IN p_acv = ana_res ( 1 : 8 ), & ! OUT -> correlation lengths cut = PARAM % curr_surf % cut , & ! IN  -> z cut plane scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN  -> lags along x and y omp = . true . ) ! IN  -> use multithread? PARAM % curr_surf % cl1 = ana_res ( 1 ) PARAM % curr_surf % cl2 = ana_res ( 2 ) PARAM % curr_surf % ang = ana_res ( 4 ) call multiple_anisotropy ( tabin = PARAM % surf ( 1 : nn , 1 : pp ), & ! IN long = nn , & ! IN larg = pp , & ! IN scale_xy = [ dx , dy ], & ! IN multi_fft = . false ., & ! IN vec_ani = ana_res ( 9 : 17 ) ) ! OUT ib = ie + 1 ie = ib + 17 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 17 ) if ( append /= 1 ) write ( STA , '(a)' ) trim ( head ) write ( str , '(E18.6)' ) tab_results ( 1 ) result_str = str do i = 2 , ie write ( str , '(E18.6)' ) tab_results ( i ) result_str = result_str // ',' // str enddo write ( STA , * ) result_str deallocate ( head ) deallocate ( result_str ) deallocate ( tab_results ) return endsubroutine surface_analysis","tags":"","loc":"proc/surface_analysis.html"},{"title":"add_tang – CREST","text":"private  function add_tang(n, deb, fin, alp, bet, mu, si) Note Function that adds to the series mean the border integrals as explained in the docs Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku integer(kind=I4), intent(in) :: deb first integration point integer(kind=I4), intent(in) :: fin last integration point real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) Calls proc~~add_tang~~CallsGraph proc~add_tang add_tang proc~tang tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_tang~~CalledByGraph proc~add_tang add_tang proc~calculs_skku_tan calculs_skku_tan proc~calculs_skku_tan->proc~add_tang proc~fitness_skku_anal fitness_skku_anal proc~fitness_skku_anal->proc~calculs_skku_tan proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/add_tang.html"},{"title":"fitness_skku_anal – CREST","text":"private  function fitness_skku_anal(n, x) Note Generic cost function: difference between the imposed statistical moments and those\n obtained. The optimization problem must be turned into a maximization problem (as often\n in the optimization routines). The closer cost to 100 the better series. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n number of unknowns real(kind=R8), intent(in), dimension(1:n) :: x vector of unknowns Return Value real(kind=r8) Calls proc~~fitness_skku_anal~~CallsGraph proc~fitness_skku_anal fitness_skku_anal proc~calculs_skku_exp3 calculs_skku_exp3 proc~fitness_skku_anal->proc~calculs_skku_exp3 proc~calculs_skku_tan calculs_skku_tan proc~fitness_skku_anal->proc~calculs_skku_tan proc~add_tang add_tang proc~calculs_skku_tan->proc~add_tang proc~tang tang proc~calculs_skku_tan->proc~tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fitness_skku_anal~~CalledByGraph proc~fitness_skku_anal fitness_skku_anal proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/fitness_skku_anal.html"},{"title":"tang – CREST","text":"private  function tang(xi, n, alp, bet, mu, si) Note Profile function based on the tangent function Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi abscissa integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) Called by proc~~tang~~CalledByGraph proc~tang tang proc~add_tang add_tang proc~add_tang->proc~tang proc~calculs_skku_tan calculs_skku_tan proc~calculs_skku_tan->proc~tang proc~calculs_skku_tan->proc~add_tang proc~fitness_skku_anal fitness_skku_anal proc~fitness_skku_anal->proc~calculs_skku_tan proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/tang.html"},{"title":"build_heights – CREST","text":"public  subroutine build_heights(vec_out, use_fct_expo, stats_in, lg) Note Function that returns a set of heights that matches desired statistical moments. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:lg) :: vec_out height vector logical(kind=I4), intent(in) :: use_fct_expo should exponential function rather than tangent function be used? type( moment_stat ), intent(in) :: stats_in input statistical moments integer(kind=I4), intent(in) :: lg length of the height vector Calls proc~~build_heights~~CallsGraph proc~build_heights build_heights proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d sort_array2 sort_array2 proc~build_heights->sort_array2 std_array std_array proc~build_heights->std_array init pikaia_class%init proc~pikaia_skku_solver->init solve pikaia_class%solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_heights~~CalledByGraph proc~build_heights build_heights proc~add_nois add_nois proc~add_nois->proc~build_heights proc~calc_z_f calc_z_f proc~calc_z_f->proc~build_heights proc~calc_z_i calc_z_i proc~calc_z_i->proc~build_heights proc~sub_surf sub_surf proc~sub_surf->proc~build_heights proc~read_job read_job proc~read_job->proc~add_nois proc~read_job->proc~calc_z_f proc~read_job->proc~calc_z_i proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine build_heights ( vec_out , use_fct_expo , stats_in , lg ) !================================================================================================ !<@note Function that returns a set of heights that matches desired statistical moments. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: lg !! *length of the height vector* type ( MOMENT_STAT ), intent ( in ) :: stats_in !! *input statistical moments* logical ( kind = I4 ), intent ( in ) :: use_fct_expo !! *should exponential function rather than tangent function be used?* real ( kind = R8 ), intent ( out ), dimension ( 1 : lg ) :: vec_out !! *height vector* integer ( kind = I4 ) :: istat real ( kind = R8 ) :: cost_val type ( MOMENT_STAT ) :: m_tmp real ( kind = R8 ), dimension (:), allocatable :: xlower real ( kind = R8 ), dimension (:), allocatable :: xupper real ( kind = R8 ), dimension (:), allocatable :: xresul ! put input parameters in global variables, so that they can be used in the function \"fitness_skku_anal\" PARAM % m_inp % sk = stats_in % sk PARAM % m_inp % ku = stats_in % ku ! if the Pearson limit is to close to the point (Ssk, Sku), an exponential function is used if ( use_fct_expo ) then PARAM % func_gen = FCT_EXPO PARAM % nparam = 3 else PARAM % func_gen = FCT_TANG PARAM % nparam = 2 endif ! Genetic algorithm is used to determinate the tangent parameters \\alpha and \\beta so that, the set of lg heights ! will match the statistical moments. !.............................................................................. ! initialization allocate ( xresul ( 1 : PARAM % nparam ) ) ; xresul = 0.0_R8 allocate ( xlower ( 1 : PARAM % nparam ) ) ; xlower = 1.e-6_R8 allocate ( xupper ( 1 : PARAM % nparam ) ) ; xupper = 1.0_R8 call pikaia_skku_solver ( pik_class = PARAM % pik_class , & ! INOUT step = 'init' , & ! IN xl = xlower ( 1 : PARAM % nparam ), & ! IN xu = xupper ( 1 : PARAM % nparam ), & ! IN xx = xresul ( 1 : PARAM % nparam ), & ! IN nparam = PARAM % nparam , & ! IN cost = cost_func_skku , & ! IN istat = istat , & ! OUT f = cost_val ) ! IN call pikaia_skku_solver ( pik_class = PARAM % pik_class , & ! INOUT step = 'solv' , & ! IN xl = xlower ( 1 : PARAM % nparam ), & ! IN xu = xupper ( 1 : PARAM % nparam ), & ! IN xx = xresul ( 1 : PARAM % nparam ), & ! OUT nparam = PARAM % nparam , & ! IN cost = cost_func_skku , & ! IN istat = istat , & ! OUT f = cost_val ) ! IN !.............................................................................. ! the parameters habe been found, let generate lg heights !.............................................................................. call profil_theo_trie_1D ( tab = vec_out ( 1 : lg ), & ! OUT lg = lg , & ! IN x = xresul ( 1 : PARAM % nparam ), & ! IN mx = m_tmp ) ! OUT !.............................................................................. ! PARAM%func_gen value is retrieved !PARAM%func_gen = fct_sav deallocate ( xresul ) deallocate ( xlower ) deallocate ( xupper ) call std_array ( tab = vec_out ( 1 : lg ), mx = m_tmp ) ! the parameter found can lead to inverted heights if ( stats_in % sk * m_tmp % sk < 0. ) then vec_out ( 1 : lg ) = - vec_out ( 1 : lg ) endif ! heights are sorted call sort_array2 ( tab_inout = vec_out ( 1 : lg ), n = lg ) return endsubroutine build_heights","tags":"","loc":"proc/build_heights.html"},{"title":"calculs_skku_exp3 – CREST","text":"private  subroutine calculs_skku_exp3(bounds, lg, ssk, sku) Note Function to calculate the skewness and kurtosis of an exponential series. The principle is the same as calculs_skku_tan , however it fits better some particular\n series quite binary (roughly two heights). Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:3) :: bounds interval limits [-(1/bounds(1)-1), +(1/bounds(2)-1)] integer(kind=I4), intent(in) :: lg vec size real(kind=R8), intent(out) :: ssk theoretical Ssk real(kind=R8), intent(out) :: sku theoretical Sku Called by proc~~calculs_skku_exp3~~CalledByGraph proc~calculs_skku_exp3 calculs_skku_exp3 proc~fitness_skku_anal fitness_skku_anal proc~fitness_skku_anal->proc~calculs_skku_exp3 proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calculs_skku_exp3 ( bounds , lg , ssk , sku ) !================================================================================================ !<@note Function to calculate the skewness and kurtosis of an **exponential** series.<br/> !< The principle is the same as [[calculs_skku_tan]], however it fits better some particular !< series quite binary (roughly two heights). !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: bounds !! *interval limits* [-(1/bounds(1)-1), +(1/bounds(2)-1)] integer ( kind = I4 ), intent ( in ) :: lg !! *vec size* real ( kind = R8 ), intent ( out ) :: ssk !! *theoretical Ssk* real ( kind = R8 ), intent ( out ) :: sku !! *theoretical Sku* real ( kind = R8 ) :: xa , xb , kk , kk2 , kk3 , kk4 , mu , si , sk , ku , a , b , c real ( kind = R8 ) :: mu2 , mu3 , mu4 , si3 , si4 real ( kind = R8 ) :: h , hh , b1 , b2 , alp , bet , gam real ( kind = R8 ) :: exp1b , exp1a , exp2b , exp2a , exp3b , exp3a , exp4b , exp4a , tmp1a , tmp1b , tmp2a , tmp2b , tmp3a , tmp3b , tmp4a , tmp4b real ( kind = R8 ) :: tmp1a2 , tmp1b2 , tmp1a3 , tmp1b3 , tmp1a4 , tmp1b4 , tmp1a5 , tmp1b5 , tmp1a6 , tmp1b6 real ( kind = R8 ) :: tmp1a7 , tmp1b7 , tmp1a8 , tmp1b8 , tmp1a9 , tmp1b9 , tmp1a10 , tmp1b10 , tmp1a13 , tmp1b13 integer ( kind = I4 ) :: deb , fin deb = 1 fin = lg a = bounds ( 1 ) b = bounds ( 2 ) c = bounds ( 3 ) hh = ( - 2._R8 + UN / a + UN / b ) / ( lg - 1 ) h = hh xa = a xb = b b1 = - ( UN - a ) / a b2 = + ( UN - b ) / b alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) kk = c / ( b2 - b1 ) ** 3 gam = kk kk2 = kk ** 2 kk3 = kk ** 3 kk4 = kk ** 4 tmp1a = - 1 * ( UN - UN / xa ) ; tmp1a = min ( + 0.9 * HIG_E8 , tmp1a ) ; tmp1a = max ( - 0.9 * HIG_E8 , tmp1a ) tmp1b = - 1 * ( UN - UN / xb ) ; tmp1b = min ( + 0.9 * HIG_E8 , tmp1b ) ; tmp1b = max ( - 0.9 * HIG_E8 , tmp1b ) tmp2a = - 2 * ( UN - UN / xa ) ; tmp2a = min ( + 0.9 * HIG_E8 , tmp2a ) ; tmp2a = max ( - 0.9 * HIG_E8 , tmp2a ) tmp2b = - 2 * ( UN - UN / xb ) ; tmp2b = min ( + 0.9 * HIG_E8 , tmp2b ) ; tmp2b = max ( - 0.9 * HIG_E8 , tmp2b ) tmp3a = - 3 * ( UN - UN / xa ) ; tmp3a = min ( + 0.9 * HIG_E8 , tmp3a ) ; tmp3a = max ( - 0.9 * HIG_E8 , tmp3a ) tmp3b = - 3 * ( UN - UN / xb ) ; tmp3b = min ( + 0.9 * HIG_E8 , tmp3b ) ; tmp3b = max ( - 0.9 * HIG_E8 , tmp3b ) tmp4a = - 4 * ( UN - UN / xa ) ; tmp4a = min ( + 0.9 * HIG_E8 , tmp4a ) ; tmp4a = max ( - 0.9 * HIG_E8 , tmp4a ) tmp4b = - 4 * ( UN - UN / xb ) ; tmp4b = min ( + 0.9 * HIG_E8 , tmp4b ) ; tmp4b = max ( - 0.9 * HIG_E8 , tmp4b ) tmp1a2 = tmp1a ** 2 ; tmp1b2 = tmp1b ** 2 tmp1a3 = tmp1a ** 3 ; tmp1b3 = tmp1b ** 3 tmp1a4 = tmp1a ** 4 ; tmp1b4 = tmp1b ** 4 tmp1a5 = tmp1a ** 5 ; tmp1b5 = tmp1b ** 5 tmp1a6 = tmp1a ** 6 ; tmp1b6 = tmp1b ** 6 tmp1a7 = tmp1a ** 7 ; tmp1b7 = tmp1b ** 7 tmp1a8 = tmp1a ** 8 ; tmp1b8 = tmp1b ** 8 tmp1a9 = tmp1a ** 9 ; tmp1b9 = tmp1b ** 9 tmp1a10 = tmp1a ** 10 ; tmp1b10 = tmp1b ** 10 tmp1a13 = tmp1a ** 13 ; tmp1b13 = tmp1b ** 13 exp1a = exp ( - tmp1a ) ! exp( 1 * (1 - 1/xa) ) exp1b = exp ( - tmp1b ) ! exp( 1 * (1 - 1/xb) ) exp2a = exp ( - tmp2a ) ! exp( 2 * (1 - 1/xa) ) exp2b = exp ( - tmp2b ) ! exp( 2 * (1 - 1/xb) ) exp3a = exp ( - tmp3a ) ! exp( 3 * (1 - 1/xa) ) exp3b = exp ( - tmp3b ) ! exp( 3 * (1 - 1/xb) ) exp4a = exp ( - tmp4a ) ! exp( 4 * (1 - 1/xa) ) exp4b = exp ( - tmp4b ) ! exp( 4 * (1 - 1/xb) ) mu = - exp1a + exp1b - ( kk * tmp1a4 ) / 4.0D0 + ( kk * tmp1b4 ) / 4.0D0 - 1.0D0 / xa + 1.0D0 / xb mu = ( UN / h ) * mu + add_expo3 ( 1 , deb , fin , alp , bet , gam , mu = 0._R8 , si = 1._R8 ) mu = mu / lg mu2 = mu ** 2 mu3 = mu ** 3 mu4 = mu ** 4 !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . si = kk * ( - 2.4D+1 ) - exp2a / 2.0D0 - exp2b / 2.0D0 + exp1a * ( kk * 1.2D+1 + mu * 2.0D0 + 2.0D0 ) + exp1b * ( kk * 1.2D+1 - mu * 2.0D0 + 2.0D0 ) + tmp1a * ( mu * 2.0D0 + mu2 + 1.0D0 ) + tmp1b * ( mu * ( - 2.0D0 ) + mu2 + 1.0D0 ) + ( kk2 * tmp1a7 ) / 7.0D0 + ( kk2 * tmp1b7 ) / 7.0D0 + ( kk * tmp1a4 * ( mu + 1.0D0 )) / 2.0D0 - ( kk * tmp1b4 * ( mu - 1.0D0 )) / 2.0D0 + kk * exp1a * tmp1a2 * 6.0D0 + kk * exp1a * tmp1a3 * 2.0D0 + kk * exp1b * tmp1b2 * 6.0D0 + kk * exp1b * tmp1b3 * 2.0D0 + kk * exp1a * tmp1a * 1.2D+1 + kk * exp1b * tmp1b * 1.2D+1 - 3.0D0 si = ( UN / h ) * si + add_expo3 ( 2 , deb , fin , alp , bet , gam , mu , si = 1._R8 ) si = si / lg si = sqrt ( si ) si3 = si ** 3 si4 = si ** 4 !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . sk = - 1.0D0 / si3 * ( kk * ( - 2.79D+2 / 8.0D0 ) - mu * ( 9.0D0 / 2.0D0 ) + exp3a / 3.0D0 - kk * mu * 3.6D+1 - exp2a * ( kk * ( 9.0D0 / 8.0D0 ) + mu * ( 3.0D0 / 2.0D0 ) + 3.0D0 / 2.0D0 ) + tmp1a * ( mu * 3.0D0 + mu2 * 3.0D0 + mu3 + 1.0D0 ) + ( kk3 * tmp1a10 ) / 1.0D+1 - kk2 * 2.16D+3 - mu2 * 3.0D0 + exp1a * ( kk * 3.6D+1 + mu * 6.0D0 + kk * mu * 3.6D+1 + kk2 * 2.16D+3 + mu2 * 3.0D0 + 3.0D0 ) - kk * exp2a * tmp1a2 * ( 9.0D0 / 4.0D0 ) - kk * exp2a * tmp1a3 * ( 3.0D0 / 2.0D0 ) + kk * tmp1a4 * ( mu + 1.0D0 ) ** 2 * ( 3.0D0 / 4.0D0 ) + kk2 * tmp1a7 * ( mu + 1.0D0 ) * ( 3.0D0 / 7.0D0 ) + kk2 * exp1a * tmp1a4 * 9.0D+1 + kk2 * exp1a * tmp1a5 * 1.8D+1 + kk2 * exp1a * tmp1a6 * 3.0D0 - kk * exp2a * tmp1a * ( 9.0D0 / 4.0D0 ) + kk * exp1a * tmp1a * ( kk * 6.0D+1 + mu + 1.0D0 ) * 3.6D+1 + kk * exp1a * tmp1a2 * ( kk * 6.0D+1 + mu + 1.0D0 ) * 1.8D+1 + kk * exp1a * tmp1a3 * ( kk * 6.0D+1 + mu + 1.0D0 ) * 6.0D0 - 1.1D+1 / 6.0D0 ) + 1.0D0 / si3 * ( kk * ( - 2.79D+2 / 8.0D0 ) + mu * ( 9.0D0 / 2.0D0 ) + exp3b / 3.0D0 + kk * mu * 3.6D+1 - exp2b * ( kk * ( 9.0D0 / 8.0D0 ) - mu * ( 3.0D0 / 2.0D0 ) + 3.0D0 / 2.0D0 ) - tmp1b * ( mu * 3.0D0 - mu2 * 3.0D0 + mu3 - 1.0D0 ) + ( kk3 * tmp1b10 ) / 1.0D+1 - kk2 * 2.16D+3 - mu2 * 3.0D0 + exp1b * ( kk * 3.6D+1 - mu * 6.0D0 - kk * mu * 3.6D+1 + kk2 * 2.16D+3 + mu2 * 3.0D0 + 3.0D0 ) - kk * exp2b * tmp1b2 * ( 9.0D0 / 4.0D0 ) - kk * exp2b * tmp1b3 * ( 3.0D0 / 2.0D0 ) + kk * tmp1b4 * ( mu - 1.0D0 ) ** 2 * ( 3.0D0 / 4.0D0 ) - kk2 * tmp1b7 * ( mu - 1.0D0 ) * ( 3.0D0 / 7.0D0 ) + kk2 * exp1b * tmp1b4 * 9.0D+1 + kk2 * exp1b * tmp1b5 * 1.8D+1 + kk2 * exp1b * tmp1b6 * 3.0D0 - kk * exp2b * tmp1b * ( 9.0D0 / 4.0D0 ) + kk * exp1b * tmp1b2 * ( kk * 6.0D+1 - mu + 1.0D0 ) * 1.8D+1 + kk * exp1b * tmp1b3 * ( kk * 6.0D+1 - mu + 1.0D0 ) * 6.0D0 + kk * exp1b * tmp1b * ( kk * 6.0D+1 - mu + 1.0D0 ) * 3.6D+1 - 1.1D+1 / 6.0D0 ) sk = ( UN / h ) * sk + add_expo3 ( 3 , deb , fin , alp , bet , gam , mu , si ) sk = sk / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ku = 1.0D0 / si4 * ( kk * ( - 6.77962962962963D+1 ) - mu * ( 2.2D+1 / 3.0D0 ) - exp4a / 4.0D0 - kk * mu * ( 2.79D+2 / 2.0D0 ) + exp3a * ( kk * ( 8.0D0 / 2.7D+1 ) + mu * ( 4.0D0 / 3.0D0 ) + 4.0D0 / 3.0D0 ) + exp1a * ( kk * 7.2D+1 + mu * 1.2D+1 + kk * mu * 1.44D+2 + kk * mu2 * 7.2D+1 + kk2 * mu * 8.64D+3 + kk2 * 8.64D+3 + kk3 * 1.45152D+6 + mu2 * 1.2D+1 + mu3 * 4.0D0 + 4.0D0 ) - kk * mu2 * 7.2D+1 - kk2 * mu * 8.64D+3 + ( kk4 * tmp1a13 ) / 1.3D+1 - kk2 * 8.60625D+3 - kk3 * 1.45152D+6 - mu2 * 9.0D0 - mu3 * 4.0D0 - exp2a * ( kk * ( 9.0D0 / 2.0D0 ) + mu * 6.0D0 + kk * mu * ( 9.0D0 / 2.0D0 ) + kk2 * ( 1.35D+2 / 4.0D0 ) + mu2 * 3.0D0 + 3.0D0 ) + tmp1a * ( mu * 4.0D0 + mu2 * 6.0D0 + mu3 * 4.0D0 + mu4 + 1.0D0 ) + kk * exp3a * tmp1a2 * ( 4.0D0 / 3.0D0 ) + kk * exp3a * tmp1a3 * ( 4.0D0 / 3.0D0 ) + kk * tmp1a4 * ( mu + 1.0D0 ) ** 3 + kk3 * tmp1a10 * ( mu + 1.0D0 ) * ( 2.0D0 / 5.0D0 ) - kk2 * exp2a * tmp1a4 * ( 4.5D+1 / 2.0D0 ) - kk2 * exp2a * tmp1a5 * 9.0D0 - kk2 * exp2a * tmp1a6 * 3.0D0 + kk3 * exp1a * tmp1a7 * 2.88D+2 + kk3 * exp1a * tmp1a8 * 3.6D+1 + kk3 * exp1a * tmp1a9 * 4.0D0 + kk2 * tmp1a7 * ( mu + 1.0D0 ) ** 2 * ( 6.0D0 / 7.0D0 ) + kk * exp3a * tmp1a * ( 8.0D0 / 9.0D0 ) + kk * exp1a * tmp1a * ( kk * 1.2D+2 + mu * 2.0D0 + kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 7.2D+1 - kk * exp2a * tmp1a2 * ( kk * 1.5D+1 + mu * 2.0D0 + 2.0D0 ) * ( 9.0D0 / 2.0D0 ) - kk * exp2a * tmp1a3 * ( kk * 1.5D+1 + mu * 2.0D0 + 2.0D0 ) * 3.0D0 + kk2 * exp1a * tmp1a4 * ( kk * 1.68D+2 + mu + 1.0D0 ) * 3.6D+2 + kk2 * exp1a * tmp1a5 * ( kk * 1.68D+2 + mu + 1.0D0 ) * 7.2D+1 + kk2 * exp1a * tmp1a6 * ( kk * 1.68D+2 + mu + 1.0D0 ) * 1.2D+1 + kk * exp1a * tmp1a2 * ( kk * 1.2D+2 + mu * 2.0D0 + kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 3.6D+1 + kk * exp1a * tmp1a3 * ( kk * 1.2D+2 + mu * 2.0D0 + kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 1.2D+1 - kk * exp2a * tmp1a * ( kk * 1.5D+1 + mu * 2.0D0 + 2.0D0 ) * ( 9.0D0 / 2.0D0 ) - 2.5D+1 / 1.2D+1 ) + 1.0D0 / si4 * ( kk * ( - 6.77962962962963D+1 ) + mu * ( 2.2D+1 / 3.0D0 ) - exp4b / 4.0D0 + kk * mu * ( 2.79D+2 / 2.0D0 ) + exp3b * ( kk * ( 8.0D0 / 2.7D+1 ) - mu * ( 4.0D0 / 3.0D0 ) + 4.0D0 / 3.0D0 ) + exp1b * ( kk * 7.2D+1 - mu * 1.2D+1 - kk * mu * 1.44D+2 + kk * mu2 * 7.2D+1 - kk2 * mu * 8.64D+3 + kk2 * 8.64D+3 + kk3 * 1.45152D+6 + mu2 * 1.2D+1 - mu3 * 4.0D0 + 4.0D0 ) - kk * mu2 * 7.2D+1 + kk2 * mu * 8.64D+3 + ( kk4 * tmp1b13 ) / 1.3D+1 - kk2 * 8.60625D+3 - kk3 * 1.45152D+6 - mu2 * 9.0D0 + mu3 * 4.0D0 - exp2b * ( kk * ( 9.0D0 / 2.0D0 ) - mu * 6.0D0 - kk * mu * ( 9.0D0 / 2.0D0 ) + kk2 * ( 1.35D+2 / 4.0D0 ) + mu2 * 3.0D0 + 3.0D0 ) + tmp1b * ( mu * ( - 4.0D0 ) + mu2 * 6.0D0 - mu3 * 4.0D0 + mu4 + 1.0D0 ) + kk * exp3b * tmp1b2 * ( 4.0D0 / 3.0D0 ) + kk * exp3b * tmp1b3 * ( 4.0D0 / 3.0D0 ) - kk * tmp1b4 * ( mu - 1.0D0 ) ** 3 - kk3 * tmp1b10 * ( mu - 1.0D0 ) * ( 2.0D0 / 5.0D0 ) - kk2 * exp2b * tmp1b4 * ( 4.5D+1 / 2.0D0 ) - kk2 * exp2b * tmp1b5 * 9.0D0 - kk2 * exp2b * tmp1b6 * 3.0D0 + kk3 * exp1b * tmp1b7 * 2.88D+2 + kk3 * exp1b * tmp1b8 * 3.6D+1 + kk3 * exp1b * tmp1b9 * 4.0D0 + kk2 * tmp1b7 * ( mu - 1.0D0 ) ** 2 * ( 6.0D0 / 7.0D0 ) + kk * exp3b * tmp1b * ( 8.0D0 / 9.0D0 ) + kk * exp1b * tmp1b * ( kk * 1.2D+2 - mu * 2.0D0 - kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 7.2D+1 - kk * exp2b * tmp1b2 * ( kk * 1.5D+1 - mu * 2.0D0 + 2.0D0 ) * ( 9.0D0 / 2.0D0 ) - kk * exp2b * tmp1b3 * ( kk * 1.5D+1 - mu * 2.0D0 + 2.0D0 ) * 3.0D0 + kk * exp1b * tmp1b2 * ( kk * 1.2D+2 - mu * 2.0D0 - kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 3.6D+1 + kk * exp1b * tmp1b3 * ( kk * 1.2D+2 - mu * 2.0D0 - kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 1.2D+1 + kk2 * exp1b * tmp1b4 * ( kk * 1.68D+2 - mu + 1.0D0 ) * 3.6D+2 + kk2 * exp1b * tmp1b5 * ( kk * 1.68D+2 - mu + 1.0D0 ) * 7.2D+1 + kk2 * exp1b * tmp1b6 * ( kk * 1.68D+2 - mu + 1.0D0 ) * 1.2D+1 - kk * exp2b * tmp1b * ( kk * 1.5D+1 - mu * 2.0D0 + 2.0D0 ) * ( 9.0D0 / 2.0D0 ) - 2.5D+1 / 1.2D+1 ) ku = ( UN / h ) * ku + add_expo3 ( 4 , deb , fin , alp , bet , gam , mu , si ) ku = ku / lg ssk = sk sku = ku contains real ( kind = R8 ) function expo3 ( xi , n , alp , bet , gam , mu , si ) !================================================================================================ !<@note Profile function based on the exponential function !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: alp !! *offset so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: bet !! *reduction so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: gam !! ** real ( kind = R8 ), intent ( in ) :: mu !! *numerical mean* real ( kind = R8 ), intent ( in ) :: si !! *numerical standard deviation* real ( kind = R8 ), intent ( in ) :: xi !! *abscissa* integer ( kind = I4 ), intent ( in ) :: n !! *statistical moment degree, n=3 for sk and n=4 for ku* real ( kind = R8 ) :: tmp tmp = ( xi + alp ) / bet expo3 = ( ( sign ( UN , tmp ) * ( UN - exp ( - abs ( tmp ))) + gam * tmp ** 3 - mu ) / si ) ** n return endfunction expo3 real ( kind = R8 ) function add_expo3 ( n , deb , fin , alp , bet , gam , mu , si ) !================================================================================================ !<@note Function that adds to the series mean the border integrals as explained in the modules !< presentation. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: alp !! *offset so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: bet !! *reduction so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: gam !! ** real ( kind = R8 ), intent ( in ) :: mu !! *numerical mean* real ( kind = R8 ), intent ( in ) :: si !! *numerical standard deviation* integer ( kind = I4 ), intent ( in ) :: n !! *statistical moment degree, n=3 for sk and n=4 for ku* integer ( kind = I4 ), intent ( in ) :: fin !! *last integration point* integer ( kind = I4 ), intent ( in ) :: deb !! *first integration point* real ( kind = R8 ) :: xdeb , xfin xdeb = deb xfin = fin add_expo3 = ( UN / 12 ) * ( + 9 * ( expo3 ( xdeb + 0.0_R8 , n , alp , bet , gam , mu , si ) + expo3 ( xfin - 0.0_R8 , n , alp , bet , gam , mu , si )) & + 1 * ( expo3 ( xdeb + 1.0_R8 , n , alp , bet , gam , mu , si ) + expo3 ( xfin - 1.0_R8 , n , alp , bet , gam , mu , si )) & - 4 * ( expo3 ( xdeb + 0.5_R8 , n , alp , bet , gam , mu , si ) + expo3 ( xfin - 0.5_R8 , n , alp , bet , gam , mu , si )) ) return endfunction add_expo3 endsubroutine calculs_skku_exp3","tags":"","loc":"proc/calculs_skku_exp3.html"},{"title":"calculs_skku_tan – CREST","text":"private  subroutine calculs_skku_tan(bounds, lg, ssk, sku) Note Function to calculate the skewness and kurtosis of a tangent series Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: bounds defines the function limits [-pi/2.(1-bounds(1)), +pi/2.(1-bounds(2)] integer(kind=I4), intent(in) :: lg vec size real(kind=R8), intent(out) :: ssk theoretical Ssk real(kind=R8), intent(out) :: sku theoretical Sku Calls proc~~calculs_skku_tan~~CallsGraph proc~calculs_skku_tan calculs_skku_tan proc~add_tang add_tang proc~calculs_skku_tan->proc~add_tang proc~tang tang proc~calculs_skku_tan->proc~tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculs_skku_tan~~CalledByGraph proc~calculs_skku_tan calculs_skku_tan proc~fitness_skku_anal fitness_skku_anal proc~fitness_skku_anal->proc~calculs_skku_tan proc~cost_func_skku cost_func_skku proc~cost_func_skku->proc~fitness_skku_anal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calculs_skku_tan ( bounds , lg , ssk , sku ) !================================================================================================ !<@note Function to calculate the skewness and kurtosis of a **tangent** series !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: bounds !! *defines the function limits* [-pi/2.(1-bounds(1)), +pi/2.(1-bounds(2)] integer ( kind = I4 ), intent ( in ) :: lg !! *vec size* real ( kind = R8 ), intent ( out ) :: ssk !! *theoretical Ssk* real ( kind = R8 ), intent ( out ) :: sku !! *theoretical Sku* real ( kind = R8 ) :: xa , xb , mu , si , sk , ku , a , b real ( kind = R8 ) :: h , hh , b1 , b2 , alp , bet integer ( kind = I4 ) :: i , ia , ib , deb , fin !--------------------------------------------- ! WXMAXIMA file !--------------------------------------------- !kill(all); ! !f11(x):=tan(x)$ ! !assume(u<0.)$ !assume(u>-%pi/2)$ !assume(v>0.)$ !assume(v<%pi/2)$ ! !I11:integrate(f11(x),x,u,v)$ !I11:subst(-%pi/2+%pi/2*xa,u,I11)$ !I11:subst(+%pi/2-%pi/2*xb,v,I11)$ !I11:expand(trigsimp(I11)); ! !f21(x):=f11(x)-mu$ !I21:integrate(expand(f21(x)&#94;2),x,u,v)$ !I21:subst(-%pi/2+%pi/2*xa,u,I21)$ !I21:subst(+%pi/2-%pi/2*xb,v,I21)$ !I21:expand(trigsimp(I21)); ! !f31(x):=f21(x)/si$ !I31:integrate(f31(x)&#94;3,x,u,v)$ !I31:subst(-%pi/2+%pi/2*xa,u,I31)$ !I31:subst(+%pi/2-%pi/2*xb,v,I31)$ !I31:expand(trigsimp(I31)); ! !I41:integrate(f31(x)&#94;4,x,u,v)$ !I41:subst(-%pi/2+%pi/2*xa,u,I41)$ !I41:subst(+%pi/2-%pi/2*xb,v,I41)$ !I41:expand(trigsimp(I41)); !--------------------------------------------- ia = 256 ! ia and ib define the interval edges to be excluded ... ib = 256 ! ... because of high variations of the function. deb = 1 + ia ! start fin = lg - ib ! end a = bounds ( 1 ) b = bounds ( 2 ) hh = ( 2._R8 - a - b ) / ( lg - 1 ) h = ( PI_R8 / 2 ) * hh xa = a + ia * hh xb = b + ib * hh b1 = - PI_R8 / 2 * ( UN - a ) b2 = + PI_R8 / 2 * ( UN - b ) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . mu = log ( sin (( PI_R8 * xa ) / 2. )) - log ( sin (( PI_R8 * xb ) / 2. )) mu = ( UN / h ) * mu + add_tang ( 1 , deb , fin , alp , bet , mu = 0._R8 , si = 1._R8 ) do i = 1 , ia - 1 mu = mu + tang ( i * UN , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo do i = lg , lg - ( ib - 2 ), - 1 mu = mu + tang ( i * UN , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo mu = mu / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . si = 2. * mu * log ( sin (( PI_R8 * xb ) / 2. )) + cos (( PI_R8 * xb ) / 2. ) / sin (( PI_R8 * xb ) / 2. ) - ( PI_R8 * mu ** 2. * xb ) / 2. + ( PI_R8 * xb ) / 2. & ! - 2. * mu * log ( sin (( PI_R8 * xa ) / 2. )) + cos (( PI_R8 * xa ) / 2. ) / sin (( PI_R8 * xa ) / 2. ) - ( PI_R8 * mu ** 2. * xa ) / 2. + ( PI_R8 * xa ) / 2. + PI_R8 * mu ** 2. - PI_R8 ! si = ( UN / h ) * si + add_tang ( 2 , deb , fin , alp , bet , mu , si = 1._R8 ) do i = 1 , ia - 1 si = si + tang ( i * UN , 2 , alp , bet , mu , si = 1._R8 ) enddo do i = lg , lg - ( ib - 2 ), - 1 si = si + tang ( i * UN , 2 , alp , bet , mu , si = 1._R8 ) enddo si = si / lg si = sqrt ( si ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . sk = log ( sin (( PI_R8 * xb ) / 2. ) ** 2. ) / ( 2. * si ** 3. ) & ! - ( 3. * mu ** 2. * log ( sin (( PI_R8 * xb ) / 2. ))) / si ** 3. & ! - ( 3. * mu * cos (( PI_R8 * xb ) / 2. )) / ( si ** 3. * sin (( PI_R8 * xb ) / 2. )) & ! + 1 / ( 2. * si ** 3. * sin (( PI_R8 * xb ) / 2. ) ** 2. ) + ( PI_R8 * mu ** 3. * xb ) / ( 2. * si ** 3. ) & ! - ( 3. * PI_R8 * mu * xb ) / ( 2. * si ** 3. ) & ! - log ( sin (( PI_R8 * xa ) / 2. ) ** 2. ) / ( 2. * si ** 3. ) & ! + ( 3. * mu ** 2. * log ( sin (( PI_R8 * xa ) / 2. ))) / si ** 3. & ! - ( 3. * mu * cos (( PI_R8 * xa ) / 2. )) / ( si ** 3. * sin (( PI_R8 * xa ) / 2. )) & ! - 1 / ( 2. * si ** 3. * sin (( PI_R8 * xa ) / 2. ) ** 2. ) + ( PI_R8 * mu ** 3. * xa ) / ( 2. * si ** 3. ) & ! - ( 3. * PI_R8 * mu * xa ) / ( 2. * si ** 3. ) - ( PI_R8 * mu ** 3. ) / si ** 3. + ( 3. * PI_R8 * mu ) / si ** 3. ! sk = ( UN / h ) * sk + add_tang ( 3 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 sk = sk + tang ( i * UN , 3 , alp , bet , mu , si ) enddo do i = lg , lg - ( ib - 2 ), - 1 sk = sk + tang ( i * UN , 3 , alp , bet , mu , si ) enddo sk = sk / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ku = - ( 2. * mu * log ( sin (( PI_R8 * xb ) / 2. ) ** 2. )) / si ** 4. + ( 4. * mu ** 3. * log ( sin (( PI_R8 * xb ) / 2. ))) / si ** 4. & ! + ( 6. * mu ** 2. * cos (( PI_R8 * xb ) / 2. )) / ( si ** 4. * sin (( PI_R8 * xb ) / 2. )) - ( 4. * cos (( PI_R8 * xb ) / 2. )) / ( 3. * si ** 4. * sin (( PI_R8 * xb ) / 2. )) & ! - ( 2. * mu ) / ( si ** 4. * sin (( PI_R8 * xb ) / 2. ) ** 2. ) + cos (( PI_R8 * xb ) / 2. ) / ( 3. * si ** 4. * sin (( PI_R8 * xb ) / 2. ) ** 3. ) & ! - ( PI_R8 * mu ** 4. * xb ) / ( 2. * si ** 4. ) + ( 3. * PI_R8 * mu ** 2. * xb ) / si ** 4. - ( PI_R8 * xb ) / ( 2. * si ** 4. ) & ! + ( 2. * mu * log ( sin (( PI_R8 * xa ) / 2. ) ** 2. )) / si ** 4. - ( 4. * mu ** 3. * log ( sin (( PI_R8 * xa ) / 2. ))) / si ** 4. & ! + ( 6. * mu ** 2. * cos (( PI_R8 * xa ) / 2. )) / ( si ** 4. * sin (( PI_R8 * xa ) / 2. )) - ( 4. * cos (( PI_R8 * xa ) / 2. )) / ( 3. * si ** 4. * sin (( PI_R8 * xa ) / 2. )) & ! + ( 2. * mu ) / ( si ** 4. * sin (( PI_R8 * xa ) / 2. ) ** 2. ) + cos (( PI_R8 * xa ) / 2. ) / ( 3. * si ** 4. * sin (( PI_R8 * xa ) / 2. ) ** 3. ) & ! - ( PI_R8 * mu ** 4. * xa ) / ( 2. * si ** 4. ) + ( 3. * PI_R8 * mu ** 2. * xa ) / si ** 4. - ( PI_R8 * xa ) / ( 2. * si ** 4. ) & ! + ( PI_R8 * mu ** 4. ) / si ** 4. - ( 6. * PI_R8 * mu ** 2. ) / si ** 4. + PI_R8 / si ** 4. ! ku = ( UN / h ) * ku + add_tang ( 4 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 ku = ku + tang ( i * UN , 4 , alp , bet , mu , si ) enddo do i = lg , lg - ( ib - 2 ), - 1 ku = ku + tang ( i * UN , 4 , alp , bet , mu , si ) enddo ku = ku / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ssk = sk sku = ku return endsubroutine calculs_skku_tan","tags":"","loc":"proc/calculs_skku_tan.html"},{"title":"cost_func_skku – CREST","text":"private  subroutine cost_func_skku(me, x, f) Quantify de distance between desired moments and calculated moments Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=R8), intent(in), dimension(:) :: x real(kind=R8), intent(out) :: f Calls proc~~cost_func_skku~~CallsGraph proc~cost_func_skku cost_func_skku proc~fitness_skku_anal fitness_skku_anal proc~cost_func_skku->proc~fitness_skku_anal proc~calculs_skku_exp3 calculs_skku_exp3 proc~fitness_skku_anal->proc~calculs_skku_exp3 proc~calculs_skku_tan calculs_skku_tan proc~fitness_skku_anal->proc~calculs_skku_tan proc~add_tang add_tang proc~calculs_skku_tan->proc~add_tang proc~tang tang proc~calculs_skku_tan->proc~tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine cost_func_skku ( me , x , f ) !! Quantify de distance between desired moments and calculated moments implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f f = fitness_skku_anal ( n = PARAM % nparam , x = x ( 1 : PARAM % nparam ) ) return endsubroutine cost_func_skku","tags":"","loc":"proc/cost_func_skku.html"},{"title":"pikaia_skku_solver – CREST","text":"private  subroutine pikaia_skku_solver(pik_class, step, xl, xu, nparam, cost, istat, f, xx) Note This is a refactoring of the PIKAIA unconstrained optimization code from the High Altitude Observatory.\n The original code is public domain and was written by Paul Charbonneau & Barry Knapp. The present code is the awesome modern Fortran version written by Jabob Williams: OOP Pikaia, Jacob Williams Arguments Type Intent Optional Attributes Name type( pikaia_class ), intent(inout) :: pik_class PIKAIA class instanciation character(len=4), intent(in) :: step init or solv real(kind=R8), intent(in), dimension(1:nparam) :: xl lower bonds of xx real(kind=R8), intent(in), dimension(1:nparam) :: xu upper bonds of xx integer(kind=I4), intent(in) :: nparam number of parameters private  subroutine cost(me, x, f) Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=R8), intent(in), dimension(:) :: x real(kind=R8), intent(out) :: f integer(kind=I4), intent(out) :: istat real(kind=R8), intent(out) :: f real(kind=R8), intent(out), dimension(1:nparam) :: xx chromosom for PIKAIA Calls proc~~pikaia_skku_solver~~CallsGraph proc~pikaia_skku_solver pikaia_skku_solver init pikaia_class%init proc~pikaia_skku_solver->init solve pikaia_class%solve proc~pikaia_skku_solver->solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pikaia_skku_solver~~CalledByGraph proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights build_heights proc~build_heights->proc~pikaia_skku_solver proc~add_nois add_nois proc~add_nois->proc~build_heights proc~calc_z_f calc_z_f proc~calc_z_f->proc~build_heights proc~calc_z_i calc_z_i proc~calc_z_i->proc~build_heights proc~sub_surf sub_surf proc~sub_surf->proc~build_heights proc~read_job read_job proc~read_job->proc~add_nois proc~read_job->proc~calc_z_f proc~read_job->proc~calc_z_i proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine pikaia_skku_solver ( pik_class , step , xl , xu , nparam , cost , istat , f , xx ) !================================================================================================ !<@note This is a refactoring of the PIKAIA unconstrained optimization code from the High Altitude Observatory. !< The original code is public domain and was written by Paul Charbonneau & Barry Knapp. !< !< The present code is the awesome modern Fortran version written by Jabob Williams: !< !< [OOP Pikaia, Jacob Williams](https://github.com/jacobwilliams/pikaia) !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none type ( pikaia_class ), intent ( inout ) :: pik_class !! **PIKAIA** *class instanciation* character ( len = 4 ), intent ( in ) :: step !! *init* or *solv* integer ( kind = I4 ), intent ( in ) :: nparam !! *number of parameters* real ( kind = R8 ), intent ( in ), dimension ( 1 : nparam ) :: xl !! *lower bonds of xx* real ( kind = R8 ), intent ( in ), dimension ( 1 : nparam ) :: xu !! *upper bonds of xx* real ( kind = R8 ), intent ( out ), dimension ( 1 : nparam ) :: xx !! *chromosom for* **PIKAIA** integer ( kind = I4 ), intent ( out ) :: istat real ( kind = R8 ), intent ( out ) :: f interface subroutine cost ( me , x , f ) use data_arch , only : R8 use pikaia_oop , only : pikaia_class implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f endsubroutine cost endinterface select case ( step ) case ( 'init' ) !initialize the class: call pik_class % init ( n = nparam , & ! IN           ; the parameter space dimension, i.e., the number of adjustable parameters (size of the x vector). xl = xl , & ! IN, DIM(n)   ;  vector of lower bounds for x xu = xu , & ! IN, DIM(n)   ;  vector of upper bounds for x f = cost , & !              ; user-supplied scalar function of n variables, which must have the pikaia_func procedure interface. status = istat , & ! OUT          ; status output flag (0 if there were no errors) !iter_f = report_iteration,    &  !     OPT      ; user-supplied subroutine that will report the best solution for each generation. It must have the iter_func procedure interface. np = 100 , & ! IN, OPT      ; number of individuals in a population (default is 100) ngen = 1000 , & ! IN, OPT      ; maximum number of iterations nd = 9 , & ! IN           ; number of significant digits (i.e., number of genes) retained in chromosomal encoding pcross = 0.85_R8 , & ! IN, OPT      ; crossover probability; must be <= 1.0 (default is 0.85). If crossover takes place, either one or two splicing points are used, with equal probabilities pmutmn = 0.0005_R8 , & ! IN, OPT      ; minimum mutation rate; must be >= 0.0 (default is 0.0005) pmutmx = 0.25_R8 , & ! IN, OPT      ; maximum mutation rate; must be <= 1.0 (default is 0.25) pmut = 0.005_R8 , & ! IN, OPT      ; initial mutation rate; should be small (default is 0.005) (Note: the mutation rate is the probability that any one gene locus will mutate in any one generation.) imut = 2 , & ! IN, OPT      ; mutation mode; 1/2/3/4/5 (default is 2). !              1=one-point mutation, fixed rate. !              2=one-point, adjustable rate based on fitness. !              3=one-point, adjustable rate based on distance. !              4=one-point+creep, fixed rate. !              5=one-point+creep, adjustable rate based on fitness. !              6=one-point+creep, adjustable rate based on distance. fdif = 1._R8 , & ! IN, OPT      ; relative fitness differential; range from 0 (none) to 1 (maximum). (default is 1.0) irep = 3 , & ! IN, OPT      ; reproduction plan; 1/2/3=Full generational replacement/Steady-state-replace-random/Steady- state-replace-worst (default is 3) ielite = 0 , & ! IN, OPT      ; elitism flag; 0/1=off/on (default is 0) (Applies only to reproduction plans 1 and 2) ivrb = 0 , & ! IN, OPT      ; printed output 0/1/2=None/Minimal/Verbose convergence_tol = 1.0e-6_R8 , & ! IN, OPT      ; convergence tolerance; must be > 0.0 (default is 0.0001) convergence_window = 200 , & ! IN, OPT      ; convergence window; must be >= 0 This is the number of consecutive solutions within the tolerance for convergence to be declared (default is 20) initial_guess_frac = 0.1_R8 , & ! IN, OPT      ; raction of the initial population to set equal to the initial guess. Range from 0 (none) to 1.0 (all). (default is 0.1 or 10%). iseed = 999 ) ! IN, OPT      ; random seed value; must be > 0 (default is 999) case ( 'solv' ) call pik_class % solve ( x = xx ( 1 : nparam ), & ! INOUT, DIM(*) ; f = f , & !   OUT         ; status = istat , & !   OUT         ; omp = . true . ) ! IN, OPTIONAL case default stop 'Wrong choice in \"pikaia_skku_solver\"' endselect return endsubroutine pikaia_skku_solver","tags":"","loc":"proc/pikaia_skku_solver.html"},{"title":"profil_theo_trie_1D – CREST","text":"private  subroutine profil_theo_trie_1D(tab, lg, x, mx) Note Function that generates the heights when the function limits have been determined. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:lg) :: tab height vector integer(kind=I4), intent(in) :: lg height vector size real(kind=R8), intent(in), dimension( :  ) :: x unknowns: height function limits type( moment_stat ), intent(out) :: mx resulting statistical moments Calls proc~~profil_theo_trie_1d~~CallsGraph proc~profil_theo_trie_1d profil_theo_trie_1D std_array std_array proc~profil_theo_trie_1d->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~profil_theo_trie_1d~~CalledByGraph proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights build_heights proc~build_heights->proc~profil_theo_trie_1d proc~add_nois add_nois proc~add_nois->proc~build_heights proc~calc_z_f calc_z_f proc~calc_z_f->proc~build_heights proc~calc_z_i calc_z_i proc~calc_z_i->proc~build_heights proc~sub_surf sub_surf proc~sub_surf->proc~build_heights proc~read_job read_job proc~read_job->proc~add_nois proc~read_job->proc~calc_z_f proc~read_job->proc~calc_z_i proc~read_job->proc~sub_surf proc~prg_surf prg_surf proc~prg_surf->proc~read_job program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine profil_theo_trie_1D ( tab , lg , x , mx ) !================================================================================================ !<@note Function that generates the heights when the function limits have been determined. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: lg !! *height vector size* real ( kind = R8 ), intent ( out ), dimension ( 1 : lg ) :: tab !! *height vector* real ( kind = R8 ), intent ( in ), dimension ( : ) :: x !! *unknowns: height function limits* type ( MOMENT_STAT ), intent ( out ) :: mx !! *resulting statistical moments* real ( kind = R8 ) :: b1 , b2 , alp , bet , tmp integer ( kind = I4 ) :: i select case ( PARAM % func_gen ) case ( FCT_TANG ) b1 = - PI_R8 / 2 * ( UN - x ( 1 )) b2 = + PI_R8 / 2 * ( UN - x ( 2 )) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) do i = 1 , lg tab ( i ) = tan ( ( i * UN + alp ) / bet ) enddo case ( FCT_EXPO ) b1 = - ( UN - x ( 1 )) / x ( 1 ) b2 = + ( UN - x ( 2 )) / x ( 2 ) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) do i = 1 , lg tmp = ( i * UN + alp ) / bet tmp = max ( - 0.9 * HIG_E8 , tmp ) tmp = min ( + 0.9 * HIG_E8 , tmp ) tab ( i ) = sign ( UN , tmp ) * ( UN - exp ( - abs ( tmp ))) + ( x ( 3 ) / ( b2 - b1 ) ** 3 ) * tmp ** 3 enddo endselect call std_array ( tab = tab ( 1 : lg ), mx = mx ) mx % mu = 0._R8 mx % si = 1._R8 return endsubroutine profil_theo_trie_1D","tags":"","loc":"proc/profil_theo_trie_1d.html"},{"title":"prg_surf – CREST","text":"subroutine prg_surf() Note Main function… Arguments None Calls proc~~prg_surf~~CallsGraph proc~prg_surf prg_surf proc~read_job read_job proc~prg_surf->proc~read_job get_unit get_unit proc~read_job->get_unit proc~acf_theo acf_theo proc~read_job->proc~acf_theo proc~add_nois add_nois proc~read_job->proc~add_nois proc~alloc_tabs alloc_tabs proc~read_job->proc~alloc_tabs proc~apod_acf apod_acf proc~read_job->proc~apod_acf proc~apod_sur apod_sur proc~read_job->proc~apod_sur proc~calc_acf calc_acf proc~read_job->proc~calc_acf proc~calc_ffh calc_ffh proc~read_job->proc~calc_ffh proc~calc_ord calc_ord proc~read_job->proc~calc_ord proc~calc_z_f calc_z_f proc~read_job->proc~calc_z_f proc~calc_z_i calc_z_i proc~read_job->proc~calc_z_i proc~def_size def_size proc~read_job->proc~def_size proc~digi_fil digi_fil proc~read_job->proc~digi_fil proc~end_loop end_loop proc~read_job->proc~end_loop proc~end_scri end_scri proc~read_job->proc~end_scri proc~make_msk make_msk proc~read_job->proc~make_msk proc~make_scratches make_scratches proc~read_job->proc~make_scratches proc~make_tex make_tex proc~read_job->proc~make_tex proc~nb_procs nb_procs proc~read_job->proc~nb_procs proc~plt__acf plt__acf proc~read_job->proc~plt__acf proc~read_img read_img proc~read_job->proc~read_img proc~repr_img repr_img proc~read_job->proc~repr_img proc~save_img save_img proc~read_job->proc~save_img proc~smooth__ smooth__ proc~read_job->proc~smooth__ proc~spct_sur spct_sur proc~read_job->proc~spct_sur proc~sta_loop sta_loop proc~read_job->proc~sta_loop proc~sta_scri sta_scri proc~read_job->proc~sta_scri proc~sta_theo sta_theo proc~read_job->proc~sta_theo proc~stat_sur stat_sur proc~read_job->proc~stat_sur proc~sub_surf sub_surf proc~read_job->proc~sub_surf proc~surface_analysis surface_analysis proc~read_job->proc~surface_analysis selectcase selectcase proc~read_job->selectcase str_remove_chars str_remove_chars proc~read_job->str_remove_chars ellipse_acf ellipse_acf proc~acf_theo->ellipse_acf proc~calc_imp_acf calc_imp_acf proc~acf_theo->proc~calc_imp_acf proc~build_heights build_heights proc~add_nois->proc~build_heights scramble scramble proc~add_nois->scramble std_array std_array proc~add_nois->std_array proc~apod_acf->ellipse_acf proc~apod2 apod2 proc~apod_acf->proc~apod2 apod apod proc~apod_sur->apod proc~apod_sur->std_array proc~acf_wiener acf_wiener proc~calc_acf->proc~acf_wiener calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_ffh->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_ffh->calc_fftw3_real_fwd calc_moments calc_moments proc~calc_ffh->calc_moments init_order init_order proc~calc_ord->init_order sort_array2 sort_array2 proc~calc_ord->sort_array2 proc~calc_z_f->proc~build_heights proc~calc_z_f->std_array proc~calc_z_i->proc~build_heights proc~calc_z_i->scramble proc~calc_z_i->std_array proc~digi_fil->calc_fftw3_real_bwd proc~digi_fil->calc_fftw3_real_fwd proc~digi_fil->std_array end_fftw3 end_fftw3 proc~end_scri->end_fftw3 calc_fftw3 calc_fftw3 proc~make_tex->calc_fftw3 proc~make_tex->calc_moments omp_get_num_procs omp_get_num_procs proc~nb_procs->omp_get_num_procs proc~plt__acf->get_unit dir_separator dir_separator proc~plt__acf->dir_separator proc~plt__acf->ellipse_acf mkdir mkdir proc~plt__acf->mkdir read_surf read_surf proc~read_img->read_surf proc~repr_img->proc~alloc_tabs proc~repr_img->proc~surface_analysis proc~repr_img->apod proc~repr_img->calc_moments fft_filter fft_filter proc~repr_img->fft_filter init_scal init_scal proc~repr_img->init_scal proc~repr_img->proc~acf_wiener proc~repr_img->scramble proc~repr_img->sort_array2 proc~repr_img->std_array write_surf write_surf proc~repr_img->write_surf proc~save_img->init_scal proc~save_img->write_surf proc~smooth__->fft_filter proc~smooth__->std_array proc~spct_sur->get_unit proc~spct_sur->proc~apod_sur proc~spct_sur->calc_fftw3 trans_corner2center trans_corner2center proc~spct_sur->trans_corner2center random_init random_init proc~sta_scri->random_init proc~stat_sur->proc~apod_sur proc~stat_sur->proc~surface_analysis proc~stat_sur->proc~acf_wiener proc~stat_sur->sort_array2 proc~stat_sur->std_array proc~sub_surf->calc_moments proc~sub_surf->end_fftw3 fftw_plan_with_nthreads fftw_plan_with_nthreads proc~sub_surf->fftw_plan_with_nthreads proc~sub_surf->init_order omp_get_max_threads omp_get_max_threads proc~sub_surf->omp_get_max_threads proc~sub_surf->proc~acf_wiener proc~sub_surf->proc~build_heights proc~sub_surf->proc~calc_imp_acf proc~calc_res_acf calc_res_acf proc~sub_surf->proc~calc_res_acf progress_bar_terminal progress_bar_terminal proc~sub_surf->progress_bar_terminal proc~sub_surf->sort_array2 tab_end_fftw3_real tab_end_fftw3_real proc~sub_surf->tab_end_fftw3_real tab_init_fftw3_real tab_init_fftw3_real proc~sub_surf->tab_init_fftw3_real proc~surface_analysis->get_unit abbott_param abbott_param proc~surface_analysis->abbott_param calc_median calc_median proc~surface_analysis->calc_median proc~surface_analysis->calc_moments calcul_asfc_hermite calcul_asfc_hermite proc~surface_analysis->calcul_asfc_hermite calcul_normales calcul_normales proc~surface_analysis->calcul_normales proc~surface_analysis->ellipse_acf proc~surface_analysis->fft_filter indice_fractal indice_fractal proc~surface_analysis->indice_fractal multiple_anisotropy multiple_anisotropy proc~surface_analysis->multiple_anisotropy peaks_and_pits_curvatures peaks_and_pits_curvatures proc~surface_analysis->peaks_and_pits_curvatures proc~surface_analysis->proc~acf_wiener surf_area surf_area proc~surface_analysis->surf_area topology topology proc~surface_analysis->topology proc~acf_wiener->calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_fwd proc~acf_wiener->trans_corner2center tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd proc~build_heights->sort_array2 proc~build_heights->std_array proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo init pikaia_class%init proc~pikaia_skku_solver->init solve pikaia_class%solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~prg_surf~~CalledByGraph proc~prg_surf prg_surf program~main main program~main->proc~prg_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine prg_surf () !================================================================================================ !<@note Main function... ! ! - retrieve script (job) file ! - read script ! - run specific functions associated to a script keyword ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 128 ) :: arg_prg character ( len = 512 ) :: job_file integer ( kind = I4 ) :: var_i ! String initialisation arg_prg = repeat ( ' ' , len ( arg_prg )) JOB_FILE = repeat ( ' ' , len ( JOB_FILE )) var_i = 1 call get_command_argument ( var_i , arg_prg ) ! argument one: argument string if ( len_trim ( arg_prg ) == 0 ) then ! if there is no job file, stop write ( TER , * ) 'no job file, stop' stop else job_file = trim ( arg_prg ) endif call read_job ( job_file ) ! the program executes 'prg_repeat' times write ( TER , * ) 'Program completed' return endsubroutine prg_surf","tags":"","loc":"proc/prg_surf.html"},{"title":"func_acf – CREST","text":"Uses crest_param data_arch miscellaneous stat_mom fftw3 module~~func_acf~~UsesGraph module~func_acf func_acf data_arch data_arch module~func_acf->data_arch fftw3 fftw3 module~func_acf->fftw3 miscellaneous miscellaneous module~func_acf->miscellaneous module~crest_param crest_param module~func_acf->module~crest_param stat_mom stat_mom module~func_acf->stat_mom module~crest_param->data_arch module~crest_param->stat_mom pikaia_oop pikaia_oop module~crest_param->pikaia_oop surfile surfile module~crest_param->surfile Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~func_acf~~UsedByGraph module~func_acf func_acf module~analyses analyses module~analyses->module~func_acf module~script script module~script->module~func_acf module~script->module~analyses program~main main program~main->module~script Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function autocov_impo (xi, xj, tau1, tau2, alpha, ang) Function that returns Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi coordinate real(kind=R8), intent(in) :: xj coordinate real(kind=R8), intent(in) :: tau1 correlation length along real(kind=R8), intent(in) :: tau2 correlation length along real(kind=R8), intent(in) :: alpha log(z) where z is often 0.2 real(kind=R8), intent(in) :: ang angle (rad) Return Value real(kind=r8) Subroutines public  subroutine acf_wiener (tab_in, tab_out, w, h, multi_fft) Function that returns the acf of an array. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:w, 1:h) :: tab_in input array real(kind=R8), intent(out), dimension(1:w, 1:h) :: tab_out acf of the input array integer(kind=I4), intent(in) :: w 2D array length integer(kind=I4), intent(in) :: h 2D array width logical(kind=I4), intent(in), optional :: multi_fft run parallel acfs? public  subroutine apod2 (tab_in, tab_out, long, larg, tau1, tau2, ang) Function that returns an apodized array. To prevent gaps from appearing after FFT (because of non periodic waves), the surface must\n be transformed, but not too much. Here a modified Tukey window is determined. The starting\n surface is not modified below the “correlation lengths”. Above the correlation lengths, a\n smooth decrease is forced with a cosine squared. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in input acf real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out apodized acf integer(kind=I4), intent(in) :: long surface acf length integer(kind=I4), intent(in) :: larg surface acf width real(kind=R8), intent(in) :: tau1 surface first correlation length real(kind=R8), intent(in) :: tau2 surface second correlation length real(kind=R8), intent(in) :: ang ellipsis angle public  subroutine calc_imp_acf (long, larg, tau1, tau2, alpha, ang, tab_acf, apod) Function that returns the theoretical autocorrelation function in an array. The autocorrelation function is supposed to be obtained from a real surface which must be periodic\n or nearly periodic (because of the use of FFTs).\n In addition, the surface is supposed to be 0 mean and normalized ( ),\n therefore acf is zero-mean and normalized so that its max value is 1. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long surface acf width integer(kind=I4), intent(in) :: larg surface acf height real(kind=R8), intent(in) :: tau1 first correlation length real(kind=R8), intent(in) :: tau2 surface second correlation length real(kind=R8), intent(in) :: alpha parameter that controls the expondential decrease real(kind=R8), intent(in) :: ang acf ellipsis angle real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_acf resulting acf logical(kind=I4), intent(in) :: apod apodization?","tags":"","loc":"module/func_acf.html"},{"title":"crest_param – CREST","text":"Uses stat_mom data_arch surfile pikaia_oop module~~crest_param~~UsesGraph module~crest_param crest_param data_arch data_arch module~crest_param->data_arch pikaia_oop pikaia_oop module~crest_param->pikaia_oop stat_mom stat_mom module~crest_param->stat_mom surfile surfile module~crest_param->surfile Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~crest_param~~UsedByGraph module~crest_param crest_param module~analyses analyses module~analyses->module~crest_param module~func_acf func_acf module~analyses->module~func_acf module~func_acf->module~crest_param module~script script module~script->module~crest_param module~script->module~analyses module~script->module~func_acf module~skku_profiles skku_profiles module~script->module~skku_profiles module~skku_profiles->module~crest_param program~main main program~main->module~crest_param program~main->module~script Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=I4), public, parameter :: FCT_EXPO = 2 exponential function for height generation integer(kind=I4), public, parameter :: FCT_TANG = 1 tangent function for height generation integer(kind=I4), public :: JOB JOB file: script type( param_crest ), public :: PARAM integer(kind=I4), public :: SPY SPY file integer(kind=I4), public :: STA result file integer(kind=I4), public, parameter :: TER = 6 terminal output integer(kind=I4), public :: i_iter current and number of iterations integer(kind=I4), public :: line_read *line number in the script” integer(kind=I4), public :: nb_iter current and number of iterations integer(kind=I4), public :: save_line_read *line number in the script” type( SCALE_SURF ), public :: scale_img .SUR surface properties Derived Types type, public :: acf_param Components Type Visibility Attributes Name Initial real(kind=R8), public :: ang roughness orientation real(kind=R8), public :: cl1 correlation principal length at z=acf__z real(kind=R8), public :: cl2 correlation secondary length at z=acf__z real(kind=R8), public :: cut acf cutting plane z, for correlation lengths determination type, public :: param_crest Components Type Visibility Attributes Name Initial real(kind=R8), public, allocatable, dimension(:,:) :: acf_surf calculated autocorrelation logical(kind=I4), public :: apod apodize imposed acf? logical(kind=I4), public :: calc_mstt calculate starting moments? logical(kind=I4), public :: calc_zf calculate final heights? real(kind=R8), public :: crt_acf acf criterion: mean absolute difference between imposed and calculated acf allowed type( acf_param ), public :: curr_surf current  surface ACF properties real(kind=R8), public :: cutoff Gaussian filter cutoff real(kind=R8), public, allocatable, dimension(:,:) :: fhi digital filter integer(kind=I4), public :: func_gen mathematical function used to generate the heights integer(kind=I4), public :: height surface nb points along y real(kind=R8), public, allocatable, dimension(:,:) :: imp_acf imposed autocorrelation type( moment_stat ), public :: m__HF surface to be reproduced stat moments, high frequencies type( moment_stat ), public :: m__LF surface to be reproduced stat moments, low  frequencies type( moment_stat ), public :: m_end final stat moments type( moment_stat ), public :: m_ini surface to be reproduced stat moments type( moment_stat ), public :: m_inp input stat moments for genetic algo optimizer type( moment_stat ), public :: m_stt starting stat moments integer(kind=I4), public :: nb_threads number of concurrent threads integer(kind=I4), public :: nparam number of parameters for the mathematical function integer(kind=I4), public :: npts surface nb points integer(kind=I4), public, allocatable, dimension(:) :: order vector that stores heights order type( acf_param ), public :: orig_surf original surface ACF properties logical(kind=I4), public :: periodic is the surface periodic? type( pikaia_class ), public :: pik_class PIKAIA class instanciation logical(kind=I4), public :: reajust_skku if Ssk 2 +1 > Sku, modify Sku real(kind=R8), public :: res_acf store mean absolute difference between imposed and calculated acf integer(kind=I4), public :: sub_height subsurface nb points along y integer(kind=I4), public :: sub_npts subsurface nb points real(kind=R8), public :: sub_surf_height subsurface height (m) real(kind=R8), public :: sub_surf_width subsurface width (m) integer(kind=I4), public :: sub_width subsurface nb points along x real(kind=R8), public, allocatable, dimension(:,:) :: surf surface array real(kind=R8), public, allocatable, dimension(:,:) :: surf_HF surface high frequencies real(kind=R8), public, allocatable, dimension(:,:) :: surf_LF surface low frequencies real(kind=R8), public, allocatable, dimension(:,:) :: surf_copy surface array copy real(kind=R8), public :: surf_dx surface increment along x (m) real(kind=R8), public :: surf_dy surface increment along y (m) real(kind=R8), public :: surf_height surface height (m) logical(kind=I4), public, allocatable, dimension(:,:) :: surf_msk surface high frequencies real(kind=R8), public :: surf_width surface width (m) real(kind=R8), public, allocatable, dimension(:) :: vect_h vector used to store the heights that meet the stat moments integer(kind=I4), public :: width surface nb points along x","tags":"","loc":"module/crest_param.html"},{"title":"script – CREST","text":"Uses analyses crest_param gnufor pikaia_oop sort_arrays func_acf files data_arch skku_profiles filter surfile anisotropy stat_mom fftw3 miscellaneous module~~script~~UsesGraph module~script script anisotropy anisotropy module~script->anisotropy data_arch data_arch module~script->data_arch fftw3 fftw3 module~script->fftw3 files files module~script->files filter filter module~script->filter gnufor gnufor module~script->gnufor miscellaneous miscellaneous module~script->miscellaneous module~analyses analyses module~script->module~analyses module~crest_param crest_param module~script->module~crest_param module~func_acf func_acf module~script->module~func_acf module~skku_profiles skku_profiles module~script->module~skku_profiles pikaia_oop pikaia_oop module~script->pikaia_oop sort_arrays sort_arrays module~script->sort_arrays stat_mom stat_mom module~script->stat_mom surfile surfile module~script->surfile module~analyses->anisotropy module~analyses->data_arch module~analyses->fftw3 module~analyses->files module~analyses->filter module~analyses->miscellaneous module~analyses->module~crest_param module~analyses->module~func_acf module~analyses->stat_mom abbott abbott module~analyses->abbott asfc asfc module~analyses->asfc grad_curv grad_curv module~analyses->grad_curv morpho morpho module~analyses->morpho module~crest_param->data_arch module~crest_param->pikaia_oop module~crest_param->stat_mom module~crest_param->surfile module~func_acf->data_arch module~func_acf->fftw3 module~func_acf->miscellaneous module~func_acf->module~crest_param module~func_acf->stat_mom module~skku_profiles->data_arch module~skku_profiles->module~crest_param module~skku_profiles->pikaia_oop module~skku_profiles->sort_arrays module~skku_profiles->stat_mom Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~script~~UsedByGraph module~script script program~main main program~main->module~script Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private  subroutine acf_theo () Function that returns the theoretical acf PARAM%imp_acf. Read more… Arguments None private  subroutine add_nois () Function that returns the starting surface of random heights Read more… Arguments None private  subroutine alloc_tabs () Function that allocates arrays in global variable PARAM Read more… Arguments None private  subroutine apod_acf () Function that apodize the acf to prevent spectral leakage Read more… Arguments None private  subroutine apod_sur () Function that apodize the reference surface for acf calculus purposes Read more… Arguments None private  subroutine calc_acf () Function that returns the autocorrelation function of a surface in PARAM%acf_surf Read more… Arguments None private  subroutine calc_ffh () Function that returns … Read more… Arguments None private  subroutine calc_ord () Function that returns the vector PARAM%order that contains the heights order. Read more… Arguments None private  subroutine calc_res_acf (acf_surf, imp_acf, crit_acf, acf__z, w, h) Function that returns crit_acf the mean absolute difference between theoretical\n and calculated acfs, above z (usually 0.2 as recommended by iso 25178) Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:w, 1:h) :: acf_surf calculated surface acf real(kind=R8), intent(in), dimension(1:w, 1:h) :: imp_acf required surface acf real(kind=R8), intent(out) :: crit_acf mean absolute difference between theoretical and calculated acfs real(kind=R8), intent(in) :: acf__z plane elevation z where correlation lengths are calculated integer(kind=I4), intent(in) :: w surface acf width (points) integer(kind=I4), intent(in) :: h surface acf height (points) private  subroutine calc_z_f () Function that returns PARAM%surf, the surface made of heights with the required statistical\n moments, in the right order. Read more… Arguments None private  subroutine calc_z_i () Function that returns the starting surface of random heights Read more… Arguments None private  subroutine def_size () Geometrical characteristics of the numerical surface Arguments None private  subroutine digi_fil () Function that applies the digital filter to the random heights Read more… Arguments None private  subroutine end_loop () The loop ends here Arguments None private  subroutine end_scri () End of script Arguments None private  subroutine make_msk () Function that reads a digital surf file and turns it into a mask Read more… Arguments None private  subroutine make_scratches () This subroutine initializes a real matrix tab of dimensions nx by ny with ones Read more… Arguments None private  subroutine make_tex () Function that creates a periodic macro-texture: knowing the FFT of an analytical texture Read more… Arguments None private  subroutine nb_procs () Number of concurrent threads Arguments None private  subroutine plt__acf () Function that calculates the mean absolute difference between the desired Acf and\n the one obtained.\n However, the important zone where both should match is above the cut - where the correlation\n lengths are determined. Read more… Arguments None private  subroutine read_img () Function that reads a digital surf file and returns the surface in PARAM%surf Read more… Arguments None public  subroutine read_job (job_file) Function that reads a script file. Keywords are identified and corresponding actions are\n triggered. Read more… Arguments Type Intent Optional Attributes Name character(len=512), intent(in) :: job_file job file with macros to execute private  subroutine repr_img () Function that set parameters for image reproduction Read more… Arguments None private  subroutine save_img (tab) Function that save an array tab as a digital surf file. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(:,:) :: tab a surface to save as a .sur file private  subroutine smooth__ () Function that applies a low-pass filter to the surface PARAM%surf Read more… Arguments None private  subroutine spct_sur (file_spct, apod) Returns the default surface spectrum Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: file_spct txt file containing the surface FFT module logical(kind=I4), intent(in), optional :: apod window applied to surface? private  subroutine sta_loop () Starting the loop Arguments None private  subroutine sta_scri () Start the script reading Arguments None private  subroutine sta_theo () Required statistical moments Arguments None private  subroutine stat_sur () Define surface statistical moments as reference Read more… Arguments None private  subroutine sub_surf () Function that returns the best subsurface from the final surface. Read more… Arguments None","tags":"","loc":"module/script.html"},{"title":"analyses – CREST","text":"Uses crest_param grad_curv stat_mom files func_acf filter asfc morpho abbott anisotropy data_arch fftw3 miscellaneous module~~analyses~~UsesGraph module~analyses analyses abbott abbott module~analyses->abbott anisotropy anisotropy module~analyses->anisotropy asfc asfc module~analyses->asfc data_arch data_arch module~analyses->data_arch fftw3 fftw3 module~analyses->fftw3 files files module~analyses->files filter filter module~analyses->filter grad_curv grad_curv module~analyses->grad_curv miscellaneous miscellaneous module~analyses->miscellaneous module~crest_param crest_param module~analyses->module~crest_param module~func_acf func_acf module~analyses->module~func_acf morpho morpho module~analyses->morpho stat_mom stat_mom module~analyses->stat_mom module~crest_param->data_arch module~crest_param->stat_mom pikaia_oop pikaia_oop module~crest_param->pikaia_oop surfile surfile module~crest_param->surfile module~func_acf->data_arch module~func_acf->fftw3 module~func_acf->miscellaneous module~func_acf->module~crest_param module~func_acf->stat_mom Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~analyses~~UsedByGraph module~analyses analyses module~script script module~script->module~analyses program~main main program~main->module~script Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine surface_analysis (app) The function analyses determinates ISO 25178 parameters of the current surface. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in), optional :: app append results to csv","tags":"","loc":"module/analyses.html"},{"title":"skku_profiles – CREST","text":"Principle If one wishes to analytically generate a height series with the given statistical moments Sk and Ku, a means is to transform a Gaussian series with Johnson’s Translation System .\nBut an alternative means is to use the tangent function: in most of industrial cases, the surface heights can be fitted with a tangent function which limits are the parameters it’s possible to cover a large (Sk, Ku) domain with these 2 parameters: the starting point and the ending point of the tangent height series. close to generates deep pits, and close to generates high pics. the four first statistical moments can be analytically determined, as functions of and the four first statistical moments can be linked to the analytical expressions so that the calculus are very fast an optimization process is used to choose the tangent limits when Sk and Ku are given. The i surface height is expressed as: with and .\nAs explained above the limits are and Statistical moments Transformation of a data set sum into an integral The use of an analytical representation of the heights is of limited interest if the sums, as expressed above, cannot be avoided\nbecause it becomes time consuming for large . So, how will be the statistical moments calculated in a discrete problem? … recalling that Simpson’s method involves such sums and that it links it to the function integral. NB : it is considered that is an even number, so It can be deduced from the figure: As for the borders: As a result: therefore: Extension A formula that links the mean of a sum to a function integral has been determined.\nThe same goes for the standard deviation which is the mean of the sum of squares. The same process applies therefore to the four statistical moments, provided\nthat one is able to analytically determine the integrals (Maxima and Mathematica are useful tools). mu is calculated as explained above when va is calculated, is replaced by with si=1 when Sk is calculated, is replaced by when Ku is calculated, is replaced by Uses crest_param pikaia_oop sort_arrays data_arch stat_mom module~~skku_profiles~~UsesGraph module~skku_profiles skku_profiles data_arch data_arch module~skku_profiles->data_arch module~crest_param crest_param module~skku_profiles->module~crest_param pikaia_oop pikaia_oop module~skku_profiles->pikaia_oop sort_arrays sort_arrays module~skku_profiles->sort_arrays stat_mom stat_mom module~skku_profiles->stat_mom module~crest_param->data_arch module~crest_param->pikaia_oop module~crest_param->stat_mom surfile surfile module~crest_param->surfile Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~skku_profiles~~UsedByGraph module~skku_profiles skku_profiles module~script script module~script->module~skku_profiles program~main main program~main->module~script Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function add_tang (n, deb, fin, alp, bet, mu, si) Function that adds to the series mean the border integrals as explained in the docs Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku integer(kind=I4), intent(in) :: deb first integration point integer(kind=I4), intent(in) :: fin last integration point real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) private  function fitness_skku_anal (n, x) Generic cost function: difference between the imposed statistical moments and those\n obtained. The optimization problem must be turned into a maximization problem (as often\n in the optimization routines). Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n number of unknowns real(kind=R8), intent(in), dimension(1:n) :: x vector of unknowns Return Value real(kind=r8) private  function tang (xi, n, alp, bet, mu, si) Profile function based on the tangent function Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi abscissa integer(kind=I4), intent(in) :: n statistical moment degree, n=3 for sk and n=4 for ku real(kind=R8), intent(in) :: alp offset so that points are in [b1,b2] real(kind=R8), intent(in) :: bet reduction so that points are in [b1,b2] real(kind=R8), intent(in) :: mu numerical mean real(kind=R8), intent(in) :: si numerical standard deviation Return Value real(kind=r8) Subroutines public  subroutine build_heights (vec_out, use_fct_expo, stats_in, lg) Function that returns a set of heights that matches desired statistical moments. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:lg) :: vec_out height vector logical(kind=I4), intent(in) :: use_fct_expo should exponential function rather than tangent function be used? type( moment_stat ), intent(in) :: stats_in input statistical moments integer(kind=I4), intent(in) :: lg length of the height vector private  subroutine calculs_skku_exp3 (bounds, lg, ssk, sku) Function to calculate the skewness and kurtosis of an exponential series. The principle is the same as calculs_skku_tan , however it fits better some particular\n series quite binary (roughly two heights). Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:3) :: bounds interval limits [-(1/bounds(1)-1), +(1/bounds(2)-1)] integer(kind=I4), intent(in) :: lg vec size real(kind=R8), intent(out) :: ssk theoretical Ssk real(kind=R8), intent(out) :: sku theoretical Sku private  subroutine calculs_skku_tan (bounds, lg, ssk, sku) Function to calculate the skewness and kurtosis of a tangent series Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: bounds defines the function limits [-pi/2.(1-bounds(1)), +pi/2.(1-bounds(2)] integer(kind=I4), intent(in) :: lg vec size real(kind=R8), intent(out) :: ssk theoretical Ssk real(kind=R8), intent(out) :: sku theoretical Sku private  subroutine cost_func_skku (me, x, f) Quantify de distance between desired moments and calculated moments Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=R8), intent(in), dimension(:) :: x real(kind=R8), intent(out) :: f private  subroutine pikaia_skku_solver (pik_class, step, xl, xu, nparam, cost, istat, f, xx) This is a refactoring of the PIKAIA unconstrained optimization code from the High Altitude Observatory.\n The original code is public domain and was written by Paul Charbonneau & Barry Knapp. Read more… Arguments Type Intent Optional Attributes Name type( pikaia_class ), intent(inout) :: pik_class PIKAIA class instanciation character(len=4), intent(in) :: step init or solv real(kind=R8), intent(in), dimension(1:nparam) :: xl lower bonds of xx real(kind=R8), intent(in), dimension(1:nparam) :: xu upper bonds of xx integer(kind=I4), intent(in) :: nparam number of parameters private  subroutine cost(me, x, f) Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=R8), intent(in), dimension(:) :: x real(kind=R8), intent(out) :: f integer(kind=I4), intent(out) :: istat real(kind=R8), intent(out) :: f real(kind=R8), intent(out), dimension(1:nparam) :: xx chromosom for PIKAIA private  subroutine profil_theo_trie_1D (tab, lg, x, mx) Function that generates the heights when the function limits have been determined. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:lg) :: tab height vector integer(kind=I4), intent(in) :: lg height vector size real(kind=R8), intent(in), dimension( :  ) :: x unknowns: height function limits type( moment_stat ), intent(out) :: mx resulting statistical moments","tags":"","loc":"module/skku_profiles.html"},{"title":"main – CREST","text":"Uses data_arch crest_param script program~~main~~UsesGraph program~main main data_arch data_arch program~main->data_arch module~crest_param crest_param program~main->module~crest_param module~script script program~main->module~script module~crest_param->data_arch pikaia_oop pikaia_oop module~crest_param->pikaia_oop stat_mom stat_mom module~crest_param->stat_mom surfile surfile module~crest_param->surfile module~script->data_arch module~script->module~crest_param anisotropy anisotropy module~script->anisotropy fftw3 fftw3 module~script->fftw3 files files module~script->files filter filter module~script->filter gnufor gnufor module~script->gnufor miscellaneous miscellaneous module~script->miscellaneous module~analyses analyses module~script->module~analyses module~func_acf func_acf module~script->module~func_acf module~skku_profiles skku_profiles module~script->module~skku_profiles module~script->pikaia_oop sort_arrays sort_arrays module~script->sort_arrays module~script->stat_mom module~script->surfile module~analyses->data_arch module~analyses->module~crest_param module~analyses->anisotropy module~analyses->fftw3 module~analyses->files module~analyses->filter module~analyses->miscellaneous module~analyses->module~func_acf module~analyses->stat_mom abbott abbott module~analyses->abbott asfc asfc module~analyses->asfc grad_curv grad_curv module~analyses->grad_curv morpho morpho module~analyses->morpho module~func_acf->data_arch module~func_acf->module~crest_param module~func_acf->fftw3 module~func_acf->miscellaneous module~func_acf->stat_mom module~skku_profiles->data_arch module~skku_profiles->module~crest_param module~skku_profiles->pikaia_oop module~skku_profiles->sort_arrays module~skku_profiles->stat_mom Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~main~~CallsGraph program~main main proc~prg_surf prg_surf program~main->proc~prg_surf proc~read_job read_job proc~prg_surf->proc~read_job get_unit get_unit proc~read_job->get_unit proc~acf_theo acf_theo proc~read_job->proc~acf_theo proc~add_nois add_nois proc~read_job->proc~add_nois proc~alloc_tabs alloc_tabs proc~read_job->proc~alloc_tabs proc~apod_acf apod_acf proc~read_job->proc~apod_acf proc~apod_sur apod_sur proc~read_job->proc~apod_sur proc~calc_acf calc_acf proc~read_job->proc~calc_acf proc~calc_ffh calc_ffh proc~read_job->proc~calc_ffh proc~calc_ord calc_ord proc~read_job->proc~calc_ord proc~calc_z_f calc_z_f proc~read_job->proc~calc_z_f proc~calc_z_i calc_z_i proc~read_job->proc~calc_z_i proc~def_size def_size proc~read_job->proc~def_size proc~digi_fil digi_fil proc~read_job->proc~digi_fil proc~end_loop end_loop proc~read_job->proc~end_loop proc~end_scri end_scri proc~read_job->proc~end_scri proc~make_msk make_msk proc~read_job->proc~make_msk proc~make_scratches make_scratches proc~read_job->proc~make_scratches proc~make_tex make_tex proc~read_job->proc~make_tex proc~nb_procs nb_procs proc~read_job->proc~nb_procs proc~plt__acf plt__acf proc~read_job->proc~plt__acf proc~read_img read_img proc~read_job->proc~read_img proc~repr_img repr_img proc~read_job->proc~repr_img proc~save_img save_img proc~read_job->proc~save_img proc~smooth__ smooth__ proc~read_job->proc~smooth__ proc~spct_sur spct_sur proc~read_job->proc~spct_sur proc~sta_loop sta_loop proc~read_job->proc~sta_loop proc~sta_scri sta_scri proc~read_job->proc~sta_scri proc~sta_theo sta_theo proc~read_job->proc~sta_theo proc~stat_sur stat_sur proc~read_job->proc~stat_sur proc~sub_surf sub_surf proc~read_job->proc~sub_surf proc~surface_analysis surface_analysis proc~read_job->proc~surface_analysis selectcase selectcase proc~read_job->selectcase str_remove_chars str_remove_chars proc~read_job->str_remove_chars ellipse_acf ellipse_acf proc~acf_theo->ellipse_acf proc~calc_imp_acf calc_imp_acf proc~acf_theo->proc~calc_imp_acf proc~build_heights build_heights proc~add_nois->proc~build_heights scramble scramble proc~add_nois->scramble std_array std_array proc~add_nois->std_array proc~apod_acf->ellipse_acf proc~apod2 apod2 proc~apod_acf->proc~apod2 apod apod proc~apod_sur->apod proc~apod_sur->std_array proc~acf_wiener acf_wiener proc~calc_acf->proc~acf_wiener calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_ffh->calc_fftw3_real_bwd calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_ffh->calc_fftw3_real_fwd calc_moments calc_moments proc~calc_ffh->calc_moments init_order init_order proc~calc_ord->init_order sort_array2 sort_array2 proc~calc_ord->sort_array2 proc~calc_z_f->proc~build_heights proc~calc_z_f->std_array proc~calc_z_i->proc~build_heights proc~calc_z_i->scramble proc~calc_z_i->std_array proc~digi_fil->calc_fftw3_real_bwd proc~digi_fil->calc_fftw3_real_fwd proc~digi_fil->std_array end_fftw3 end_fftw3 proc~end_scri->end_fftw3 calc_fftw3 calc_fftw3 proc~make_tex->calc_fftw3 proc~make_tex->calc_moments omp_get_num_procs omp_get_num_procs proc~nb_procs->omp_get_num_procs proc~plt__acf->get_unit dir_separator dir_separator proc~plt__acf->dir_separator proc~plt__acf->ellipse_acf mkdir mkdir proc~plt__acf->mkdir read_surf read_surf proc~read_img->read_surf proc~repr_img->proc~alloc_tabs proc~repr_img->proc~surface_analysis proc~repr_img->apod proc~repr_img->calc_moments fft_filter fft_filter proc~repr_img->fft_filter init_scal init_scal proc~repr_img->init_scal proc~repr_img->proc~acf_wiener proc~repr_img->scramble proc~repr_img->sort_array2 proc~repr_img->std_array write_surf write_surf proc~repr_img->write_surf proc~save_img->init_scal proc~save_img->write_surf proc~smooth__->fft_filter proc~smooth__->std_array proc~spct_sur->get_unit proc~spct_sur->proc~apod_sur proc~spct_sur->calc_fftw3 trans_corner2center trans_corner2center proc~spct_sur->trans_corner2center random_init random_init proc~sta_scri->random_init proc~stat_sur->proc~apod_sur proc~stat_sur->proc~surface_analysis proc~stat_sur->proc~acf_wiener proc~stat_sur->sort_array2 proc~stat_sur->std_array proc~sub_surf->calc_moments proc~sub_surf->end_fftw3 fftw_plan_with_nthreads fftw_plan_with_nthreads proc~sub_surf->fftw_plan_with_nthreads proc~sub_surf->init_order omp_get_max_threads omp_get_max_threads proc~sub_surf->omp_get_max_threads proc~sub_surf->proc~acf_wiener proc~sub_surf->proc~build_heights proc~sub_surf->proc~calc_imp_acf proc~calc_res_acf calc_res_acf proc~sub_surf->proc~calc_res_acf progress_bar_terminal progress_bar_terminal proc~sub_surf->progress_bar_terminal proc~sub_surf->sort_array2 tab_end_fftw3_real tab_end_fftw3_real proc~sub_surf->tab_end_fftw3_real tab_init_fftw3_real tab_init_fftw3_real proc~sub_surf->tab_init_fftw3_real proc~surface_analysis->get_unit abbott_param abbott_param proc~surface_analysis->abbott_param calc_median calc_median proc~surface_analysis->calc_median proc~surface_analysis->calc_moments calcul_asfc_hermite calcul_asfc_hermite proc~surface_analysis->calcul_asfc_hermite calcul_normales calcul_normales proc~surface_analysis->calcul_normales proc~surface_analysis->ellipse_acf proc~surface_analysis->fft_filter indice_fractal indice_fractal proc~surface_analysis->indice_fractal multiple_anisotropy multiple_anisotropy proc~surface_analysis->multiple_anisotropy peaks_and_pits_curvatures peaks_and_pits_curvatures proc~surface_analysis->peaks_and_pits_curvatures proc~surface_analysis->proc~acf_wiener surf_area surf_area proc~surface_analysis->surf_area topology topology proc~surface_analysis->topology proc~acf_wiener->calc_fftw3_real_bwd proc~acf_wiener->calc_fftw3_real_fwd proc~acf_wiener->trans_corner2center tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~acf_wiener->tab_calc_fftw3_real_bwd tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~acf_wiener->tab_calc_fftw3_real_fwd proc~build_heights->sort_array2 proc~build_heights->std_array proc~pikaia_skku_solver pikaia_skku_solver proc~build_heights->proc~pikaia_skku_solver proc~profil_theo_trie_1d profil_theo_trie_1D proc~build_heights->proc~profil_theo_trie_1d proc~calc_imp_acf->proc~apod2 proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo init pikaia_class%init proc~pikaia_skku_solver->init solve pikaia_class%solve proc~pikaia_skku_solver->solve proc~profil_theo_trie_1d->std_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines subroutine prg_surf () Main function… Read more… Arguments None Source Code program main !$ use omp_lib use script , only : read_job use crest_param use data_arch , only : I4 , R8 implicit none !~ call test_logistic() !~ stop call prg_surf contains subroutine prg_surf () !================================================================================================ !<@note Main function... ! ! - retrieve script (job) file ! - read script ! - run specific functions associated to a script keyword ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 128 ) :: arg_prg character ( len = 512 ) :: job_file integer ( kind = I4 ) :: var_i ! String initialisation arg_prg = repeat ( ' ' , len ( arg_prg )) JOB_FILE = repeat ( ' ' , len ( JOB_FILE )) var_i = 1 call get_command_argument ( var_i , arg_prg ) ! argument one: argument string if ( len_trim ( arg_prg ) == 0 ) then ! if there is no job file, stop write ( TER , * ) 'no job file, stop' stop else job_file = trim ( arg_prg ) endif call read_job ( job_file ) ! the program executes 'prg_repeat' times write ( TER , * ) 'Program completed' return endsubroutine prg_surf endprogram main","tags":"","loc":"program/main.html"},{"title":"mod_func_acf.f90 – CREST","text":"This file depends on sourcefile~~mod_func_acf.f90~~EfferentGraph sourcefile~mod_func_acf.f90 mod_func_acf.f90 sourcefile~mod_crest_param.f90 mod_crest_param.f90 sourcefile~mod_func_acf.f90->sourcefile~mod_crest_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_func_acf.f90~~AfferentGraph sourcefile~mod_func_acf.f90 mod_func_acf.f90 sourcefile~mod_analyses.f90 mod_analyses.f90 sourcefile~mod_analyses.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_script.f90 mod_script.f90 sourcefile~mod_script.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_script.f90->sourcefile~mod_analyses.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_script.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: october, 23 2024 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.2em;\"> !        **Routines for acf calculations** !  </span> module func_acf use data_arch , only : I4 , R8 , HIG_E8 , EPS_R8 , UN , PI_R8 use fftw3 , only : calc_fftw3_real_bwd , calc_fftw3_real_fwd , tab_calc_fftw3_real_bwd , tab_calc_fftw3_real_fwd , fftw_plan_with_nthreads , init_fftw3_real , end_fftw3 , PAD_FFT , extend , & ! SINGL_FFTW_ALLOCATED , NB_THREADS_FFT , FFT_DIM , FFTW_ESTIMATE , FFTW_MEASURE , FFTW_EXHAUSTIVE use stat_mom , only : calc_moments use crest_param , only : PARAM , SPY , TER use stat_mom , only : moment_stat use miscellaneous , only : trans_corner2center , trans_center2corner implicit none private public :: calc_imp_acf , acf_wiener , apod2 contains subroutine acf_wiener ( tab_in , tab_out , w , h , multi_fft ) !================================================================================================ !<@note Function that returns the *acf* of an array. !<  !< \\begin{align*} !<    acf(i,j) &= (z \\ast z)(i,j) = \\sum_{k,l}&#94;{n,n} z(k+1-i,l+1-j)z(k,l)  \\\\ !<    TF(acf)  &= ACF = Z \\cdot Z                                          \\\\ !<    acf      &= TF&#94;{-1}(ACF) = TF&#94;{-1}(Z&#94;2) !< \\end{align*} !<  !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: w !! *2D array length* integer ( kind = I4 ), intent ( in ) :: h !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: tab_in !! *input array* real ( kind = R8 ), intent ( out ), dimension ( 1 : w , 1 : h ) :: tab_out !! *acf of the input array* logical ( kind = I4 ), intent ( in ), optional :: multi_fft !! *run parallel acfs?* integer ( kind = I4 ) :: lo2 , la2 real ( kind = R8 ) :: tmp logical ( kind = I4 ) :: parallel_fft integer ( kind = I4 ), dimension ( 1 : 2 ) :: loc_max complex ( kind = R8 ), dimension (:,:), allocatable :: tab_cmpl real ( kind = R8 ), dimension (:,:), allocatable :: tab_real allocate ( tab_cmpl ( 1 : w , 1 : h ) ) allocate ( tab_real ( 1 : w , 1 : h ) ) ! check for simultaneous fftw calculations !......................................... parallel_fft = . false . if ( present ( multi_fft ) ) parallel_fft = multi_fft !......................................... ! DFFT real -> complex !......................................... if ( parallel_fft ) then call tab_calc_fftw3_real_fwd ( tab_in = tab_in ( 1 : w , 1 : h ), & ! IN tab_ou = tab_cmpl ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN else call calc_fftw3_real_fwd ( tab_in = tab_in ( 1 : w , 1 : h ), & ! IN tab_ou = tab_cmpl ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h , & ! IN planner_flag = FFTW_MEASURE ) ! IN endif !......................................... tab_cmpl ( 1 : w , 1 : h ) = cmplx ( abs ( tab_cmpl ( 1 : w , 1 : h ) ) ** 2 , 0 , kind = R8 ) ! IFFT complex -> real !......................................... if ( parallel_fft ) then call tab_calc_fftw3_real_bwd ( tab_in = tab_cmpl ( 1 : w , 1 : h ), & ! IN tab_ou = tab_real ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN else call calc_fftw3_real_bwd ( tab_in = tab_cmpl ( 1 : w , 1 : h ), & ! IN tab_ou = tab_real ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h , & ! IN planner_flag = FFTW_MEASURE ) ! IN endif !......................................... ! the maximum is placed in the array center !......................................... call trans_corner2center ( tab_in = tab_real ( 1 : w , 1 : h ), & ! IN tab_out = tab_out ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN !......................................... ! the maximum is 1 !......................................... loc_max ( 1 : 2 ) = maxloc ( tab_out ( 1 : w , 1 : h ) ) lo2 = loc_max ( 1 ) la2 = loc_max ( 2 ) tmp = tab_out ( lo2 , la2 ) tab_out ( 1 : w , 1 : h ) = tab_out ( 1 : w , 1 : h ) / tmp !......................................... deallocate ( tab_cmpl ) deallocate ( tab_real ) return endsubroutine acf_wiener real ( kind = R8 ) function autocov_impo ( xi , xj , tau1 , tau2 , alpha , ang ) !================================================================================================ !<@note Function that returns  \\exp \\left(\\alpha \\sqrt{\\left(\\frac{x}{\\tau_1}\\right)&#94;2+ !<                                                        \\left(\\frac{y}{\\tau_2}\\right)&#94;2} !<                                      \\right)  !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: tau1 !! *correlation length along x* real ( kind = R8 ), intent ( in ) :: tau2 !! *correlation length along y* real ( kind = R8 ), intent ( in ) :: alpha !! *log(z)* where *z* is often 0.2 real ( kind = R8 ), intent ( in ) :: xi !! *x coordinate* real ( kind = R8 ), intent ( in ) :: xj !! *y coordinate* real ( kind = R8 ), intent ( in ) :: ang !! *angle* (rad) real ( kind = R8 ) :: x , y , r x = + cos ( ang ) * xi + sin ( ang ) * xj y = - sin ( ang ) * xi + cos ( ang ) * xj r = sqrt ( ( x / tau1 ) ** 2 + ( y / tau2 ) ** 2 ) autocov_impo = exp ( alpha * r ) return endfunction autocov_impo subroutine calc_imp_acf ( long , larg , tau1 , tau2 , alpha , ang , tab_acf , apod ) !================================================================================================ !<@note Function that returns the theoretical autocorrelation function in an array.<br/> !< The autocorrelation function is supposed to be obtained from a real surface which must be periodic !< or nearly periodic (because of the use of FFTs). !< In addition, the surface is supposed to be 0 mean and normalized (\\sigma = 1 ), !< therefore *acf* is zero-mean and normalized so that its max value is 1.<br/> !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface acf width* integer ( kind = I4 ), intent ( in ) :: larg !! *surface acf height* logical ( kind = I4 ), intent ( in ) :: apod !! *apodization?* real ( kind = R8 ), intent ( in ) :: tau1 !! *first correlation length* real ( kind = R8 ), intent ( in ) :: tau2 !! *surface second correlation length* real ( kind = R8 ), intent ( in ) :: alpha !! *parameter that controls the expondential decrease* real ( kind = R8 ), intent ( in ) :: ang !! *acf ellipsis angle* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_acf !! *resulting acf* integer ( kind = I4 ) :: i , j , long2 , larg2 real ( kind = R8 ) :: xi , xj , s , c , coeff real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp ! acf array, centered and normalized !......................................... c = cos ( ang ) ; s = sin ( ang ) long2 = long / 2 + 1 larg2 = larg / 2 + 1 do j = 1 , larg do i = 1 , long xi = real ( i - long2 , kind = R8 ) * PARAM % surf_dx ! dimensioned coordinate x xj = real ( j - larg2 , kind = R8 ) * PARAM % surf_dy ! dimensioned coordinate y tab_acf ( i , j ) = autocov_impo ( xi = xi , & ! IN xj = xj , & ! IN tau1 = tau1 , & ! IN tau2 = tau2 , & ! IN alpha = alpha , & ! IN ang = ang ) ! IN enddo enddo !......................................... ! For long correlation lengths and roughness orientation, the acf is far from periodic ! Furthermore, far from the center, respecting the acf becomes less important. A windowing ! can be determined so that at a given distance from the center, the acf is lessened. !......................................... if ( apod ) then allocate ( tab_tmp ( 1 : long , 1 : larg ) ) coeff = 0.4 * PARAM % surf_width * c / tau1 ! along the primary axis (longest correlation length) the acf is reduce beyond ! 0.4 * image width * cos(ang) ! (0.4 * image width is less than half width) call apod2 ( tab_in = tab_acf ( 1 : long , 1 : larg ), & ! IN tab_out = tab_tmp ( 1 : long , 1 : larg ), & ! OUT long = long , & ! IN larg = larg , & ! IN tau1 = coeff * tau1 , & ! IN tau2 = coeff * tau2 , & ! IN ang = ang ) ! IN tab_acf ( 1 : long , 1 : larg ) = tab_tmp ( 1 : long , 1 : larg ) deallocate ( tab_tmp ) endif !......................................... ! acf centered tab_acf ( 1 : long , 1 : larg ) = tab_acf ( 1 : long , 1 : larg ) - sum ( tab_acf ( 1 : long , 1 : larg ) ) / ( long * larg ) ! acf scaled (maximum = 1) tab_acf ( 1 : long , 1 : larg ) = tab_acf ( 1 : long , 1 : larg ) / tab_acf ( long2 , larg2 ) return endsubroutine calc_imp_acf subroutine apod2 ( tab_in , tab_out , long , larg , tau1 , tau2 , ang ) !================================================================================================ !<@note Function that returns an apodized array.<br/> !< To prevent gaps from appearing after FFT (because of non periodic waves), the surface must !< be transformed, but not too much. Here a modified Tukey window is determined. The starting !< surface is not modified below the \"correlation lengths\". Above the correlation lengths, a !< smooth decrease is forced with a cosine squared. !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface acf length* integer ( kind = I4 ), intent ( in ) :: larg !! *surface acf width* real ( kind = R8 ), intent ( in ) :: tau1 !! *surface first correlation length* real ( kind = R8 ), intent ( in ) :: tau2 !! *surface second correlation length* real ( kind = R8 ), intent ( in ) :: ang !! *ellipsis angle* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *input acf* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *apodized acf* real ( kind = R8 ) :: r2 , c0 , s0 , rd , rr , theta , theta_diag , x , y , t , a_min , sum_inn , sum_tab , sum_int integer ( kind = I4 ) :: i , j , k , long2 , larg2 , npt_out , n real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp ! first bissector angle (rad) theta_diag = atan2 ( PARAM % surf_height , PARAM % surf_width ) ! sine and cosine of the ellipsis angle c0 = cos ( ang ) ; s0 = sin ( ang ) long2 = long / 2 larg2 = larg / 2 if ( long == 2 * ( long / 2 ) ) long2 = long / 2 + 1 if ( larg == 2 * ( larg / 2 ) ) larg2 = larg / 2 + 1 tab_out ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) rr = 1.e6_R8 do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) cycle ! The correlation length is exceeded. ! The angle corresponding to the position (i,j) is calculated theta = atan2 ( y , x ) ; if ( theta < 0. ) theta = theta + 2 * Pi_R8 t = tan ( theta ) ! According the location of (i,j) (right, top, left or bottom) the line that begin at the surface center, passing by (i,j), ! ends on one of the four borders. if ( theta > 2 * Pi_R8 - theta_diag . or . theta <= + theta_diag ) then ; x = ( long - long2 ) * PARAM % surf_dx ; y = x * t ; endif if ( theta > + theta_diag . and . theta <= PI_R8 - theta_diag ) then ; y = ( larg - larg2 ) * PARAM % surf_dy ; x = y / t ; endif if ( theta > PI_R8 - theta_diag . and . theta <= PI_R8 + theta_diag ) then ; x = ( 1 - long2 ) * PARAM % surf_dx ; y = x * t ; endif if ( theta > PI_R8 + theta_diag . and . theta <= 2 * Pi_R8 - theta_diag ) then ; y = ( 1 - larg2 ) * PARAM % surf_dy ; x = y / t ; endif ! The same distance as above is calculated, from the center to the surface edge, then ... rd = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 rr = min ( rr , sqrt ( rd ) ) enddo enddo rr = 0.99 * rr sum_inn = 0 sum_tab = 0 sum_int = 0 npt_out = 0 n = 2 do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) then sum_inn = sum_inn + tab_in ( i , j ) cycle endif r2 = sqrt ( r2 ) if ( r2 >= rr ) then npt_out = npt_out + 1 cycle endif ! ... the modified Tuckey window can be determined. sum_tab = sum_tab + ( cos ( 0.5_R8 * PI_R8 * ( r2 - 1. ) / ( rr - 1. ) ) ** n ) * tab_in ( i , j ) sum_int = sum_int + ( r2 - 1. ) / ( rr - 1. ) enddo enddo a_min = - ( sum_inn + sum_tab ) / ( npt_out + sum_int ) do j = 1 , larg do i = 1 , long x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 ! Below the correlation length, no transformation if ( r2 <= 1._R8 ) cycle r2 = sqrt ( r2 ) if ( r2 >= rr ) then tab_out ( i , j ) = a_min cycle endif ! ... the modified Tuckey window can be determined. tab_out ( i , j ) = ( cos ( 0.5_R8 * PI_R8 * ( r2 - 1. ) / ( rr - 1. ) ) ** n ) * tab_in ( i , j ) + a_min * ( r2 - 1. ) / ( rr - 1. ) enddo enddo allocate ( tab_tmp ( 1 : long , 1 : larg ) ) do k = 1 , 10 tab_tmp ( 1 : long , 1 : larg ) = tab_out ( 1 : long , 1 : larg ) do j = 1 + 1 , larg - 1 do i = 1 + 1 , long - 1 x = ( i - long2 ) * PARAM % surf_dx y = ( j - larg2 ) * PARAM % surf_dy ! Distance as expressed in the theoretical acf. When r2 is 1., the acf is 0.2. r2 = ( ( + c0 * x + s0 * y ) / tau1 ) ** 2 + & ! ( ( - s0 * x + c0 * y ) / tau2 ) ** 2 r2 = sqrt ( r2 ) if ( r2 <= 0.98_R8 . or . ( r2 >= 1.02_R8 . and . r2 <= 0.98_R8 * rr ) . or . r2 >= 1.02_R8 * rr ) cycle tab_out ( i , j ) = ( 2 * tab_tmp ( i , j ) + tab_tmp ( i + 1 , j ) + tab_tmp ( i - 1 , j ) + & ! tab_tmp ( i , j + 1 ) + tab_tmp ( i , j - 1 ) + ( tab_tmp ( i + 1 , j - 1 ) + tab_tmp ( i - 1 , j - 1 ) + & ! tab_tmp ( i - 1 , j + 1 ) + tab_tmp ( i + 1 , j + 1 ) ) / sqrt ( 2._R8 ) ) / ( 6. + 4. / sqrt ( 2._R8 ) ) enddo enddo enddo deallocate ( tab_tmp ) return endsubroutine apod2 endmodule func_acf","tags":"","loc":"sourcefile/mod_func_acf.f90.html"},{"title":"mod_crest_param.f90 – CREST","text":"Files dependent on this one sourcefile~~mod_crest_param.f90~~AfferentGraph sourcefile~mod_crest_param.f90 mod_crest_param.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_script.f90 mod_script.f90 sourcefile~main.f90->sourcefile~mod_script.f90 sourcefile~mod_analyses.f90 mod_analyses.f90 sourcefile~mod_analyses.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_func_acf.f90 mod_func_acf.f90 sourcefile~mod_analyses.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_func_acf.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_script.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_script.f90->sourcefile~mod_analyses.f90 sourcefile~mod_script.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_skku_profiles.f90 mod_skku_profiles.f90 sourcefile~mod_script.f90->sourcefile~mod_skku_profiles.f90 sourcefile~mod_skku_profiles.f90->sourcefile~mod_crest_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: october, 23 2024 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.2em;\"> !        **Global variables and types** !  </span> module crest_param use data_arch , only : I4 , R8 use stat_mom , only : moment_stat use pikaia_oop , only : pikaia_class use surfile , only : SCALE_SURF implicit none public integer ( kind = I4 ) :: JOB !! *JOB file: script* integer ( kind = I4 ) :: SPY !! *SPY file* integer ( kind = I4 ) :: STA !! *result file* integer ( kind = I4 ), parameter :: TER = 6 !! *terminal output* integer ( kind = I4 ) :: line_read , save_line_read !! *line number in the script\" integer ( kind = I4 ) :: i_iter , nb_iter !! *current and number of iterations* type ( SCALE_SURF ) :: scale_img !! *.SUR surface properties* type acf_param real ( kind = R8 ) :: cl1 !! *correlation principal length at z=acf__z* real ( kind = R8 ) :: cl2 !! *correlation secondary length at z=acf__z* real ( kind = R8 ) :: cut !! *acf cutting plane z, for correlation lengths determination* real ( kind = R8 ) :: ang !! *roughness orientation* endtype acf_param type param_crest real ( kind = R8 ), allocatable , dimension (:) :: vect_h !! *vector used to store the heights that meet the stat moments* real ( kind = R8 ), allocatable , dimension (:,:) :: surf !! *surface array* real ( kind = R8 ), allocatable , dimension (:,:) :: surf_copy !! *surface array copy* real ( kind = R8 ), allocatable , dimension (:,:) :: surf_LF !! *surface low frequencies* real ( kind = R8 ), allocatable , dimension (:,:) :: surf_HF !! *surface high frequencies* real ( kind = R8 ), allocatable , dimension (:,:) :: imp_acf !! *imposed autocorrelation* real ( kind = R8 ), allocatable , dimension (:,:) :: fhi !! *digital filter* real ( kind = R8 ), allocatable , dimension (:,:) :: acf_surf !! *calculated autocorrelation* integer ( kind = I4 ), allocatable , dimension (:) :: order !! *vector that stores heights order* logical ( kind = I4 ), allocatable , dimension (:,:) :: surf_msk !! *surface high frequencies* type ( MOMENT_STAT ) :: m_ini !! *surface to be reproduced stat moments* type ( MOMENT_STAT ) :: m__LF !! *surface to be reproduced stat moments, low  frequencies* type ( MOMENT_STAT ) :: m__HF !! *surface to be reproduced stat moments, high frequencies* type ( MOMENT_STAT ) :: m_end !! *final stat moments* type ( MOMENT_STAT ) :: m_inp !! *input stat moments for genetic algo optimizer* type ( MOMENT_STAT ) :: m_stt !! *starting stat moments* type ( pikaia_class ) :: pik_class !! **PIKAIA** *class instanciation* type ( ACF_PARAM ) :: orig_surf !! *original surface ACF properties* type ( ACF_PARAM ) :: curr_surf !! *current  surface ACF properties* integer ( kind = I4 ) :: func_gen !! *mathematical function used to generate the heights* integer ( kind = I4 ) :: nparam !! *number of parameters for the mathematical function* integer ( kind = I4 ) :: nb_threads !! *number of concurrent threads* integer ( kind = I4 ) :: width !! *surface nb points along x* integer ( kind = I4 ) :: height !! *surface nb points along y* integer ( kind = I4 ) :: npts !! *surface nb points* integer ( kind = I4 ) :: sub_width !! *subsurface nb points along x* integer ( kind = I4 ) :: sub_height !! *subsurface nb points along y* integer ( kind = I4 ) :: sub_npts !! *subsurface nb points* logical ( kind = I4 ) :: reajust_skku !! *if Ssk**2 +1 > Sku, modify Sku* logical ( kind = I4 ) :: periodic !! *is the surface periodic?* logical ( kind = I4 ) :: apod !! *apodize imposed acf?* logical ( kind = I4 ) :: calc_mstt !! *calculate starting moments?* logical ( kind = I4 ) :: calc_zf !! *calculate final heights?* real ( kind = R8 ) :: cutoff !! *Gaussian filter cutoff* real ( kind = R8 ) :: surf_width !! *surface width (m)* real ( kind = R8 ) :: surf_height !! *surface height (m)* real ( kind = R8 ) :: sub_surf_width !! *subsurface width (m)* real ( kind = R8 ) :: sub_surf_height !! *subsurface height (m)* real ( kind = R8 ) :: surf_dx !! *surface increment along x (m)* real ( kind = R8 ) :: surf_dy !! *surface increment along y (m)* real ( kind = R8 ) :: crt_acf !! *acf criterion: mean absolute difference between imposed and calculated acf allowed* real ( kind = R8 ) :: res_acf !! *store mean absolute difference between imposed and calculated acf* endtype param_crest type ( param_crest ) :: PARAM integer ( kind = I4 ), parameter :: FCT_TANG = 1 !! *tangent function for height generation* integer ( kind = I4 ), parameter :: FCT_EXPO = 2 !! *exponential function for height generation* endmodule crest_param","tags":"","loc":"sourcefile/mod_crest_param.f90.html"},{"title":"mod_script.f90 – CREST","text":"This file depends on sourcefile~~mod_script.f90~~EfferentGraph sourcefile~mod_script.f90 mod_script.f90 sourcefile~mod_analyses.f90 mod_analyses.f90 sourcefile~mod_script.f90->sourcefile~mod_analyses.f90 sourcefile~mod_crest_param.f90 mod_crest_param.f90 sourcefile~mod_script.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_func_acf.f90 mod_func_acf.f90 sourcefile~mod_script.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_skku_profiles.f90 mod_skku_profiles.f90 sourcefile~mod_script.f90->sourcefile~mod_skku_profiles.f90 sourcefile~mod_analyses.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_analyses.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_func_acf.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_skku_profiles.f90->sourcefile~mod_crest_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_script.f90~~AfferentGraph sourcefile~mod_script.f90 mod_script.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_script.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: october, 23 2024 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.2em;\"> !        **Routines to decode the script** !  </span> module script !$ use omp_lib use data_arch , only : I4 , R4 , R8 , UN , PI_R8 , EPS_R8 use skku_profiles , only : build_heights use crest_param , only : PARAM , JOB , SPY , STA , TER , FCT_TANG , FCT_EXPO , LINE_READ , SAVE_LINE_READ , I_ITER , NB_ITER , SCALE_IMG use stat_mom , only : moment_stat , calc_moments , scramble , std_array use sort_arrays , only : sort_array2 , init_order use miscellaneous , only : get_unit , trans_corner2center , trans_center2corner , progress_bar_terminal use surfile , only : init_scal , read_surf , write_surf , SCALE_SURF use func_acf , only : calc_imp_acf , acf_wiener , apod2 use fftw3 , only : tab_init_fftw3_real , calc_fftw3_real_bwd , calc_fftw3_real_fwd , fftw_plan_with_nthreads , end_fftw3 , tab_end_fftw3_real , extend , apod , & ! SINGL_FFTW_ALLOCATED , NB_THREADS_FFT , FFT_DIM , FFTW_ESTIMATE , FFTW_MEASURE , FFTW_EXHAUSTIVE , BACKWARD , FORWARD , calc_fftw3 use filter , only : fft_filter , soften use gnufor , only : write_xyy_plots , run_gnuplot use anisotropy , only : ellipse_acf use pikaia_oop , only : pikaia_class use files , only : str_remove_chars , dir_separator , mkdir use analyses , only : surface_analysis implicit none private public :: read_job contains subroutine read_job ( job_file ) !================================================================================================ !<@note Function that reads a script file. Keywords are identified and corresponding actions are !< triggered. !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 512 ), intent ( in ) :: job_file !! *job file with macros to execute* integer ( kind = I4 ) :: vide character ( len = 512 ) :: keyword logical ( kind = I4 ) :: first ! script file call get_unit ( JOB ) open ( unit = JOB , file = trim ( job_file ), status = 'old' ) call check_empty_lines () ! witness file call get_unit ( SPY ) open ( unit = SPY , file = \"out/spy.txt\" , status = 'unknown' ) LINE_READ = 0 first = . true . ! determine if calc_z_f has been already used ! default function used: the tangent function PARAM % func_gen = FCT_TANG ! default is 2 bounds when generating profiles PARAM % nparam = 2 PARAM % calc_mstt = . true . PARAM % calc_zf = . true . ! default cutting plane for correlation lengths PARAM % orig_surf % cut = 0.5 PARAM % curr_surf % cut = 0.5 o : do keyword = repeat ( ' ' , len ( keyword ) ) read ( JOB , * , iostat = vide ) keyword ; LINE_READ = LINE_READ + 1 ! remove unwanted characters from keyword keyword = str_remove_chars ( string = trim ( keyword ), chars = '- # *' ) write ( SPY , '(a6,I4.4,a)' ) \"line: \" , LINE_READ , ' ' , trim ( keyword ) selectcase ( keyword ( 1 : 8 ) ) case ( 'ACF_THEO' ) ! desired acf call acf_theo () case ( 'ADD_NOIS' ) ! add noise to current surface call add_nois () case ( 'ALLOCATE' ) ! allocate tabs in PARAM type call alloc_tabs () case ( 'ANALYSIS' ) call surface_analysis () case ( 'APOD_ACF' ) ! apodize acf call apod_acf () case ( 'APOD_SUR' ) ! apodize surface call apod_sur () case ( 'CALC_ACF' ) ! determine the surface acf call calc_acf () case ( 'CALC_FFH' ) ! deigital filter call calc_ffh () case ( 'CALC_ORD' ) ! determine height order call calc_ord () case ( 'CALC_Z_F' ) ! final heights call calc_z_f () case ( 'CALC_Z_I' ) ! starting heights call calc_z_i () case ( 'DEF_SIZE' ) ! image size call def_size () case ( 'DIGI_FIL' ) ! apply digital filter call digi_fil () case ( 'END_LOOP' ) ! loop end call end_loop () case ( 'END_SCRI' ) ! close the script reading call end_scri () exit o case ( 'MAKE_MSK' ) ! turn image into mask call make_msk () case ( 'MAKE_SCR' ) ! make secratches call make_scratches () case ( 'MAKE_TEX' ) ! build a texture call make_tex () case ( 'NB_PROCS' ) ! number of threads call nb_procs () case ( 'PLT__ACF' ) ! print the correlation graphs and/or determine ! if the stop criterion is reached. call plt__acf () case ( 'READ_PRF' ) ! read image call read_img () case ( 'REPR_IMG' ) ! reproduce image call repr_img () case ( 'SAVE_ACF' ) ! save the acf surface if ( sum ( PARAM % imp_acf ) == 0 ) then call save_img ( tab = PARAM % acf_surf ) ! IN: real acf else call save_img ( tab = PARAM % imp_acf ) ! IN: wanted acf endif case ( 'SAVE_PRF' ) ! save image call save_img ( tab = PARAM % surf ) ! IN: surface to save case ( 'SMOOTH__' ) ! low-pass filter call smooth__ () case ( 'SPCT_SUR' ) ! surface spectrum frequencies call spct_sur () case ( 'STA_LOOP' ) ! loop start call sta_loop () case ( 'STA_SCRI' ) ! start script call sta_scri () case ( 'STA_THEO' ) ! desired stat moments call sta_theo () case ( 'STAT_SUR' ) ! surface moments as reference call stat_sur () case ( 'SUB_SURF' ) ! extract the best surface call sub_surf () endselect enddo o close ( JOB ) contains subroutine check_empty_lines () !! Check for empty lines in the script implicit none do read ( JOB , '(A)' , iostat = vide ) keyword if ( vide < 0 ) then rewind ( JOB ) return endif if ( len_trim ( keyword ) == 0 ) stop 'Empty line in script file' enddo return endsubroutine check_empty_lines endsubroutine read_job subroutine alloc_tabs () !================================================================================================ !<@note Function that allocates arrays in global variable [[PARAM]] !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h w = PARAM % width h = PARAM % height allocate ( PARAM % fhi ( 1 : w , 1 : h ) ) ; PARAM % fhi ( 1 : w , 1 : h ) = 0 ! *digital filter* allocate ( PARAM % imp_acf ( 1 : w , 1 : h ) ) ; PARAM % imp_acf ( 1 : w , 1 : h ) = 0 ! *imposed autocorrelation* allocate ( PARAM % order ( 1 : w * h ) ) ; PARAM % order ( 1 : w * h ) = 0 ! *vector that stores heights order* allocate ( PARAM % vect_h ( 1 : w * h ) ) ; PARAM % vect_h ( 1 : w * h ) = 0 ! *vector used to store the heights that meet the stat moments* allocate ( PARAM % acf_surf ( 1 : w , 1 : h ) ) ; PARAM % acf_surf ( 1 : w , 1 : h ) = 0 ! *calculated autocorrelation* allocate ( PARAM % surf_copy ( 1 : w , 1 : h ) ) ; PARAM % surf_copy ( 1 : w , 1 : h ) = 0 ! *surface array copy* allocate ( PARAM % surf_LF ( 1 : w , 1 : h ) ) ; PARAM % surf_LF ( 1 : w , 1 : h ) = 0 ! *surface low frequencies* allocate ( PARAM % surf_HF ( 1 : w , 1 : h ) ) ; PARAM % surf_HF ( 1 : w , 1 : h ) = 0 ! *surface high frequencies* return endsubroutine alloc_tabs subroutine plt__acf () !================================================================================================ !<@note Function that calculates the mean absolute difference between the desired Acf and !< the one obtained. !< However, the important zone where both should match is above the cut - where the correlation !< lengths are determined. !< !< If the mean absolute difference is below the criterion, the loops to improve the acf are !< stopped. !< !< The function can also plot the acfs. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: i , w , h , mw , mh , uplot , ll logical ( kind = I4 ) :: is_x , is_y real ( kind = R8 ) :: lim_crit_acf , crit_acf , dxy , l1 , l2 character ( len = 512 ) :: plt_acf real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp real ( kind = R8 ), dimension ( 1 : 8 ) :: res read ( JOB , * ) lim_crit_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , \"Acf criterion \" , lim_crit_acf read ( JOB , * ) plt_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , trim ( plt_acf ) PARAM % crt_acf = lim_crit_acf ! mean absolute difference limit w = PARAM % width h = PARAM % height ! Mean absolute difference between the calculated acf and the theoretical acf !................................................................................... if ( PARAM % curr_surf % cut > 0 ) then allocate ( tab_tmp ( 1 : w , 1 : h ) ) tab_tmp ( 1 : w , 1 : h ) = 0 where ( PARAM % imp_acf > PARAM % curr_surf % cut ) tab_tmp = abs ( PARAM % acf_surf - PARAM % imp_acf ) crit_acf = 100 * sum ( tab_tmp ( 1 : w , 1 : h ) ) / count ( tab_tmp ( 1 : w , 1 : h ) > 0 ) PARAM % res_acf = crit_acf deallocate ( tab_tmp ) write ( TER , * ) \"acf difference \" , crit_acf write ( SPY , * ) 'acf difference ' , crit_acf ! if the acf criterion is reached, the loops stop: a means is to modify the max number ! of loops, so that the main loop is exited. if ( lim_crit_acf > 0. . and . lim_crit_acf > crit_acf ) NB_ITER = 1 endif !................................................................................... ! Graphs? !................................................................................... ! if 'x' is present, plot the graph along the principal axis ! if 'y' is present, plot the graph along the secondary axis is_x = ( index ( trim ( plt_acf ), 'x' ) /= 0 ) is_y = ( index ( trim ( plt_acf ), 'y' ) /= 0 ) if ( . not .( is_x . or . is_y ) ) return mw = w / 2 + 1 mh = h / 2 + 1 call ellipse_acf ( tabin = PARAM % acf_surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN p_acv = res ( 1 : 8 ), & ! OUT -> correlation lengths cut = PARAM % curr_surf % cut , & ! IN  -> z cut plane scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN  -> lags along x and y omp = . true . ) ! IN  -> use multithread? write ( TER , * ) res ( 1 : 2 ), res ( 4 ) write ( SPY , * ) 'acf lengths and roughness orientation ' , res ( 1 : 2 ), res ( 4 ) ! parameters for the plot ll = 2 * min ( mw , mh ) - 3 dxy = sqrt ( PARAM % surf_dx ** 2 + PARAM % surf_dy ** 2 ) call get_unit ( uplot ) if ( is_x ) call graph ( axis = 1 ) if ( is_y ) call graph ( axis = 2 ) contains subroutine graph ( axis ) !================================================================================================ !<@note Function that plots the graphs to compare the ACF along the primary and/or secondary axes. !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: axis !! *1 or 2 for primary or secondary axis* integer ( kind = I4 ) :: exit_status logical ( kind = I4 ) :: dir_exists character ( len = 256 ) :: file_acf , file_gpl , title , cwd character ( len = 003 ) :: xlab character ( len = 1 ) :: os_sep real ( kind = R8 ) :: angle real ( kind = R8 ), allocatable , dimension (:) :: profile_acf_surf , profile_imp_acf allocate ( profile_acf_surf ( 1 : ll ) ) allocate ( profile_imp_acf ( 1 : ll ) ) ! if \"out/gpl\" does not exist, create it inquire ( file = \"out/gpl\" , exist = dir_exists ) if ( . not . dir_exists ) then os_sep = dir_separator () call getcwd ( cwd ) call mkdir ( wkd = trim ( cwd ), directory = \"out/gpl\" , sep = os_sep , exit_status = exit_status ) endif if ( axis == 1 ) then angle = PARAM % curr_surf % ang file_acf = 'out/gpl/acfx.txt' file_gpl = 'out/gpl/acfx.gpl' title = '\"ACF comparison along primary axis X\"' xlab = '\"X\"' else angle = PARAM % curr_surf % ang + 9 0. file_acf = 'out/gpl/acfy.txt' file_gpl = 'out/gpl/acfy.gpl' title = '\"ACF comparison along secondary axis Y\"' xlab = '\"Y\"' endif ! extract the ACF profile along a particular direction call profile_at_angle ( tab = PARAM % acf_surf ( 1 : w , 1 : h ), profile = profile_acf_surf ( 1 : ll ), theta = angle ) call profile_at_angle ( tab = PARAM % imp_acf ( 1 : w , 1 : h ), profile = profile_imp_acf ( 1 : ll ), theta = angle ) open ( uplot , file = trim ( file_acf )) write ( uplot , * ) 'X' , '\"calculated acf\"' , '\"theoretical acf\"' do i = 1 , ll write ( uplot , * ) ( i - ll / 2 ) * dxy , real ( profile_acf_surf ( i ), kind = R4 ), & ! real ( profile_imp_acf ( i ), kind = R4 ) ! if ( i - ll / 2 < 0 ) then if ( profile_acf_surf ( i ) < PARAM % curr_surf % cut . and . profile_acf_surf ( i + 1 ) > PARAM % curr_surf % cut ) l1 = ( i - ll / 2 ) * dxy endif if ( i - ll / 2 > 0 . and . i < ll ) then if ( profile_acf_surf ( i ) > PARAM % curr_surf % cut . and . profile_acf_surf ( i + 1 ) < PARAM % curr_surf % cut ) l2 = ( i - ll / 2 ) * dxy endif enddo close ( uplot ) open ( uplot , file = trim ( file_gpl )) write ( uplot , '(a)' ) 'set title ' // trim ( title ) write ( uplot , '(a)' ) 'set xlabel ' // trim ( xlab ) write ( uplot , '(a)' ) 'set ylabel \"ACF\"' write ( uplot , '(a,f4.2,a,f5.2,a)' ) \"set arrow from graph 0, first \" , PARAM % curr_surf % cut , & ! \" to graph 1, first \" , PARAM % curr_surf % cut , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2,a)' ) \"set arrow from \" , l1 , \", graph 0 to \" , & ! l1 , \",\" , PARAM % curr_surf % cut , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2,a)' ) \"set arrow from \" , l2 , \", graph 0 to \" , & ! l2 , \",\" , PARAM % curr_surf % cut , ' nohead lc rgb \"#000000\" front' ! write ( uplot , '(a,E8.2,a,E8.2,a,f5.2)' ) 'set label \"L1 = ' , res ( axis ), '\" at ' , l2 , ',' , PARAM % curr_surf % cut + 0.1 write ( uplot , '(a,i2,a)' ) 'plot \"' // trim ( file_acf ) // '\" using 1:2 with lines title \"acf real surface\", \"' // trim ( file_acf ) // '\" using 1:3 with lines title \"theoretical acf\"' write ( uplot , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( uplot , '(a)' ) 'q' close ( uplot ) call system ( 'gnuplot \"' // trim ( file_gpl ) // '\"' ) deallocate ( profile_acf_surf ) deallocate ( profile_imp_acf ) return endsubroutine graph subroutine profile_at_angle ( tab , profile , theta ) !================================================================================================ !<@note Function that extract the ACF profile along a particular direction !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: tab real ( kind = R8 ), intent ( in ) :: theta real ( kind = R8 ), intent ( out ), dimension ( 1 : ll ) :: profile integer ( kind = I4 ) :: p , nx , ny real ( kind = R8 ) :: r , x , y , xb , yb , xm , ym , xp , yp , h1 , h2 , h3 , h4 , hh do p = - ll / 2 , ll / 2 !  identifying a point on the diameter r = p !  corresponding algebraic radius !  projection on x and y of the point marked by its radius and angle !  by taking the lower integer, we have the number of the bottom row and left-hand column of the rectangle !  the remainder (x-nx) represents the abscissa of the point in the rectangle with sides=1 !  the 0.9999 coefficient is used to avoid falling right on an existing point x = mw + r * cos ( theta * PI_R8 / 180 ) * 0.9999_R8 ; nx = floor ( x ) ; xb = x - nx y = mh + r * sin ( theta * PI_R8 / 180 ) * 0.9999_R8 ; ny = floor ( y ) ; yb = y - ny xm = UN - xb ; xp = xb ym = UN - yb ; yp = yb if ( nx + 1 <= w . and . ny + 1 <= h . and . & ! nx >= 1 . and . ny >= 1 ) then ! attention r may be greater than lo2 or la2 h1 = tab ( nx , ny ) h2 = tab ( nx + 1 , ny ) h3 = tab ( nx + 1 , ny + 1 ) h4 = tab ( nx , ny + 1 ) hh = h1 * xm * ym + & ! h2 * xp * ym + & ! h3 * xp * yp + & ! h4 * xm * yp ! profile ( p + ll / 2 + 1 ) = hh endif enddo return endsubroutine profile_at_angle endsubroutine plt__acf subroutine calc_acf () !================================================================================================ !<@note Function that returns the autocorrelation function of a surface in PARAM%acf_surf !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h logical ( kind = I4 ) :: set_acf ! if set_acf is true, the acf becomes the prescribed one read ( JOB , * ) set_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , \"Set ACF \" , set_acf w = PARAM % width h = PARAM % height call acf_wiener ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! IN tab_out = PARAM % acf_surf ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h ) ! IN if ( set_acf ) PARAM % imp_acf ( 1 : w , 1 : h ) = PARAM % acf_surf ( 1 : w , 1 : h ) return endsubroutine calc_acf subroutine sta_loop () !! Starting the loop implicit none read ( JOB , * ) NB_ITER ; LINE_READ = LINE_READ + 1 write ( SPY , * ) LINE_READ , I_ITER , '/' , NB_ITER I_ITER = 1 ! the account begins SAVE_LINE_READ = LINE_READ ! remember where to go when rewinding return endsubroutine sta_loop subroutine end_loop () !! The loop ends here implicit none integer ( kind = I4 ) :: i_ligne if ( I_ITER < NB_ITER ) then rewind ( JOB ) ! the maximum number of loops is not reached, ! go to the begining of the script else I_ITER = NB_ITER ! the maximum number of loops is reached return endif ! return to the beginning of the loop LINE_READ = SAVE_LINE_READ do i_ligne = 1 , SAVE_LINE_READ read ( JOB , * ) enddo I_ITER = I_ITER + 1 return endsubroutine end_loop subroutine sub_surf () !================================================================================================ !<@note Function that returns the best subsurface from the final surface. !< !< We are here because a non periodic resulting surface is required. To do that, a wider !< periodic surface is created, and it matches the required moments and acf. !< !< However, sub-sampling the surface into a smaller surface that matches the required size !< will result in degraded moments and acf. Hence, several locations are tested to find the !< best subsurface. !< !< Note that the right moments can always be obtained by substitution, respecting the order of heights. !< However, the acf will be slightly impacted. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: i , w , h , l , we , he , dw , dh , ndw , ndh , idw , jdh , ib , ie , jb , je , best_idw , best_jdh integer ( kind = I4 ) :: n_seek , inc_dw , inc_dh , nn_res , res_ratio real ( kind = R8 ) :: best_acf , res_acf , size_ratio character ( len = 100 ) :: text type ( MOMENT_STAT ) :: m_res integer ( kind = I4 ), dimension ( 1 : 2 ) :: best_ind integer ( kind = I4 ), allocatable , dimension (:) :: order_tmp real ( kind = R8 ), allocatable , dimension (:,:) :: sav_surf , surf_tmp , acf_tmp , tab_res_acf real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp read ( JOB , * ) n_seek ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"n_seek  \" , n_seek ! n_seek is the number of subsurfaces explored if ( PARAM % periodic ) return ! reset the FFTW configuration because from now on, the acf will be calculated on smaller surfaces call end_fftw3 () ! extended surface size we = PARAM % width he = PARAM % height allocate ( sav_surf ( 1 : we , 1 : he ) ) ! save the extended surface sav_surf ( 1 : we , 1 : he ) = PARAM % surf ( 1 : we , 1 : he ) ! reset previous arrays deallocate ( PARAM % surf ) deallocate ( PARAM % imp_acf ) deallocate ( PARAM % acf_surf ) call fftw_plan_with_nthreads ( nthreads = 1 ) NB_THREADS_FFT = omp_get_max_threads () ! the new image size is the one of the subsurface, because it is the size defined by the user w = PARAM % sub_width h = PARAM % sub_height l = PARAM % sub_npts call tab_init_fftw3_real ( long = w , larg = h , plan_flag = FFTW_MEASURE ) PARAM % width = w PARAM % height = h PARAM % npts = l allocate ( PARAM % surf ( 1 : w , 1 : h ) ) allocate ( PARAM % acf_surf ( 1 : w , 1 : h ) ) ! build a smaller set of heights that match the required moments call build_heights ( vec_out = PARAM % vect_h ( 1 : l ), & ! use_fct_expo = ( PARAM % m_end % ku < 1.34 * PARAM % m_end % sk ** 2 + 1.8 ), & ! stats_in = PARAM % m_end , & ! lg = l ) ! allocate ( PARAM % imp_acf ( 1 : w , 1 : h ) ) ! recalculate the theoretical acf, for the new size surface call calc_imp_acf ( long = w , & ! IN larg = h , & ! IN apod = PARAM % apod , & ! IN tau1 = PARAM % curr_surf % cl1 , & ! IN tau2 = PARAM % curr_surf % cl2 , & ! IN alpha = log ( PARAM % curr_surf % cut ), & ! IN ang = PARAM % curr_surf % ang * PI_R8 / 180 , & ! IN tab_acf = PARAM % imp_acf ( 1 : w , 1 : h )) ! OUT ! difference between old and new size: hence, there will be dw*dh possible locations ! for the subsurface dw = we - w dh = he - h ! initialize the best acf result (mean absolute difference) and subsurface locations best_acf = 1.e6_R8 best_idw = 0 best_jdh = 0 size_ratio = dw / dh ! Number of locations along x and y. It respects the total number to be explored, as set ! by the user and the size ratio of the surface ndw = nint ( sqrt ( n_seek / size_ratio ) ) ndh = nint ( real ( n_seek , kind = R8 ) / ndw ) ! ndw and ndh are modified to be mumtiples of the number of threads, but the product ! should not be too far from n_seek if ( size_ratio > 1. ) then ndw = NB_THREADS_FFT * ( int ( ndw / NB_THREADS_FFT ) + 1 ) ndh = NB_THREADS_FFT * ( int ( ndh / NB_THREADS_FFT ) ) else ndw = NB_THREADS_FFT * ( int ( ndw / NB_THREADS_FFT ) ) ndh = NB_THREADS_FFT * ( int ( ndh / NB_THREADS_FFT ) + 1 ) endif ! don't exceed the maximums ndw = min ( ndw , dw ) ndh = min ( ndh , dh ) ! increments for looping inc_dw = dw / ndw inc_dh = dh / ndh ! result storage allocate ( tab_res_acf ( 1 : ndw , 1 : ndh ) ) tab_res_acf ( 1 : ndw , 1 : ndh ) = - 1 allocate ( surf_tmp ( 1 : w , 1 : h ) ) allocate ( acf_tmp ( 1 : w , 1 : h ) ) allocate ( order_tmp ( 1 : l ) ) allocate ( tab_tmp ( 1 : l ) ) call progress_bar_terminal ( val = 0 , max_val = ndw * ndh , init = . true .) !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_THREADS_FFT) !$OMP DO SCHEDULE (STATIC, ndw/NB_THREADS_FFT) PRIVATE(ib, ie, jb, je, jdh, surf_tmp, tab_tmp, order_tmp, acf_tmp, i, m_res, res_acf, nn_res, res_ratio, text) do idw = 1 , ndw ib = idw * inc_dw ie = ib + w - 1 do jdh = 1 , ndh jb = jdh * inc_dh je = jb + h - 1 surf_tmp ( 1 : w , 1 : h ) = sav_surf ( ib : ie , jb : je ) !....................................................................................... tab_tmp ( 1 : l ) = reshape ( surf_tmp ( 1 : w , 1 : h ), [ l ] ) ! store the subsurface height order call init_order ( order = order_tmp ( 1 : l ), & ! OUT n = l ) ! IN call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! INOUT tab0 = order_tmp ( 1 : l ), & ! INOUT n = l ) ! IN ! replace old heights with new ones that matches required moments do i = 1 , l tab_tmp ( order_tmp ( i ) ) = PARAM % vect_h ( i ) enddo surf_tmp ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call calc_moments ( tab = tab_tmp ( 1 : l ), & ! IN mx = m_res , & ! OUT nb_mom = 4 ) ! IN surf_tmp ( 1 : w , 1 : h ) = ( surf_tmp ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si !....................................................................................... ! calculate the acf call acf_wiener ( tab_in = surf_tmp ( 1 : w , 1 : h ), & ! IN tab_out = acf_tmp ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h , & ! IN multi_fft = . true . ) ! IN ! calculate the result (mean absolute difference between theoretical acf and calculated acf) call calc_res_acf ( acf_surf = acf_tmp ( 1 : w , 1 : h ), & ! IN imp_acf = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN acf__z = PARAM % curr_surf % cut , & ! IN crit_acf = res_acf , & ! OUT w = w , & ! IN h = h ) ! IN tab_res_acf ( idw , jdh ) = res_acf ! update progressbar !$OMP CRITICAL nn_res = count ( tab_res_acf > 0 ) call progress_bar_terminal ( val = nn_res , max_val = ndw * ndh , init = . false .) !$OMP END CRITICAL enddo enddo !$OMP END DO !$OMP END PARALLEL ! find the best subsurface best_ind ( 1 : 2 ) = minloc ( tab_res_acf ) idw = best_ind ( 1 ) jdh = best_ind ( 2 ) ib = idw * ( dw / ndw ) ie = ib + w - 1 jb = jdh * ( dh / ndh ) je = jb + h - 1 PARAM % surf ( 1 : w , 1 : h ) = sav_surf ( ib : ie , jb : je ) ! redo calculations on the best subsurface !....................................................................................... tab_tmp ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call init_order ( order = PARAM % order ( 1 : l ), & ! n = l ) ! call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! tab0 = PARAM % order ( 1 : l ), & ! n = l ) ! do i = 1 , l tab_tmp ( PARAM % order ( i ) ) = PARAM % vect_h ( i ) enddo PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call calc_moments ( tab = tab_tmp ( 1 : l ), & ! mx = m_res , & ! nb_mom = 4 ) ! PARAM % surf ( 1 : w , 1 : h ) = ( PARAM % surf ( 1 : w , 1 : h ) - m_res % mu ) / m_res % si !....................................................................................... call tab_end_fftw3_real () deallocate ( sav_surf ) deallocate ( tab_tmp ) deallocate ( surf_tmp ) deallocate ( acf_tmp ) deallocate ( order_tmp ) deallocate ( tab_res_acf ) return endsubroutine sub_surf subroutine calc_res_acf ( acf_surf , imp_acf , crit_acf , acf__z , w , h ) !================================================================================================ !<@note Function that returns *crit_acf* the mean absolute difference between theoretical !< and calculated acfs, above *z* (usually 0.2 as recommended by iso 25178) !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: w !! *surface acf width (points)* integer ( kind = I4 ), intent ( in ) :: h !! *surface acf height (points)* real ( kind = R8 ), intent ( in ) :: acf__z !! *plane elevation z where correlation lengths are calculated* real ( kind = R8 ), intent ( out ) :: crit_acf !! *mean absolute difference between theoretical and calculated acfs* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: acf_surf !! *calculated surface acf* real ( kind = R8 ), intent ( in ), dimension ( 1 : w , 1 : h ) :: imp_acf !! *required surface acf* real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp allocate ( tab_tmp ( 1 : w , 1 : h ) ) tab_tmp ( 1 : w , 1 : h ) = 0 where ( imp_acf > acf__z ) tab_tmp = abs ( acf_surf - imp_acf ) crit_acf = 100 * sum ( tab_tmp ( 1 : w , 1 : h ) ) / count ( tab_tmp ( 1 : w , 1 : h ) > 0 ) deallocate ( tab_tmp ) return endsubroutine calc_res_acf subroutine read_img () !================================================================================================ !<@note Function that reads a digital surf file and returns the surface in PARAM%surf !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 512 ) :: nom_surf nom_surf = repeat ( \" \" , len ( nom_surf ) ) read ( JOB , * ) nom_surf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , trim ( nom_surf ) ! read the surface, no scaling, no centering call read_surf ( nom_fic = trim ( nom_surf ), & ! IN tab_s = PARAM % surf , & ! OUT scal = SCALE_IMG ) ! OUT PARAM % width = SCALE_IMG % xres PARAM % height = SCALE_IMG % yres PARAM % npts = SCALE_IMG % xres * SCALE_IMG % yres PARAM % surf_dx = SCALE_IMG % lx / SCALE_IMG % xres PARAM % surf_dy = SCALE_IMG % ly / SCALE_IMG % yres PARAM % surf_width = SCALE_IMG % lx PARAM % surf_height = SCALE_IMG % ly write ( * , * ) \"width \" , PARAM % width , \" height \" , PARAM % height , \" npts \" , PARAM % npts write ( * , * ) \"surf dx \" , PARAM % surf_dx , \" dy \" , PARAM % surf_dy write ( * , * ) \"width \" , PARAM % surf_width , \" height \" , PARAM % surf_height return endsubroutine read_img subroutine make_msk () !================================================================================================ !<@note Function that reads a digital surf file and turns it into a mask !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h w = PARAM % width h = PARAM % height allocate ( PARAM % surf_msk ( 1 : w , 1 : h )) PARAM % surf_msk ( 1 : w , 1 : h ) = nint ( PARAM % surf ( 1 : w , 1 : h ) ) return endsubroutine make_msk subroutine save_img ( tab ) !================================================================================================ !<@note Function that save an array *tab* as a digital surf file. ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension (:,:) :: tab !! *a surface to save as a .sur file* integer ( kind = I4 ) :: w ! image width integer ( kind = I4 ) :: h ! image height integer ( kind = I4 ), dimension ( 1 : 2 ) :: shape_tab character ( len = 512 ) :: nom_surf type ( SCALE_SURF ) :: scale_img_tmp shape_tab = shape ( tab ) w = shape_tab ( 1 ) h = shape_tab ( 2 ) nom_surf = repeat ( \" \" , len ( nom_surf ) ) read ( JOB , * ) nom_surf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , trim ( nom_surf ) call init_scal ( scal = scale_img_tmp , & ! out; creates a surface type, containing ... nx = w , & !  in; ... the number of points along x ... ny = h , & !  in; ... the number of points along y ... lx = PARAM % surf_width , & !  in; ... the length (default unit : m) ... ly = PARAM % surf_height , & !  in; ... the width ... unit_z = 'm' ) !  in; ... and the unit along z. call write_surf ( nom_fic = trim ( nom_surf ), & ! tab_s = tab ( 1 : w , 1 : h ), & ! scal = scale_img_tmp ) ! return endsubroutine save_img subroutine spct_sur ( file_spct , apod ) !================================================================================================ !<@note Returns the default surface spectrum !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len =* ), intent ( in ), optional :: file_spct !! *txt file containing the surface FFT module* logical ( kind = I4 ), intent ( in ), optional :: apod !! *window applied to surface?* integer ( kind = I4 ) :: w , h , ww , hh , i , j , np , txt_file logical ( kind = I4 ) :: apod_surf character ( len = 512 ) :: str real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp , tab_freq1 , tab_freq2 , tab_spc complex ( kind = R8 ), dimension (:,:), allocatable :: tab_cmpl , cmpl1 w = PARAM % width h = PARAM % height if ( present ( file_spct ) ) then ! use in the program -> arguments passed to subroutine str = file_spct apod_surf = apod else ! use in script -> arguments passed to batch file read ( JOB , * ) str ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , 'file_spct: ' , trim ( str ) read ( JOB , * ) apod_surf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , 'apod surf: ' , apod_surf endif allocate ( tab_tmp ( 1 : w , 1 : h ) ) allocate ( tab_freq1 ( 1 : w , 1 : h ), tab_freq2 ( 1 : w , 1 : h ) ) allocate ( tab_cmpl ( 1 : w , 1 : h ), cmpl1 ( 1 : w , 1 : h ) ) if ( apod_surf ) then tab_tmp ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) call apod_sur () endif cmpl1 ( 1 : w , 1 : h ) = cmplx ( PARAM % surf ( 1 : w , 1 : h ), 0 , kind = R8 ) call calc_fftw3 ( sens = FORWARD , & ! IN tab_in = cmpl1 ( 1 : w , 1 : h ), & ! IN tab_ou = tab_cmpl ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN tab_freq1 ( 1 : w , 1 : h ) = log10 ( abs ( tab_cmpl ( 1 : w , 1 : h ) ) + UN ) call trans_corner2center ( tab_in = tab_freq1 ( 1 : w , 1 : h ), & ! IN tab_out = tab_freq2 ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN np = 50 ! reduce image size ww = w / np hh = h / np allocate ( tab_spc ( 1 : ww , 1 : hh ) ) do i = 1 , ww do j = 1 , hh tab_spc ( i , j ) = sum ( tab_freq2 ( ( i - 1 ) * np + 1 : i * np , & ! ( j - 1 ) * np + 1 : j * np ) ) ! enddo enddo call get_unit ( txt_file ) ! Ouvrir un fichier binaire open ( newunit = txt_file , file = trim ( str ), action = \"write\" ) ! Écrire les dimensions (pour Python) write ( txt_file , * ) ww , hh ! Écrire les données en mémoire contiguë write ( txt_file , * ) tab_spc ( 1 : ww , 1 : hh ) close ( txt_file ) if ( apod_surf ) PARAM % surf ( 1 : w , 1 : h ) = tab_tmp ( 1 : w , 1 : h ) deallocate ( tab_tmp , tab_freq1 , tab_freq2 , tab_spc ) deallocate ( tab_cmpl , cmpl1 ) return endsubroutine spct_sur subroutine stat_sur () !================================================================================================ !<@note Define surface statistical moments as reference !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l logical ( kind = I4 ) :: apodize read ( JOB , * ) apodize ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , 'apod? ' , apodize w = PARAM % width h = PARAM % height l = PARAM % npts PARAM % surf_copy ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) if ( apodize ) then ! apodize surface for the acf call apod_sur () call acf_wiener ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! IN tab_out = PARAM % acf_surf ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h ) ! IN ! retrieve original surface PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf_copy ( 1 : w , 1 : h ) endif ! do not append to result file, make new one call surface_analysis ( app = 0 ) ! calculate statistical moments that become prescribed call std_array ( tab = PARAM % surf ( 1 : w , 1 : h ), mx = PARAM % m_end ) ! determine final heights PARAM % vect_h ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) ! determine height order call sort_array2 ( tab_inout = PARAM % vect_h ( 1 : l ), n = l ) ! prescribe moments PARAM % m_ini = PARAM % m_end ! prescribe acf PARAM % imp_acf ( 1 : w , 1 : h ) = PARAM % acf_surf ( 1 : w , 1 : h ) return endsubroutine stat_sur subroutine smooth__ () !================================================================================================ !<@note Function that applies a low-pass filter to the surface PARAM%surf !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp real ( kind = R8 ) :: cutoff read ( JOB , * ) cutoff ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"cutoff \" , cutoff PARAM % cutoff = cutoff w = PARAM % width h = PARAM % height ! forces FFT reinitialization FFT_DIM = 0 allocate ( tab_tmp ( 1 : w , 1 : h ) ) ! remark: if cutoff is negative, the filter is a top-hat instead of Gaussian call fft_filter ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN cutoff = PARAM % cutoff , & ! IN bf_tab = tab_tmp ( 1 : w , 1 : h ), & ! OUT multi_fft = . false ., & ! IN pad = - 1._R8 , & ! IN ext = 'constant' ) ! IN ! standardize surface call std_array ( tab = tab_tmp ( 1 : w , 1 : h ) ) PARAM % surf ( 1 : w , 1 : h ) = tab_tmp ( 1 : w , 1 : h ) deallocate ( tab_tmp ) FFT_DIM = 0 return endsubroutine smooth__ subroutine apod_sur () !================================================================================================ !<@note Function that apodize the reference surface for acf calculus purposes !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp w = PARAM % width h = PARAM % height allocate ( tab_tmp ( 1 : w , 1 : h ) ) call apod ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & !  IN tab_out = tab_tmp ( 1 : w , 1 : h ), & !  OUT long = w , & !  IN larg = h , & !  IN type_apo = 'tuckey' ) !  IN ! standardize surface call std_array ( tab_tmp ( 1 : w , 1 : h ) ) PARAM % surf ( 1 : w , 1 : h ) = tab_tmp ( 1 : w , 1 : h ) deallocate ( tab_tmp ) return endsubroutine apod_sur subroutine apod_acf () !================================================================================================ !<@note Function that apodize the acf to prevent spectral leakage !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h real ( kind = R8 ) :: tau1 , tau2 , ang , coeff , c , s , R1 , R2 real ( kind = R8 ), dimension ( 1 : 8 ) :: ana_res real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp logical ( kind = I4 ) :: set_acf read ( JOB , * ) set_acf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , \"Set ACF \" , set_acf w = PARAM % width h = PARAM % height call ellipse_acf ( tabin = PARAM % acf_surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN p_acv = ana_res ( 1 : 8 ), & ! OUT -> correlation lengths cut = 0.5_R8 , & ! IN  -> z cut plane scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN  -> lags along x and y omp = . true . ) ! IN  -> use multithread? tau1 = ana_res ( 1 ) tau2 = ana_res ( 2 ) ang = ana_res ( 4 ) * PI_R8 / 180 c = cos ( ang ) s = sin ( ang ) ! ellipsis bounding box (half dimensions) R1 = sqrt ( ( c * tau1 ) ** 2 + ( s * tau2 ) ** 2 ) R2 = sqrt ( ( s * tau1 ) ** 2 + ( c * tau2 ) ** 2 ) ! scale factor for the apodization to take place within the surface ! 0.4 * image width is less than half width coeff = min ( 0.4 * PARAM % surf_width / R1 , 0.4 * PARAM % surf_height / R2 ) allocate ( tab_tmp ( 1 : w , 1 : h ) ) ! modified Tuckey windowing call apod2 ( tab_in = PARAM % acf_surf ( 1 : w , 1 : h ), & ! IN tab_out = tab_tmp ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h , & ! IN tau1 = coeff * tau1 , & ! IN tau2 = coeff * tau2 , & ! IN ang = ang ) ! IN if ( set_acf ) then ! acf calculated becomes prescribed acf PARAM % imp_acf ( 1 : w , 1 : h ) = tab_tmp ( 1 : w , 1 : h ) else PARAM % acf_surf ( 1 : w , 1 : h ) = tab_tmp ( 1 : w , 1 : h ) endif deallocate ( tab_tmp ) return endsubroutine apod_acf subroutine repr_img () !================================================================================================ !<@note Function that set parameters for image reproduction !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tmp , surf_tmp integer ( kind = I4 ) :: reproduction_step real ( kind = R8 ) :: cutoff , dx , dy type ( SCALE_SURF ) :: scale_img_tmp type ( MOMENT_STAT ) :: m_res read ( JOB , * ) reproduction_step ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"reproduction_step \" , reproduction_step w = PARAM % width h = PARAM % height l = PARAM % npts dx = PARAM % surf_dx dy = PARAM % surf_dy allocate ( tab_tmp ( 1 : w , 1 : h ) ) allocate ( surf_tmp ( 1 : w , 1 : h ) ) select case ( reproduction_step ) case ( 0 : 1 ) PARAM % orig_surf % cut = 0.5_R8 PARAM % curr_surf % cut = 0.5_R8 call alloc_tabs () PARAM % surf_copy ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) call calc_moments ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN mx = PARAM % m_ini , & ! OUT nb_mom = 4 ) ! IN call apod ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! tab_out = tab_tmp ( 1 : w , 1 : h ), & ! long = w , & ! larg = h , & ! type_apo = 'tuckey' ) ! call std_array ( tab_tmp ( 1 : w , 1 : h ) ) call acf_wiener ( tab_in = tab_tmp ( 1 : w , 1 : h ), & ! IN tab_out = PARAM % acf_surf ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h ) ! IN call surface_analysis ( app = 0 ) !-------------- NORMALIZATION ------------------------ call std_array ( PARAM % surf ( 1 : w , 1 : h ), PARAM % m_ini ) case ( 2 ) !------------ SAVE LOW FREQ SURF --------------------- PARAM % surf_LF ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) !------------ REPRODUCE HIGH FREQ --------------------- PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf_HF ( 1 : w , 1 : h ) PARAM % m_end = PARAM % m__HF PARAM % vect_h ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call sort_array2 ( tab_inout = PARAM % vect_h ( 1 : l ), n = l ) surf_tmp ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) case ( 3 ) !------------ SAVE HIGH FREQ SURF --------------------- PARAM % surf_HF ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf_LF ( 1 : w , 1 : h ) + PARAM % surf_HF ( 1 : w , 1 : h ) * PARAM % m__HF % si / PARAM % m__LF % si call std_array ( PARAM % surf ( 1 : w , 1 : h ) ) PARAM % vect_h ( 1 : l ) = reshape ( PARAM % surf_copy ( 1 : w , 1 : h ), [ l ] ) ! heights are sorted call sort_array2 ( tab_inout = PARAM % vect_h ( 1 : l ), n = l ) call calc_moments ( tab = PARAM % vect_h ( 1 : l ), & ! IN mx = m_res , & ! OUT nb_mom = 2 ) ! IN PARAM % vect_h ( 1 : l ) = ( PARAM % vect_h ( 1 : l ) - m_res % mu ) / m_res % si surf_tmp ( 1 : w , 1 : h ) = PARAM % surf_copy ( 1 : w , 1 : h ) call std_array ( surf_tmp ( 1 : w , 1 : h ) ) case ( 4 ) call std_array ( PARAM % surf ( 1 : w , 1 : h ) ) PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) * PARAM % m_ini % si + PARAM % m_ini % mu call surface_analysis ( app = 1 ) endselect select case ( reproduction_step ) case ( 0 ) PARAM % imp_acf ( 1 : w , 1 : h ) = PARAM % acf_surf ( 1 : w , 1 : h ) ! the calculated moments become the prescribed ones PARAM % m_end = PARAM % m_ini ! heights are stored because they are the prescribed ones PARAM % vect_h ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) ! shuffle the set, then ... call scramble ( tab = PARAM % vect_h ( 1 : l ), & ! INOUT lg = l ) ! IN ! ... define an initial random surface ... PARAM % surf ( 1 : w , 1 : h ) = reshape ( PARAM % vect_h ( 1 : l ), [ w , h ] ) ! and sort heights call sort_array2 ( tab_inout = PARAM % vect_h ( 1 : l ), n = l ) case ( 1 ) !------------ SUBTRACT LOW FREQ ---------------------- read ( JOB , * ) cutoff ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"cutoff \" , cutoff call fft_filter ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN cutoff = cutoff , & ! IN bf_tab = PARAM % surf_LF ( 1 : w , 1 : h ), & ! OUT multi_fft = . false ., & ! IN ext = 'constant' ) ! IN PARAM % surf_HF ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) - PARAM % surf_LF ( 1 : w , 1 : h ) !------------ MOMENTS LF & HF  ---------------------- call std_array ( tab = PARAM % surf_HF ( 1 : w , 1 : h ), mx = PARAM % m__HF ) call std_array ( tab = PARAM % surf_LF ( 1 : w , 1 : h ), mx = PARAM % m__LF ) !------------ PRINT LF & HF SURFS ---------------------- call init_scal ( scal = scale_img_tmp , & ! out; creates a surface type, containing ... nx = w , & !  in; ... the number of points along x ... ny = h , & !  in; ... the number of points along y ... lx = PARAM % surf_width , & !  in; ... the length (default unit : m) ... ly = PARAM % surf_height , & !  in; ... the width ... unit_z = 'm' ) !  in; ... and the unit along z. call write_surf ( nom_fic = \"out/BF.sur\" , & ! tab_s = PARAM % surf_LF ( 1 : w , 1 : h ), & ! scal = scale_img_tmp ) ! call write_surf ( nom_fic = \"out/HF.sur\" , & ! tab_s = PARAM % surf_HF ( 1 : w , 1 : h ), & ! scal = scale_img_tmp ) ! !------------ REPRODUCE LOW FREQ ---------------------- PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf_LF ( 1 : w , 1 : h ) PARAM % m_end = PARAM % m__LF PARAM % vect_h ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call sort_array2 ( tab_inout = PARAM % vect_h ( 1 : l ), n = l ) surf_tmp ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) case default continue endselect if ( reproduction_step > 0 . and . reproduction_step < 4 ) then !------------ DESIRED ACF: PARAM%imp_acf ------------- call apod ( tab_in = surf_tmp ( 1 : w , 1 : h ), & ! tab_out = tab_tmp ( 1 : w , 1 : h ), & ! long = w , & ! larg = h , & ! type_apo = 'tuckey' ) ! call std_array ( tab_tmp ( 1 : w , 1 : h ) ) call acf_wiener ( tab_in = tab_tmp ( 1 : w , 1 : h ), & ! IN tab_out = PARAM % imp_acf ( 1 : w , 1 : h ), & ! OUT w = w , & ! IN h = h ) ! IN endif deallocate ( tab_tmp ) deallocate ( surf_tmp ) return endsubroutine repr_img subroutine calc_z_f () !================================================================================================ !<@note Function that returns PARAM%surf, the surface made of heights with the required statistical !< moments, in the right order. !< !< - The heights come from the vector PARAM%vect_h !< - the heights order is stored in the vector PARAM%order !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: i integer ( kind = I4 ) :: w , h , l real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp read ( JOB , * ) PARAM % calc_zf ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"PARAM%calc_zf \" , PARAM % calc_zf w = PARAM % width h = PARAM % height l = PARAM % npts ! final set of heights are generated to meet the desired statistical moments ! It is done once. if ( PARAM % calc_zf ) then write ( SPY , * ) 'calc_z_f -> final set of heights are generated to meet the desired statistical moments' call build_heights ( vec_out = PARAM % vect_h ( 1 : l ), & ! OUT use_fct_expo = ( PARAM % m_end % ku < 1.34 * PARAM % m_end % sk ** 2 + 1.8 ), & ! IN stats_in = PARAM % m_end , & ! IN lg = l ) ! IN endif ! The heights stored in PARAM%vect_h(1:lg) are reinjected in PARAM%surf, with respect to the order PARAM%order write ( SPY , * ) 'calc_z_f -> substitution of PARAM%surf with PARAM%vect_h with respect to PARAM%order' allocate ( tab_tmp ( 1 : l ) ) do i = 1 , l tab_tmp ( PARAM % order ( i ) ) = PARAM % vect_h ( i ) enddo PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) call std_array ( tab = tab_tmp ( 1 : l ) ) deallocate ( tab_tmp ) return endsubroutine calc_z_f subroutine calc_ord () !================================================================================================ !<@note Function that returns the vector PARAM%order that contains the heights order. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: l , w , h real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( tab_tmp ( 1 : l ) ) tab_tmp ( 1 : l ) = reshape ( PARAM % surf ( 1 : w , 1 : h ), [ l ] ) call init_order ( order = PARAM % order ( 1 : l ), & ! OUT n = l ) ! IN call sort_array2 ( tab_inout = tab_tmp ( 1 : l ), & ! IN tab0 = PARAM % order ( 1 : l ), & ! OUT n = l ) ! IN deallocate ( tab_tmp ) return endsubroutine calc_ord subroutine digi_fil () !================================================================================================ !<@note Function that applies the digital filter to the random heights !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h complex ( kind = R8 ), dimension (:,:), allocatable :: cmple complex ( kind = R8 ), dimension (:,:), allocatable :: ftab ! FFT(tab_prf) type ( MOMENT_STAT ) :: m_res write ( SPY , * ) 'digi_fil -> 1 - extends then windows PARAM%surf to calculate its FFT ftab' write ( SPY , * ) 'digi_fil -> 2 - multiplies ftab and the digital filter PARAM%fhi, then FFT-1' write ( SPY , * ) 'digi_fil -> 3 - retrieves PARAM%surf by removing the padded extension' w = PARAM % width h = PARAM % height allocate ( cmple ( 1 : w , 1 : h ) ) ! allocate ( ftab ( 1 : w , 1 : h ) ) ! cmple ( 1 : w , 1 : h ) = cmplx ( PARAM % surf ( 1 : w , 1 : h ), 0 , kind = R8 ) call calc_fftw3_real_fwd ( tab_in = PARAM % surf ( 1 : w , 1 : h ), & ! IN tab_ou = cmple ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN ftab ( 1 : w , 1 : h ) = cmple ( 1 : w , 1 : h ) where ( abs ( cmple ( 1 : w , 1 : h )) > 100 * EPS_R8 ) ftab ( 1 : w , 1 : h ) = cmple ( 1 : w , 1 : h ) / abs ( cmple ( 1 : w , 1 : h ) ) elsewhere ftab ( 1 : w , 1 : h ) = cmplx ( UN , 0._R8 , kind = R8 ) endwhere write ( SPY , * ) 'ftab normalized' !-------------------------------------------------------------------- ! FFT of the filter * FFT of the random heights !-------------------------------------------------------------------- cmple ( 1 : w , 1 : h ) = PARAM % fhi ( 1 : w , 1 : h ) * ftab ( 1 : w , 1 : h ) call calc_fftw3_real_bwd ( tab_in = cmple ( 1 : w , 1 : h ), & ! IN tab_ou = PARAM % surf ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN call std_array ( tab = PARAM % surf ( 1 : w , 1 : h ), mx = m_res ) write ( SPY , * ) 'sk ku fin ' , m_res % sk , m_res % ku deallocate ( cmple ) deallocate ( ftab ) return endsubroutine digi_fil subroutine add_nois () !================================================================================================ !<@note Function that returns the starting surface of random heights !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l real ( kind = R8 ) :: size_noise real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp type ( MOMENT_STAT ) :: mx read ( JOB , * ) mx % sk , mx % ku , size_noise ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"ssk, sku, size \" , mx % sk , mx % ku , size_noise w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( tab_tmp ( 1 : l ) ) call build_heights ( vec_out = tab_tmp ( 1 : l ), & ! OUT use_fct_expo = ( mx % ku < 1.34 * mx % sk ** 2 + 1.8 ), & ! IN stats_in = mx , & ! IN lg = l ) ! IN call std_array ( tab = tab_tmp ( 1 : l ) ) call scramble ( tab = tab_tmp ( 1 : l ), & ! INOUT lg = l ) ! IN PARAM % surf ( 1 : w , 1 : h ) = PARAM % surf ( 1 : w , 1 : h ) + size_noise * reshape ( tab_tmp ( 1 : l ), [ w , h ] ) deallocate ( tab_tmp ) return endsubroutine add_nois subroutine calc_z_i () !================================================================================================ !<@note Function that returns the starting surface of random heights !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l real ( kind = R8 ), allocatable , dimension (:) :: tab_tmp type ( MOMENT_STAT ) :: m_res w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( tab_tmp ( 1 : l ) ) ! starting set of heights are generated to meet the statistical moments prescribed by calc_ffh write ( SPY , * ) 'calc_z_i -> starting set of heights are generated to meet the prescribed statistical moments by calc_ffh' call build_heights ( vec_out = tab_tmp ( 1 : l ), & ! OUT use_fct_expo = ( PARAM % m_stt % ku < 1.34 * PARAM % m_stt % sk ** 2 + 1.8 ), & ! IN stats_in = PARAM % m_stt , & ! IN lg = l ) ! IN call std_array ( tab = tab_tmp ( 1 : l ), mx = m_res ) write ( TER , * ) 'starting statistical moments ' , m_res % mu , m_res % va , m_res % sk , m_res % ku call scramble ( tab = tab_tmp ( 1 : l ), & ! INOUT lg = l ) ! IN PARAM % surf ( 1 : w , 1 : h ) = reshape ( tab_tmp ( 1 : l ), [ w , h ] ) deallocate ( tab_tmp ) return endsubroutine calc_z_i subroutine calc_ffh () !================================================================================================ !<@note Function that returns ... !< !< - the digital filter to apply to the height distribution  \\text{PARAM%fhi} = \\sqrt{ \\left| FFT(\\text{PARAM%imp_acf}) \\right| }  !< - the starting statistical moments PARAM%m_stt%sk, PARAM%m_stt%ku !< - whether the exponential function will be used, PARAM%reajust_skku !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h , l complex ( kind = R8 ), dimension (:,:), allocatable :: cmple real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp type ( MOMENT_STAT ) :: m_h read ( JOB , * ) PARAM % calc_mstt ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"PARAM%calc_mstt \" , PARAM % calc_mstt w = PARAM % width h = PARAM % height l = PARAM % npts allocate ( cmple ( 1 : w , 1 : h ) ) write ( SPY , * ) 'calc_ffh -> PARAM%fhi = sqrt( abs( FFT(PARAM%imp_acf) ) )' call calc_fftw3_real_fwd ( tab_in = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN tab_ou = cmple ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN PARAM % fhi ( 1 : w , 1 : h ) = sqrt ( abs ( cmple ( 1 : w , 1 : h ) ) ) if ( PARAM % calc_mstt ) then ! determine starting statistical moments, if not already done !....................................................................... write ( SPY , * ) 'calc_ffh -> PARAM%m_stt calculated' cmple ( 1 : w , 1 : h ) = cmplx ( PARAM % fhi ( 1 : w , 1 : h ), 0 , kind = R8 ) allocate ( tab_tmp ( 1 : w , 1 : h ) ) call calc_fftw3_real_bwd ( tab_in = cmple ( 1 : w , 1 : h ), & ! IN tab_ou = tab_tmp ( 1 : w , 1 : h ), & ! OUT long = w , & ! IN larg = h ) ! IN call calc_moments ( tab = tab_tmp ( 1 : w , 1 : h ), & ! IN mx = m_h , & ! OUT nb_mom = 4 ) ! IN PARAM % m_stt % mu = 0 PARAM % m_stt % va = 1 PARAM % m_end % mu = 0 PARAM % m_end % va = m_h % va PARAM % m_stt % sk = sqrt ( UN * l ) * PARAM % m_end % sk / m_h % sk PARAM % m_stt % ku = l * ( PARAM % m_end % ku - 3. ) / ( m_h % ku - 3. ) + 3. PARAM % reajust_skku = . false . if ( PARAM % m_stt % ku < PARAM % m_stt % sk ** 2 + 1. ) then PARAM % m_stt % ku = PARAM % m_stt % sk ** 2 + 1. PARAM % reajust_skku = . true . endif deallocate ( tab_tmp ) !....................................................................... else write ( SPY , * ) 'calc_ffh -> PARAM%m_stt NOT calculated, set to PARAM%m_end' PARAM % m_stt % sk = PARAM % m_end % sk PARAM % m_stt % ku = PARAM % m_end % ku endif deallocate ( cmple ) return endsubroutine calc_ffh subroutine sta_scri () !! Start the script reading implicit none ! Initializes the state of the pseudorandom number generator used by RANDOM_NUMBER. call random_init ( repeatable = . false ., image_distinct = . true .) return endsubroutine sta_scri subroutine def_size () !! Geometrical characteristics of the numerical surface implicit none integer ( kind = I4 ) :: w , h logical ( kind = I4 ) :: period real ( kind = R8 ) :: lw , lh read ( JOB , * ) w , h ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"width, height  \" , w , h read ( JOB , * ) lw , lh ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"img width and height (m) \" , lw , lh read ( JOB , * ) period ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"periodic surface? \" , period PARAM % periodic = period PARAM % width = w PARAM % height = h PARAM % npts = w * h PARAM % surf_width = lw PARAM % surf_height = lh PARAM % surf_dx = lw / w PARAM % surf_dy = lh / h return endsubroutine def_size subroutine acf_theo () !================================================================================================ !<@note Function that returns the theoretical acf PARAM%imp_acf. !< !< If the surface to generate is non periodic, the starting surface is extended. The final surface !< will be a part of it. Indeed the extended surface will be periodic, because the use of FFTs. !< !< If a roughness orientation is chosen, in addition with long correlation lengths, a windowing !< should be applied to the acf to prevent from artifacts (vertical and horizontal lines) !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: w , h logical ( kind = I4 ) :: with_apod real ( kind = R8 ) :: ratio , a , b , c , s , lx , ly real ( kind = R8 ), dimension ( 1 : 8 ) :: res read ( JOB , * ) PARAM % curr_surf % cl1 , PARAM % curr_surf % cl2 , PARAM % curr_surf % cut ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"l_acf \" , PARAM % curr_surf % cl1 , PARAM % curr_surf % cl2 , PARAM % curr_surf % cut if ( PARAM % curr_surf % cl1 < PARAM % curr_surf % cl2 ) stop \"inverser cl1, cl2\" read ( JOB , * ) PARAM % curr_surf % ang ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"ang \" , PARAM % curr_surf % ang write ( SPY , * ) 'acf_theo -> determines the theoretical acf with a padded size, so correlation lengths are adjusted accordingly' read ( JOB , * ) with_apod ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"apod \" , with_apod PARAM % apod = with_apod w = PARAM % width h = PARAM % height if ( . not . PARAM % periodic ) then PARAM % sub_width = w PARAM % sub_height = h PARAM % sub_npts = w * h PARAM % sub_surf_width = PARAM % surf_width PARAM % sub_surf_height = PARAM % surf_height ! the surface must be extended a = PARAM % curr_surf % cl1 b = PARAM % curr_surf % cl2 c = cos ( PARAM % curr_surf % ang * PI_R8 / 180 ) s = sin ( PARAM % curr_surf % ang * PI_R8 / 180 ) lx = sqrt ( ( a * c ) ** 2 + ( b * s ) ** 2 ) ly = sqrt ( ( a * s ) ** 2 + ( b * c ) ** 2 ) w = w + nint ( lx / PARAM % surf_dx ) h = h + nint ( ly / PARAM % surf_dy ) ! update sizes PARAM % width = w PARAM % height = h PARAM % npts = w * h PARAM % surf_width = w * PARAM % surf_dx PARAM % surf_height = h * PARAM % surf_dy endif allocate ( PARAM % surf ( 1 : w , 1 : h ) ) allocate ( PARAM % fhi ( 1 : w , 1 : h ) ) allocate ( PARAM % imp_acf ( 1 : w , 1 : h ) ) allocate ( PARAM % order ( 1 : w * h ) ) allocate ( PARAM % vect_h ( 1 : w * h ) ) allocate ( PARAM % acf_surf ( 1 : w , 1 : h ) ) ratio = PARAM % curr_surf % cl2 / PARAM % curr_surf % cl1 ! acf_theo is the theoretical acf for the normal surface call calc_imp_acf ( long = w , & ! IN larg = h , & ! IN apod = with_apod , & ! IN tau1 = PARAM % curr_surf % cl1 , & ! IN tau2 = PARAM % curr_surf % cl2 , & ! IN alpha = log ( PARAM % curr_surf % cut ), & ! IN ang = PARAM % curr_surf % ang * PI_R8 / 180 , & ! IN tab_acf = PARAM % imp_acf ( 1 : w , 1 : h )) ! OUT call ellipse_acf ( tabin = PARAM % imp_acf ( 1 : w , 1 : h ), & ! IN long = w , & ! IN larg = h , & ! IN p_acv = res ( 1 : 8 ), & ! OUT cut = PARAM % curr_surf % cut , & ! IN scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN omp = . true . ) ! IN return endsubroutine acf_theo subroutine nb_procs () !! Number of concurrent threads implicit none integer ( kind = I4 ) :: nb_th read ( JOB , * ) nb_th ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) LINE_READ , 'nb_procs' , nb_th select case ( nb_th ) case ( 0 ) ! no multihreading PARAM % nb_threads = 1 NB_THREADS_FFT = 1 case ( - 1 ) ! determined by system PARAM % nb_threads = omp_get_num_procs () NB_THREADS_FFT = PARAM % nb_threads case default stop 'Bad choice \"nb_procs\" in \"mod_script\"' endselect return endsubroutine nb_procs subroutine sta_theo () !! Required statistical moments implicit none read ( JOB , * ) PARAM % m_end % sk , PARAM % m_end % ku ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"m_end \" , PARAM % m_end % sk , PARAM % m_end % ku return endsubroutine sta_theo subroutine end_scri () !! End of script implicit none close ( SPY ) close ( STA ) if ( allocated ( PARAM % imp_acf ) ) deallocate ( PARAM % imp_acf ) if ( allocated ( PARAM % acf_surf ) ) deallocate ( PARAM % acf_surf ) if ( allocated ( PARAM % surf_LF ) ) deallocate ( PARAM % surf_LF ) if ( allocated ( PARAM % surf_HF ) ) deallocate ( PARAM % surf_HF ) if ( allocated ( PARAM % surf_msk ) ) deallocate ( PARAM % surf_msk ) if ( allocated ( PARAM % surf ) ) deallocate ( PARAM % surf ) if ( allocated ( PARAM % surf_copy ) ) deallocate ( PARAM % surf_copy ) if ( allocated ( PARAM % vect_h ) ) deallocate ( PARAM % vect_h ) if ( allocated ( PARAM % fhi ) ) deallocate ( PARAM % fhi ) if ( allocated ( PARAM % order ) ) deallocate ( PARAM % order ) call end_fftw3 () return endsubroutine end_scri subroutine make_tex () !================================================================================================ !< @note Function that creates a periodic macro-texture: knowing the FFT of an analytical texture !        a surface is created and then transformed by a FFT. As a result it is periodic. !  @endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), allocatable , dimension (:) :: xloc , yloc , haut real ( kind = R8 ) :: ca , sa , a , b , c , x0 , y0 , h0 integer ( kind = I4 ) :: kk , w2 , h2 complex ( kind = R8 ) :: eix , eiy , ftmp real ( kind = R8 ) :: x1 , y1 , ax , ay , sx , sy , coeff integer ( kind = I4 ) :: ksi , eta complex ( kind = R8 ), allocatable , dimension (:,:) :: cmpl_in , cmpl_ou , ft real ( kind = R8 ) :: alpha ! texture orientation real ( kind = R8 ) :: sigmax , sigmay ! texture stdv integer ( kind = I4 ) :: texture ! number of texture elements character ( len = 016 ) :: dimples ! texture elementar shapes: \"circle\" or \"square\" real ( kind = R8 ) :: dx , dy integer ( kind = I4 ) :: w , h , l type ( MOMENT_STAT ) :: m_res w = PARAM % width h = PARAM % height l = PARAM % npts dx = PARAM % surf_dx dy = PARAM % surf_dy read ( JOB , * ) dimples ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"dimples \" , dimples read ( JOB , * ) texture ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"texture \" , texture sigmax = PARAM % curr_surf % cl1 / dx / w * 2 sigmay = PARAM % curr_surf % cl2 / dx / h * 2 alpha = PARAM % curr_surf % ang w2 = w / 2 h2 = h / 2 if ( w == 2 * ( w / 2 ) + 1 ) w2 = w / 2 + 1 if ( h == 2 * ( h / 2 ) + 1 ) h2 = h / 2 + 1 allocate ( cmpl_in ( 1 : w , 1 : h ), & ! cmpl_ou ( 1 : w , 1 : h ) ) ! allocate ( ft ( - w / 2 : w2 - 1 , & ! - h / 2 : h2 - 1 ) ) ! allocate ( xloc ( 1 : TEXTURE ), & ! yloc ( 1 : TEXTURE ), & ! haut ( 1 : TEXTURE ) ) ! ca = cos ( alpha * PI_R8 / 180 ) sa = sin ( alpha * PI_R8 / 180 ) ! Gaussian coefficients a = 0.5 * ( ( ca / sigmax ) * ( ca / sigmax ) + ( sa / sigmay ) * ( sa / sigmay ) ) c = 0.5 * ( ( sa / sigmax ) * ( sa / sigmax ) + ( ca / sigmay ) * ( ca / sigmay ) ) b = 1.0 * ( ( sa / sigmax ) * ( ca / sigmax ) - ( sa / sigmay ) * ( ca / sigmay ) ) call random_number ( xloc ( 1 : TEXTURE ) ) ! localisation in [0,1]x[0,1] call random_number ( yloc ( 1 : TEXTURE ) ) call random_number ( haut ( 1 : TEXTURE ) ) haut ( 1 : TEXTURE ) = 2 * haut ( 1 : TEXTURE ) - 1._R8 coeff = 2 * pi_R8 do ksi = - w / 2 , w2 - 1 do eta = - h / 2 , h2 - 1 x1 = ( + ksi * ca + eta * sa ) * coeff y1 = ( - ksi * sa + eta * ca ) * coeff ftmp = 0 sx = sigmax sy = sigmay do kk = 1 , TEXTURE ! nombre de pics sur le niveau niv x0 = xloc ( kk ) y0 = yloc ( kk ) h0 = haut ( kk ) ! d'un niveau à l'autre, on atténue les pics d'un facteur \"per_tex\" ax = - x1 * x0 ay = - y1 * y0 eix = cmplx ( cos ( ax ), sin ( ax ), kind = R8 ) eiy = cmplx ( cos ( ay ), sin ( ay ), kind = R8 ) select case ( DIMPLES ( 1 : 6 ) ) case ( \"square\" ) ftmp = ftmp + 2 * h0 * pi_R8 * sx * sy * sinc ( sx * x1 ) * eix & ! * sinc ( sy * y1 ) * eiy case ( \"circle\" ) ftmp = ftmp + 2 * h0 * pi_R8 * sx * sy * exp ( - 0.5 * ( sx ** 2 ) * ( x1 ** 2 ) ) * eix & ! * exp ( - 0.5 * ( sy ** 2 ) * ( y1 ** 2 ) ) * eiy case default stop \"make_terra, no dimple type selected\" endselect enddo ft ( ksi , eta ) = ftmp enddo enddo cmpl_in ( 1 : w2 , 1 : h2 ) = ft ( 0 : w2 - 1 , 0 : h2 - 1 ) ! SO = NE cmpl_in ( 1 : w2 , h2 + 1 : h ) = ft ( 0 : w2 - 1 , - h / 2 : - 1 ) ! SE = NO cmpl_in ( w2 + 1 : w , 1 : h2 ) = ft ( - w / 2 : - 1 , 0 : h2 - 1 ) ! NO = SE cmpl_in ( w2 + 1 : w , h2 + 1 : h ) = ft ( - w / 2 : - 1 , - h / 2 : - 1 ) ! NE = SO FFT_DIM = 0 ! forces fftw desalloc and reinit call calc_fftw3 ( sens = BACKWARD , & ! tab_in = cmpl_in ( 1 : w , 1 : h ), & ! tab_ou = cmpl_ou ( 1 : w , 1 : h ), & ! long = w , & ! larg = h ) ! FFT_DIM = 0 ! forces fftw desalloc and reinit PARAM % surf ( 1 : w , 1 : h ) = real ( cmpl_ou ( 1 : w , 1 : h ), kind = R8 ) * sqrt ( real ( w * h , kind = R8 )) call calc_moments ( tab = PARAM % surf ( 1 : w , 1 : h ), & ! IN mx = m_res , & ! OUT nb_mom = 3 ) ! IN if ( m_res % sk > 0. ) PARAM % surf ( 1 : w , 1 : h ) = - PARAM % surf ( 1 : w , 1 : h ) deallocate ( xloc , yloc , haut ) deallocate ( cmpl_in , cmpl_ou ) contains !----------------------------------------- function sinc ( x ) implicit none real ( kind = R8 ) :: sinc real ( kind = R8 ), intent ( in ) :: x if ( abs ( x ) > 1.0e-8 ) then sinc = sin ( x ) / x else sinc = UN endif return endfunction sinc !----------------------------------------- endsubroutine make_tex subroutine make_scratches () !================================================================================================ !< @note This subroutine initializes a real matrix `tab` of dimensions `nx` by `ny` with ones !        and adds `sn` linear scratches with value 0. Each scratch has a random length up to `sl`, !        a constant width `sw`, and a random orientation. Scratches can touch the matrix boundaries. ! !  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ) :: nx ! Number of rows integer ( kind = I4 ) :: ny ! Number of columns integer ( kind = I4 ) :: sn ! Number of scratches integer ( kind = I4 ) :: sw ! Scratch width integer ( kind = I4 ) :: sl ! Maximum scratch length integer ( kind = I4 ) :: i , j , n real ( kind = R8 ) :: theta , length , depth , x0 , y0 , x1 , y1 real ( kind = R8 ) :: rand , r1 , r2 nx = PARAM % width ny = PARAM % height read ( JOB , * ) sn , sw , sl ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"sn, sw, sl  \" , sn , sw , sl ! Initialize matrix with ones PARAM % surf ( 1 : nx , 1 : ny ) = 1.0_R8 ! Seed random number generator call random_seed () ! Generate each scratch do n = 1 , sn ! Random starting point call random_number ( rand ) x0 = rand * nx call random_number ( rand ) y0 = rand * ny ! Random depth ! Génération de deux variables gamma call gamma_random ( shape = 3._R8 , output = r1 ) call gamma_random ( shape = 1._R8 , output = r2 ) ! Transformation pour obtenir la loi bêta depth = r1 / ( r1 + r2 ) ! Random orientation (angle in radians) call random_number ( rand ) theta = rand * 2.0 * PI_R8 ! Random length up to sl call random_number ( rand ) length = ( 2 * ( rand - 0.5_R8 ) / 10 + 0.9_R8 ) * sl ! Calculate end point of the scratch x1 = x0 + length * cos ( theta ) y1 = y0 + length * sin ( theta ) ! Draw the scratch with width sw do i = max ( 1 , floor ( min ( x0 , x1 )) - sw ), min ( nx , ceiling ( max ( x0 , x1 )) + sw ) do j = max ( 1 , floor ( min ( y0 , y1 )) - sw ), min ( ny , ceiling ( max ( y0 , y1 )) + sw ) ! Check if point (i,j) is within sw/2 distance from the line segment if ( point_to_line_distance ( real ( i , kind = R8 ), real ( j , kind = R8 ), x0 , y0 , x1 , y1 ) <= sw / 2.0 ) then PARAM % surf ( i , j ) = depth endif enddo enddo enddo contains subroutine gamma_random ( shape , output ) implicit none real ( kind = R8 ), intent ( in ) :: shape real ( kind = R8 ), intent ( out ) :: output real ( kind = R8 ) :: b , c real ( kind = R8 ) :: u , v , w , y ! algorithme de marsaglia pour générer une variable gamma b = shape - 1.0 / 3.0 c = 1.0 / sqrt ( 9.0 * b ) do call random_number ( u ) call random_number ( v ) v = 1.0 + c * log ( v ) / sqrt ( u ) if ( v <= 0.0 ) cycle w = v * v * v call random_number ( y ) if ( y < 1.0 - 0.0331 * ( log ( v ) ** 4 )) exit if ( log ( y ) < 0.5 * log ( v ) * log ( v ) + b * ( 1.0 - v + log ( v ))) exit enddo output = b * w return endsubroutine gamma_random !----------------------------------------- real ( kind = R8 ) function point_to_line_distance ( px , py , x0 , y0 , x1 , y1 ) !! Calculate the shortest distance from a point to a line segment. implicit none real ( kind = R8 ), intent ( in ) :: px !! x-coordinate of the point real ( kind = R8 ), intent ( in ) :: py !! y-coordinate of the point real ( kind = R8 ), intent ( in ) :: x0 !! x-coordinate of the line segment start real ( kind = R8 ), intent ( in ) :: y0 !! y-coordinate of the line segment start real ( kind = R8 ), intent ( in ) :: x1 !! x-coordinate of the line segment end real ( kind = R8 ), intent ( in ) :: y1 !! y-coordinate of the line segment end real ( kind = R8 ) :: dx , dy , t , proj_x , proj_y dx = x1 - x0 dy = y1 - y0 ! Handle case where start and end points are the same if ( ( dx ** 2 + dy ** 2 ) < 1.e-12 ) then point_to_line_distance = sqrt (( px - x0 ) ** 2 + ( py - y0 ) ** 2 ) return endif ! Project point onto the line t = max ( 0.0_R8 , min ( 1.0_R8 , (( px - x0 ) * dx + ( py - y0 ) * dy ) / ( dx * dx + dy * dy ))) proj_x = x0 + t * dx proj_y = y0 + t * dy ! Calculate distance point_to_line_distance = sqrt ( ( px - proj_x ) ** 2 + ( py - proj_y ) ** 2 ) return endfunction point_to_line_distance !----------------------------------------- endsubroutine make_scratches endmodule script","tags":"","loc":"sourcefile/mod_script.f90.html"},{"title":"mod_analyses.f90 – CREST","text":"This file depends on sourcefile~~mod_analyses.f90~~EfferentGraph sourcefile~mod_analyses.f90 mod_analyses.f90 sourcefile~mod_crest_param.f90 mod_crest_param.f90 sourcefile~mod_analyses.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_func_acf.f90 mod_func_acf.f90 sourcefile~mod_analyses.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_func_acf.f90->sourcefile~mod_crest_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_analyses.f90~~AfferentGraph sourcefile~mod_analyses.f90 mod_analyses.f90 sourcefile~mod_script.f90 mod_script.f90 sourcefile~mod_script.f90->sourcefile~mod_analyses.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_script.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: june, 24 2025 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.2em;\"> !        **Routines for surface analyses** !  </span> module analyses use data_arch , only : I4 , R8 use miscellaneous , only : get_unit use filter , only : median_filter , fft_filter use abbott , only : abbott_param use morpho , only : topology , calcul_normales , surf_area use grad_curv , only : peaks_and_pits_curvatures use stat_mom , only : moment_stat , calc_moments , calc_median use asfc , only : calcul_asfc_hermite , indice_fractal use anisotropy , only : correlation_parameters , multiple_anisotropy , ellipse_acf use fftw3 , only : init_fftw3 , fftw_plan_with_nthreads , tab_init_fftw3 , end_fftw3 , tab_end_fftw3 , NB_THREADS_FFT , PAD_FFT , FFTW_MEASURE use files , only : make_path , path2vec , vec2path , filename , dir_separator , mkdir , dirname use func_acf , only : acf_wiener use crest_param , only : PARAM , JOB , SPY , STA , TER , LINE_READ , SCALE_IMG implicit none private public :: surface_analysis contains subroutine surface_analysis ( app ) !================================================================================================ !< @note !< !< The function *analyses* determinates ISO 25178 parameters of the current surface. !< !< The analysis is always performed on the whole surface. !< The results are written in the file which unit is *STA*. !< !< @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ), optional :: app !! *append results to csv* integer ( kind = I4 ) :: i , ib , ie , nn , pp , append real ( kind = R8 ) :: ra_t , md real ( kind = R8 ) :: dx , dy , si , fft_cutoff type ( MOMENT_STAT ) :: mx real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp real ( kind = R8 ), dimension (:), allocatable :: vec_heights , tab_results real ( kind = R8 ), dimension ( 1 : 20 ) :: ana_res character ( len = :), allocatable :: result_str , head character ( len = 18 ) :: str if ( . not . present ( app ) ) then read ( JOB , * ) append ; LINE_READ = LINE_READ + 1 ; write ( SPY , * ) \"line: \" , LINE_READ , \"append \" , append else append = app endif ! result file call get_unit ( STA ) if ( append == 1 ) then open ( unit = STA , file = \"out/res.csv\" , status = 'unknown' , position = 'append' ) else open ( unit = STA , file = \"out/res.csv\" , status = 'unknown' ) endif !--------------------------------------------------------- ana_res = 0 nn = PARAM % width pp = PARAM % height dx = PARAM % surf_dx dy = PARAM % surf_dy si = 1 allocate ( tab_results ( 1 : 100 ) ) allocate ( vec_heights ( 1 : nn * pp ) ) vec_heights ( 1 : nn * pp ) = reshape ( PARAM % surf ( 1 : nn , 1 : pp ), [ nn * pp ] ) !----------------------------------- head = 'smrk1,smrk2,spk,svk,Sk,pente,residus,coeffa_tan,coeffb_tan,' call abbott_param ( tab = vec_heights ( 1 : nn * pp ), & ! lg = nn * pp , & ! nom = \"out/abbott_res.txt\" , & ! curves = [. false ., . false ., . false .], & ! results = ana_res ( 1 : 11 ), & ! omp = . true . ) ! ib = 1 ie = ib + 9 - 1 tab_results ( ib : ie ) = [ ana_res ( 1 ), & ! smrk1, iso 25178 ana_res ( 2 ), & ! smrk2, iso 25178 ana_res ( 3 ), & ! spk  , iso 25178 ana_res ( 4 ), & ! svk  , iso 25178 ! 5 et 6 pour off1 et off2 ana_res ( 7 ), & ! sk   , iso 25178 ana_res ( 8 ), & ! core slope ana_res ( 9 ), & ! adjustment factor (tangent fit) ana_res ( 10 ), & ! coeffa_tan        (tangent fit) ana_res ( 11 ) ] ! coeffb_tan        (tangent fit) deallocate ( vec_heights ) !----------------------------------- head = head // 'Snb1,Smc1,Sk1,Snb2,Smc2,Sk2,Sdq,Scq,Sh3z,Sv3z,' call topology ( tab = PARAM % surf ( 1 : nn , 1 : pp ), & ! long = nn , & ! larg = pp , & ! res = ana_res ( 1 : 6 ) ) ! fft_cutoff = dx / 5.e-6 ! 5.e-6 = 5 µm allocate ( tab_tmp ( 1 : nn , 1 : pp ) ) call fft_filter ( tab = PARAM % surf ( 1 : nn , 1 : pp ), & ! in long = nn , & ! in larg = pp , & ! in cutoff = fft_cutoff , & ! in bf_tab = tab_tmp ( 1 : nn , 1 : pp ), & ! out multi_fft = . false .) ! in call peaks_and_pits_curvatures ( heights = tab_tmp ( 1 : nn , 1 : pp ), & ! nx = nn , & ! ny = pp , & ! dx = dx , & ! dy = dy , & ! S_param_grad = ana_res ( 07 ), & ! S_param_curv = ana_res ( 08 ), & ! peak_curv = ana_res ( 09 ), & ! pits_curv = ana_res ( 10 ) ) ! deallocate ( tab_tmp ) ib = ie + 1 ie = ib + 10 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 10 ) !----------------------------------- head = head // 'Sv,Sp,Smd,Sa,Sm,Sq,Ssk,Sku,Sks,' call calc_moments ( tab = reshape ( PARAM % surf ( 1 : nn , 1 : pp ), [ nn * pp ] ), & ! mx = mx , & ! nb_mom = 4 ) ! call calc_median ( tab = reshape ( PARAM % surf ( 1 : nn , 1 : pp ), [ nn * pp ] ), & ! md = md ) ! ra_t = sum ( abs ( PARAM % surf ( 1 : nn , 1 : pp ) - mx % mu ) / ( nn * pp ) ) ana_res ( 1 : 8 ) = [ minval ( PARAM % surf ( 1 : nn , 1 : pp ) ) - mx % mu , & ! maxval ( PARAM % surf ( 1 : nn , 1 : pp ) ) - mx % mu , & ! md - mx % mu , & ! ra_t , mx % mu , mx % si , mx % sk , mx % ku ] ! ib = ie + 1 ie = ib + 8 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 8 ) ib = ie + 1 ie = ib tab_results ( ib ) = ana_res ( 8 ) / ( ana_res ( 7 ) ** 2 + 1 ) ! kind of kurtosis excess !----------------------------------- head = head // 'Smbd,ordorig,R2adj,' call indice_fractal ( tab_in = PARAM % surf ( 1 : nn , 1 : pp ), & ! long = nn , & ! larg = pp , & ! indf = ana_res ( 1 : 3 ) ) ! ib = ie + 1 ie = ib + 3 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 3 ) !----------------------------------- head = head // 'Sh,Sdr,' call calcul_normales ( tab_in = PARAM % surf ( 1 : nn , 1 : pp ), & ! long = nn , & ! larg = pp , & ! scale_xyz = [ dx , dy , si ], & ! cone_angle = 5._R8 , & ! hori = ana_res ( 1 ) ) ! call surf_area ( tab_in = PARAM % surf ( 1 : nn , 1 : pp ), & ! long = nn , & ! larg = pp , & ! scale_xyz = [ dx , dy , si ], & ! aire = ana_res ( 2 ) ) ! ib = ie + 1 ie = ib + 2 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 2 ) !----------------------------------- head = head // 'Sasfc,R2adj,' call calcul_asfc_hermite ( tab_in = PARAM % surf ( 1 : nn , 1 : pp ), & ! scal = SCALE_IMG , & ! asfc_res = ana_res ( 1 : 2 ), & ! omp = . true . ) ! ib = ie + 1 ie = ib + 2 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 2 ) !----------------------------------- head = head // 'Rmax,Sal,Stri,Std,d.sl,b.sl,r.sl,r.cv,bmp,smp,rmp,bml,sml,rml,bms,sms,rms' if ( sum ( PARAM % acf_surf ( 1 : nn , 1 : pp )) == 0 ) then call acf_wiener ( tab_in = PARAM % surf ( 1 : nn , 1 : pp ), & ! IN tab_out = PARAM % acf_surf ( 1 : nn , 1 : pp ), & ! OUT w = nn , & ! IN h = pp ) ! IN endif call ellipse_acf ( tabin = PARAM % acf_surf ( 1 : nn , 1 : pp ), & ! IN long = nn , & ! IN larg = pp , & ! IN p_acv = ana_res ( 1 : 8 ), & ! OUT -> correlation lengths cut = PARAM % curr_surf % cut , & ! IN  -> z cut plane scale_xy = [ PARAM % surf_dx , PARAM % surf_dy ], & ! IN  -> lags along x and y omp = . true . ) ! IN  -> use multithread? PARAM % curr_surf % cl1 = ana_res ( 1 ) PARAM % curr_surf % cl2 = ana_res ( 2 ) PARAM % curr_surf % ang = ana_res ( 4 ) call multiple_anisotropy ( tabin = PARAM % surf ( 1 : nn , 1 : pp ), & ! IN long = nn , & ! IN larg = pp , & ! IN scale_xy = [ dx , dy ], & ! IN multi_fft = . false ., & ! IN vec_ani = ana_res ( 9 : 17 ) ) ! OUT ib = ie + 1 ie = ib + 17 - 1 tab_results ( ib : ie ) = ana_res ( 1 : 17 ) if ( append /= 1 ) write ( STA , '(a)' ) trim ( head ) write ( str , '(E18.6)' ) tab_results ( 1 ) result_str = str do i = 2 , ie write ( str , '(E18.6)' ) tab_results ( i ) result_str = result_str // ',' // str enddo write ( STA , * ) result_str deallocate ( head ) deallocate ( result_str ) deallocate ( tab_results ) return endsubroutine surface_analysis endmodule analyses","tags":"","loc":"sourcefile/mod_analyses.f90.html"},{"title":"mod_skku_profiles.f90 – CREST","text":"This file depends on sourcefile~~mod_skku_profiles.f90~~EfferentGraph sourcefile~mod_skku_profiles.f90 mod_skku_profiles.f90 sourcefile~mod_crest_param.f90 mod_crest_param.f90 sourcefile~mod_skku_profiles.f90->sourcefile~mod_crest_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_skku_profiles.f90~~AfferentGraph sourcefile~mod_skku_profiles.f90 mod_skku_profiles.f90 sourcefile~mod_script.f90 mod_script.f90 sourcefile~mod_script.f90->sourcefile~mod_skku_profiles.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_script.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: may, 03 2019 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.2em;\"> !        **Routines to generate a (Sk, Ku) series** !  </span> module skku_profiles use data_arch , only : I4 , R8 , UN , EPS_R8 , PI_R8 , HIG_E8 use crest_param , only : PARAM , JOB , SPY , TER , FCT_TANG , FCT_EXPO use stat_mom , only : moment_stat , calc_moments , scramble , std_array use sort_arrays , only : sort_array2 , init_order use pikaia_oop , only : pikaia_class implicit none !> {!src/inc_doc/profile_generation.md!} private public :: build_heights contains subroutine build_heights ( vec_out , use_fct_expo , stats_in , lg ) !================================================================================================ !<@note Function that returns a set of heights that matches desired statistical moments. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: lg !! *length of the height vector* type ( MOMENT_STAT ), intent ( in ) :: stats_in !! *input statistical moments* logical ( kind = I4 ), intent ( in ) :: use_fct_expo !! *should exponential function rather than tangent function be used?* real ( kind = R8 ), intent ( out ), dimension ( 1 : lg ) :: vec_out !! *height vector* integer ( kind = I4 ) :: istat real ( kind = R8 ) :: cost_val type ( MOMENT_STAT ) :: m_tmp real ( kind = R8 ), dimension (:), allocatable :: xlower real ( kind = R8 ), dimension (:), allocatable :: xupper real ( kind = R8 ), dimension (:), allocatable :: xresul ! put input parameters in global variables, so that they can be used in the function \"fitness_skku_anal\" PARAM % m_inp % sk = stats_in % sk PARAM % m_inp % ku = stats_in % ku ! if the Pearson limit is to close to the point (Ssk, Sku), an exponential function is used if ( use_fct_expo ) then PARAM % func_gen = FCT_EXPO PARAM % nparam = 3 else PARAM % func_gen = FCT_TANG PARAM % nparam = 2 endif ! Genetic algorithm is used to determinate the tangent parameters \\alpha and \\beta so that, the set of lg heights ! will match the statistical moments. !.............................................................................. ! initialization allocate ( xresul ( 1 : PARAM % nparam ) ) ; xresul = 0.0_R8 allocate ( xlower ( 1 : PARAM % nparam ) ) ; xlower = 1.e-6_R8 allocate ( xupper ( 1 : PARAM % nparam ) ) ; xupper = 1.0_R8 call pikaia_skku_solver ( pik_class = PARAM % pik_class , & ! INOUT step = 'init' , & ! IN xl = xlower ( 1 : PARAM % nparam ), & ! IN xu = xupper ( 1 : PARAM % nparam ), & ! IN xx = xresul ( 1 : PARAM % nparam ), & ! IN nparam = PARAM % nparam , & ! IN cost = cost_func_skku , & ! IN istat = istat , & ! OUT f = cost_val ) ! IN call pikaia_skku_solver ( pik_class = PARAM % pik_class , & ! INOUT step = 'solv' , & ! IN xl = xlower ( 1 : PARAM % nparam ), & ! IN xu = xupper ( 1 : PARAM % nparam ), & ! IN xx = xresul ( 1 : PARAM % nparam ), & ! OUT nparam = PARAM % nparam , & ! IN cost = cost_func_skku , & ! IN istat = istat , & ! OUT f = cost_val ) ! IN !.............................................................................. ! the parameters habe been found, let generate lg heights !.............................................................................. call profil_theo_trie_1D ( tab = vec_out ( 1 : lg ), & ! OUT lg = lg , & ! IN x = xresul ( 1 : PARAM % nparam ), & ! IN mx = m_tmp ) ! OUT !.............................................................................. ! PARAM%func_gen value is retrieved !PARAM%func_gen = fct_sav deallocate ( xresul ) deallocate ( xlower ) deallocate ( xupper ) call std_array ( tab = vec_out ( 1 : lg ), mx = m_tmp ) ! the parameter found can lead to inverted heights if ( stats_in % sk * m_tmp % sk < 0. ) then vec_out ( 1 : lg ) = - vec_out ( 1 : lg ) endif ! heights are sorted call sort_array2 ( tab_inout = vec_out ( 1 : lg ), n = lg ) return endsubroutine build_heights subroutine cost_func_skku ( me , x , f ) !! Quantify de distance between desired moments and calculated moments implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f f = fitness_skku_anal ( n = PARAM % nparam , x = x ( 1 : PARAM % nparam ) ) return endsubroutine cost_func_skku real ( kind = R8 ) function fitness_skku_anal ( n , x ) !================================================================================================ !<@note Generic cost function: difference between the imposed statistical moments and those !< obtained. The optimization problem must be turned into a maximization problem (as often !< in the optimization routines). !< !< The closer cost to 100 the better series. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n !! *number of unknowns* real ( kind = R8 ), intent ( in ), dimension ( 1 : n ) :: x !! *vector of unknowns* real ( kind = R8 ) :: sk , ku select case ( PARAM % func_gen ) case ( FCT_TANG ) ; call calculs_skku_tan ( bounds = x ( 1 : PARAM % nparam ), lg = PARAM % npts , ssk = sk , sku = ku ) case ( FCT_EXPO ) ; call calculs_skku_exp3 ( bounds = x ( 1 : PARAM % nparam ), lg = PARAM % npts , ssk = sk , sku = ku ) endselect fitness_skku_anal = ( abs ( sk ** 2 - PARAM % m_inp % sk ** 2 ) + & ! abs ( ku - PARAM % m_inp % ku ) ) / PARAM % m_inp % ku ! fitness_skku_anal = 10 0._r8 / ( 1._r8 + fitness_skku_anal ) return endfunction fitness_skku_anal subroutine pikaia_skku_solver ( pik_class , step , xl , xu , nparam , cost , istat , f , xx ) !================================================================================================ !<@note This is a refactoring of the PIKAIA unconstrained optimization code from the High Altitude Observatory. !< The original code is public domain and was written by Paul Charbonneau & Barry Knapp. !< !< The present code is the awesome modern Fortran version written by Jabob Williams: !< !< [OOP Pikaia, Jacob Williams](https://github.com/jacobwilliams/pikaia) !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none type ( pikaia_class ), intent ( inout ) :: pik_class !! **PIKAIA** *class instanciation* character ( len = 4 ), intent ( in ) :: step !! *init* or *solv* integer ( kind = I4 ), intent ( in ) :: nparam !! *number of parameters* real ( kind = R8 ), intent ( in ), dimension ( 1 : nparam ) :: xl !! *lower bonds of xx* real ( kind = R8 ), intent ( in ), dimension ( 1 : nparam ) :: xu !! *upper bonds of xx* real ( kind = R8 ), intent ( out ), dimension ( 1 : nparam ) :: xx !! *chromosom for* **PIKAIA** integer ( kind = I4 ), intent ( out ) :: istat real ( kind = R8 ), intent ( out ) :: f interface subroutine cost ( me , x , f ) use data_arch , only : R8 use pikaia_oop , only : pikaia_class implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f endsubroutine cost endinterface select case ( step ) case ( 'init' ) !initialize the class: call pik_class % init ( n = nparam , & ! IN           ; the parameter space dimension, i.e., the number of adjustable parameters (size of the x vector). xl = xl , & ! IN, DIM(n)   ;  vector of lower bounds for x xu = xu , & ! IN, DIM(n)   ;  vector of upper bounds for x f = cost , & !              ; user-supplied scalar function of n variables, which must have the pikaia_func procedure interface. status = istat , & ! OUT          ; status output flag (0 if there were no errors) !iter_f = report_iteration,    &  !     OPT      ; user-supplied subroutine that will report the best solution for each generation. It must have the iter_func procedure interface. np = 100 , & ! IN, OPT      ; number of individuals in a population (default is 100) ngen = 1000 , & ! IN, OPT      ; maximum number of iterations nd = 9 , & ! IN           ; number of significant digits (i.e., number of genes) retained in chromosomal encoding pcross = 0.85_R8 , & ! IN, OPT      ; crossover probability; must be <= 1.0 (default is 0.85). If crossover takes place, either one or two splicing points are used, with equal probabilities pmutmn = 0.0005_R8 , & ! IN, OPT      ; minimum mutation rate; must be >= 0.0 (default is 0.0005) pmutmx = 0.25_R8 , & ! IN, OPT      ; maximum mutation rate; must be <= 1.0 (default is 0.25) pmut = 0.005_R8 , & ! IN, OPT      ; initial mutation rate; should be small (default is 0.005) (Note: the mutation rate is the probability that any one gene locus will mutate in any one generation.) imut = 2 , & ! IN, OPT      ; mutation mode; 1/2/3/4/5 (default is 2). !              1=one-point mutation, fixed rate. !              2=one-point, adjustable rate based on fitness. !              3=one-point, adjustable rate based on distance. !              4=one-point+creep, fixed rate. !              5=one-point+creep, adjustable rate based on fitness. !              6=one-point+creep, adjustable rate based on distance. fdif = 1._R8 , & ! IN, OPT      ; relative fitness differential; range from 0 (none) to 1 (maximum). (default is 1.0) irep = 3 , & ! IN, OPT      ; reproduction plan; 1/2/3=Full generational replacement/Steady-state-replace-random/Steady- state-replace-worst (default is 3) ielite = 0 , & ! IN, OPT      ; elitism flag; 0/1=off/on (default is 0) (Applies only to reproduction plans 1 and 2) ivrb = 0 , & ! IN, OPT      ; printed output 0/1/2=None/Minimal/Verbose convergence_tol = 1.0e-6_R8 , & ! IN, OPT      ; convergence tolerance; must be > 0.0 (default is 0.0001) convergence_window = 200 , & ! IN, OPT      ; convergence window; must be >= 0 This is the number of consecutive solutions within the tolerance for convergence to be declared (default is 20) initial_guess_frac = 0.1_R8 , & ! IN, OPT      ; raction of the initial population to set equal to the initial guess. Range from 0 (none) to 1.0 (all). (default is 0.1 or 10%). iseed = 999 ) ! IN, OPT      ; random seed value; must be > 0 (default is 999) case ( 'solv' ) call pik_class % solve ( x = xx ( 1 : nparam ), & ! INOUT, DIM(*) ; f = f , & !   OUT         ; status = istat , & !   OUT         ; omp = . true . ) ! IN, OPTIONAL case default stop 'Wrong choice in \"pikaia_skku_solver\"' endselect return endsubroutine pikaia_skku_solver subroutine calculs_skku_tan ( bounds , lg , ssk , sku ) !================================================================================================ !<@note Function to calculate the skewness and kurtosis of a **tangent** series !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: bounds !! *defines the function limits* [-pi/2.(1-bounds(1)), +pi/2.(1-bounds(2)] integer ( kind = I4 ), intent ( in ) :: lg !! *vec size* real ( kind = R8 ), intent ( out ) :: ssk !! *theoretical Ssk* real ( kind = R8 ), intent ( out ) :: sku !! *theoretical Sku* real ( kind = R8 ) :: xa , xb , mu , si , sk , ku , a , b real ( kind = R8 ) :: h , hh , b1 , b2 , alp , bet integer ( kind = I4 ) :: i , ia , ib , deb , fin !--------------------------------------------- ! WXMAXIMA file !--------------------------------------------- !kill(all); ! !f11(x):=tan(x)$ ! !assume(u<0.)$ !assume(u>-%pi/2)$ !assume(v>0.)$ !assume(v<%pi/2)$ ! !I11:integrate(f11(x),x,u,v)$ !I11:subst(-%pi/2+%pi/2*xa,u,I11)$ !I11:subst(+%pi/2-%pi/2*xb,v,I11)$ !I11:expand(trigsimp(I11)); ! !f21(x):=f11(x)-mu$ !I21:integrate(expand(f21(x)&#94;2),x,u,v)$ !I21:subst(-%pi/2+%pi/2*xa,u,I21)$ !I21:subst(+%pi/2-%pi/2*xb,v,I21)$ !I21:expand(trigsimp(I21)); ! !f31(x):=f21(x)/si$ !I31:integrate(f31(x)&#94;3,x,u,v)$ !I31:subst(-%pi/2+%pi/2*xa,u,I31)$ !I31:subst(+%pi/2-%pi/2*xb,v,I31)$ !I31:expand(trigsimp(I31)); ! !I41:integrate(f31(x)&#94;4,x,u,v)$ !I41:subst(-%pi/2+%pi/2*xa,u,I41)$ !I41:subst(+%pi/2-%pi/2*xb,v,I41)$ !I41:expand(trigsimp(I41)); !--------------------------------------------- ia = 256 ! ia and ib define the interval edges to be excluded ... ib = 256 ! ... because of high variations of the function. deb = 1 + ia ! start fin = lg - ib ! end a = bounds ( 1 ) b = bounds ( 2 ) hh = ( 2._R8 - a - b ) / ( lg - 1 ) h = ( PI_R8 / 2 ) * hh xa = a + ia * hh xb = b + ib * hh b1 = - PI_R8 / 2 * ( UN - a ) b2 = + PI_R8 / 2 * ( UN - b ) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . mu = log ( sin (( PI_R8 * xa ) / 2. )) - log ( sin (( PI_R8 * xb ) / 2. )) mu = ( UN / h ) * mu + add_tang ( 1 , deb , fin , alp , bet , mu = 0._R8 , si = 1._R8 ) do i = 1 , ia - 1 mu = mu + tang ( i * UN , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo do i = lg , lg - ( ib - 2 ), - 1 mu = mu + tang ( i * UN , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo mu = mu / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . si = 2. * mu * log ( sin (( PI_R8 * xb ) / 2. )) + cos (( PI_R8 * xb ) / 2. ) / sin (( PI_R8 * xb ) / 2. ) - ( PI_R8 * mu ** 2. * xb ) / 2. + ( PI_R8 * xb ) / 2. & ! - 2. * mu * log ( sin (( PI_R8 * xa ) / 2. )) + cos (( PI_R8 * xa ) / 2. ) / sin (( PI_R8 * xa ) / 2. ) - ( PI_R8 * mu ** 2. * xa ) / 2. + ( PI_R8 * xa ) / 2. + PI_R8 * mu ** 2. - PI_R8 ! si = ( UN / h ) * si + add_tang ( 2 , deb , fin , alp , bet , mu , si = 1._R8 ) do i = 1 , ia - 1 si = si + tang ( i * UN , 2 , alp , bet , mu , si = 1._R8 ) enddo do i = lg , lg - ( ib - 2 ), - 1 si = si + tang ( i * UN , 2 , alp , bet , mu , si = 1._R8 ) enddo si = si / lg si = sqrt ( si ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . sk = log ( sin (( PI_R8 * xb ) / 2. ) ** 2. ) / ( 2. * si ** 3. ) & ! - ( 3. * mu ** 2. * log ( sin (( PI_R8 * xb ) / 2. ))) / si ** 3. & ! - ( 3. * mu * cos (( PI_R8 * xb ) / 2. )) / ( si ** 3. * sin (( PI_R8 * xb ) / 2. )) & ! + 1 / ( 2. * si ** 3. * sin (( PI_R8 * xb ) / 2. ) ** 2. ) + ( PI_R8 * mu ** 3. * xb ) / ( 2. * si ** 3. ) & ! - ( 3. * PI_R8 * mu * xb ) / ( 2. * si ** 3. ) & ! - log ( sin (( PI_R8 * xa ) / 2. ) ** 2. ) / ( 2. * si ** 3. ) & ! + ( 3. * mu ** 2. * log ( sin (( PI_R8 * xa ) / 2. ))) / si ** 3. & ! - ( 3. * mu * cos (( PI_R8 * xa ) / 2. )) / ( si ** 3. * sin (( PI_R8 * xa ) / 2. )) & ! - 1 / ( 2. * si ** 3. * sin (( PI_R8 * xa ) / 2. ) ** 2. ) + ( PI_R8 * mu ** 3. * xa ) / ( 2. * si ** 3. ) & ! - ( 3. * PI_R8 * mu * xa ) / ( 2. * si ** 3. ) - ( PI_R8 * mu ** 3. ) / si ** 3. + ( 3. * PI_R8 * mu ) / si ** 3. ! sk = ( UN / h ) * sk + add_tang ( 3 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 sk = sk + tang ( i * UN , 3 , alp , bet , mu , si ) enddo do i = lg , lg - ( ib - 2 ), - 1 sk = sk + tang ( i * UN , 3 , alp , bet , mu , si ) enddo sk = sk / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ku = - ( 2. * mu * log ( sin (( PI_R8 * xb ) / 2. ) ** 2. )) / si ** 4. + ( 4. * mu ** 3. * log ( sin (( PI_R8 * xb ) / 2. ))) / si ** 4. & ! + ( 6. * mu ** 2. * cos (( PI_R8 * xb ) / 2. )) / ( si ** 4. * sin (( PI_R8 * xb ) / 2. )) - ( 4. * cos (( PI_R8 * xb ) / 2. )) / ( 3. * si ** 4. * sin (( PI_R8 * xb ) / 2. )) & ! - ( 2. * mu ) / ( si ** 4. * sin (( PI_R8 * xb ) / 2. ) ** 2. ) + cos (( PI_R8 * xb ) / 2. ) / ( 3. * si ** 4. * sin (( PI_R8 * xb ) / 2. ) ** 3. ) & ! - ( PI_R8 * mu ** 4. * xb ) / ( 2. * si ** 4. ) + ( 3. * PI_R8 * mu ** 2. * xb ) / si ** 4. - ( PI_R8 * xb ) / ( 2. * si ** 4. ) & ! + ( 2. * mu * log ( sin (( PI_R8 * xa ) / 2. ) ** 2. )) / si ** 4. - ( 4. * mu ** 3. * log ( sin (( PI_R8 * xa ) / 2. ))) / si ** 4. & ! + ( 6. * mu ** 2. * cos (( PI_R8 * xa ) / 2. )) / ( si ** 4. * sin (( PI_R8 * xa ) / 2. )) - ( 4. * cos (( PI_R8 * xa ) / 2. )) / ( 3. * si ** 4. * sin (( PI_R8 * xa ) / 2. )) & ! + ( 2. * mu ) / ( si ** 4. * sin (( PI_R8 * xa ) / 2. ) ** 2. ) + cos (( PI_R8 * xa ) / 2. ) / ( 3. * si ** 4. * sin (( PI_R8 * xa ) / 2. ) ** 3. ) & ! - ( PI_R8 * mu ** 4. * xa ) / ( 2. * si ** 4. ) + ( 3. * PI_R8 * mu ** 2. * xa ) / si ** 4. - ( PI_R8 * xa ) / ( 2. * si ** 4. ) & ! + ( PI_R8 * mu ** 4. ) / si ** 4. - ( 6. * PI_R8 * mu ** 2. ) / si ** 4. + PI_R8 / si ** 4. ! ku = ( UN / h ) * ku + add_tang ( 4 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 ku = ku + tang ( i * UN , 4 , alp , bet , mu , si ) enddo do i = lg , lg - ( ib - 2 ), - 1 ku = ku + tang ( i * UN , 4 , alp , bet , mu , si ) enddo ku = ku / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ssk = sk sku = ku return endsubroutine calculs_skku_tan real ( kind = R8 ) function add_tang ( n , deb , fin , alp , bet , mu , si ) !================================================================================================ !<@note Function that adds to the series mean the border integrals as explained in the docs !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: alp !! *offset so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: bet !! *reduction so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: mu !! *numerical mean* real ( kind = R8 ), intent ( in ) :: si !! *numerical standard deviation* integer ( kind = I4 ), intent ( in ) :: n !! *statistical moment degree, n=3 for sk and n=4 for ku* integer ( kind = I4 ), intent ( in ) :: fin !! *last integration point* integer ( kind = I4 ), intent ( in ) :: deb !! *first integration point* real ( kind = R8 ) :: xdeb , xfin xdeb = deb xfin = fin add_tang = ( UN / 12 ) * ( + 9 * ( tang ( xdeb + 0.0_R8 , n , alp , bet , mu , si ) + tang ( xfin - 0.0_R8 , n , alp , bet , mu , si )) & + 1 * ( tang ( xdeb + 1.0_R8 , n , alp , bet , mu , si ) + tang ( xfin - 1.0_R8 , n , alp , bet , mu , si )) & - 4 * ( tang ( xdeb + 0.5_R8 , n , alp , bet , mu , si ) + tang ( xfin - 0.5_R8 , n , alp , bet , mu , si )) ) return endfunction add_tang real ( kind = R8 ) function tang ( xi , n , alp , bet , mu , si ) !================================================================================================ !<@note Profile function based on the tangent function !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: alp !! *offset so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: bet !! *reduction so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: mu !! *numerical mean* real ( kind = R8 ), intent ( in ) :: si !! *numerical standard deviation* real ( kind = R8 ), intent ( in ) :: xi !! *abscissa* integer ( kind = I4 ), intent ( in ) :: n !! *statistical moment degree, n=3 for sk and n=4 for ku* real ( kind = R8 ) :: tmp tmp = ( xi + alp ) / bet tang = ( ( tan ( tmp ) - mu ) / si ) ** n return endfunction tang subroutine calculs_skku_exp3 ( bounds , lg , ssk , sku ) !================================================================================================ !<@note Function to calculate the skewness and kurtosis of an **exponential** series.<br/> !< The principle is the same as [[calculs_skku_tan]], however it fits better some particular !< series quite binary (roughly two heights). !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 3 ) :: bounds !! *interval limits* [-(1/bounds(1)-1), +(1/bounds(2)-1)] integer ( kind = I4 ), intent ( in ) :: lg !! *vec size* real ( kind = R8 ), intent ( out ) :: ssk !! *theoretical Ssk* real ( kind = R8 ), intent ( out ) :: sku !! *theoretical Sku* real ( kind = R8 ) :: xa , xb , kk , kk2 , kk3 , kk4 , mu , si , sk , ku , a , b , c real ( kind = R8 ) :: mu2 , mu3 , mu4 , si3 , si4 real ( kind = R8 ) :: h , hh , b1 , b2 , alp , bet , gam real ( kind = R8 ) :: exp1b , exp1a , exp2b , exp2a , exp3b , exp3a , exp4b , exp4a , tmp1a , tmp1b , tmp2a , tmp2b , tmp3a , tmp3b , tmp4a , tmp4b real ( kind = R8 ) :: tmp1a2 , tmp1b2 , tmp1a3 , tmp1b3 , tmp1a4 , tmp1b4 , tmp1a5 , tmp1b5 , tmp1a6 , tmp1b6 real ( kind = R8 ) :: tmp1a7 , tmp1b7 , tmp1a8 , tmp1b8 , tmp1a9 , tmp1b9 , tmp1a10 , tmp1b10 , tmp1a13 , tmp1b13 integer ( kind = I4 ) :: deb , fin deb = 1 fin = lg a = bounds ( 1 ) b = bounds ( 2 ) c = bounds ( 3 ) hh = ( - 2._R8 + UN / a + UN / b ) / ( lg - 1 ) h = hh xa = a xb = b b1 = - ( UN - a ) / a b2 = + ( UN - b ) / b alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) kk = c / ( b2 - b1 ) ** 3 gam = kk kk2 = kk ** 2 kk3 = kk ** 3 kk4 = kk ** 4 tmp1a = - 1 * ( UN - UN / xa ) ; tmp1a = min ( + 0.9 * HIG_E8 , tmp1a ) ; tmp1a = max ( - 0.9 * HIG_E8 , tmp1a ) tmp1b = - 1 * ( UN - UN / xb ) ; tmp1b = min ( + 0.9 * HIG_E8 , tmp1b ) ; tmp1b = max ( - 0.9 * HIG_E8 , tmp1b ) tmp2a = - 2 * ( UN - UN / xa ) ; tmp2a = min ( + 0.9 * HIG_E8 , tmp2a ) ; tmp2a = max ( - 0.9 * HIG_E8 , tmp2a ) tmp2b = - 2 * ( UN - UN / xb ) ; tmp2b = min ( + 0.9 * HIG_E8 , tmp2b ) ; tmp2b = max ( - 0.9 * HIG_E8 , tmp2b ) tmp3a = - 3 * ( UN - UN / xa ) ; tmp3a = min ( + 0.9 * HIG_E8 , tmp3a ) ; tmp3a = max ( - 0.9 * HIG_E8 , tmp3a ) tmp3b = - 3 * ( UN - UN / xb ) ; tmp3b = min ( + 0.9 * HIG_E8 , tmp3b ) ; tmp3b = max ( - 0.9 * HIG_E8 , tmp3b ) tmp4a = - 4 * ( UN - UN / xa ) ; tmp4a = min ( + 0.9 * HIG_E8 , tmp4a ) ; tmp4a = max ( - 0.9 * HIG_E8 , tmp4a ) tmp4b = - 4 * ( UN - UN / xb ) ; tmp4b = min ( + 0.9 * HIG_E8 , tmp4b ) ; tmp4b = max ( - 0.9 * HIG_E8 , tmp4b ) tmp1a2 = tmp1a ** 2 ; tmp1b2 = tmp1b ** 2 tmp1a3 = tmp1a ** 3 ; tmp1b3 = tmp1b ** 3 tmp1a4 = tmp1a ** 4 ; tmp1b4 = tmp1b ** 4 tmp1a5 = tmp1a ** 5 ; tmp1b5 = tmp1b ** 5 tmp1a6 = tmp1a ** 6 ; tmp1b6 = tmp1b ** 6 tmp1a7 = tmp1a ** 7 ; tmp1b7 = tmp1b ** 7 tmp1a8 = tmp1a ** 8 ; tmp1b8 = tmp1b ** 8 tmp1a9 = tmp1a ** 9 ; tmp1b9 = tmp1b ** 9 tmp1a10 = tmp1a ** 10 ; tmp1b10 = tmp1b ** 10 tmp1a13 = tmp1a ** 13 ; tmp1b13 = tmp1b ** 13 exp1a = exp ( - tmp1a ) ! exp( 1 * (1 - 1/xa) ) exp1b = exp ( - tmp1b ) ! exp( 1 * (1 - 1/xb) ) exp2a = exp ( - tmp2a ) ! exp( 2 * (1 - 1/xa) ) exp2b = exp ( - tmp2b ) ! exp( 2 * (1 - 1/xb) ) exp3a = exp ( - tmp3a ) ! exp( 3 * (1 - 1/xa) ) exp3b = exp ( - tmp3b ) ! exp( 3 * (1 - 1/xb) ) exp4a = exp ( - tmp4a ) ! exp( 4 * (1 - 1/xa) ) exp4b = exp ( - tmp4b ) ! exp( 4 * (1 - 1/xb) ) mu = - exp1a + exp1b - ( kk * tmp1a4 ) / 4.0D0 + ( kk * tmp1b4 ) / 4.0D0 - 1.0D0 / xa + 1.0D0 / xb mu = ( UN / h ) * mu + add_expo3 ( 1 , deb , fin , alp , bet , gam , mu = 0._R8 , si = 1._R8 ) mu = mu / lg mu2 = mu ** 2 mu3 = mu ** 3 mu4 = mu ** 4 !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . si = kk * ( - 2.4D+1 ) - exp2a / 2.0D0 - exp2b / 2.0D0 + exp1a * ( kk * 1.2D+1 + mu * 2.0D0 + 2.0D0 ) + exp1b * ( kk * 1.2D+1 - mu * 2.0D0 + 2.0D0 ) + tmp1a * ( mu * 2.0D0 + mu2 + 1.0D0 ) + tmp1b * ( mu * ( - 2.0D0 ) + mu2 + 1.0D0 ) + ( kk2 * tmp1a7 ) / 7.0D0 + ( kk2 * tmp1b7 ) / 7.0D0 + ( kk * tmp1a4 * ( mu + 1.0D0 )) / 2.0D0 - ( kk * tmp1b4 * ( mu - 1.0D0 )) / 2.0D0 + kk * exp1a * tmp1a2 * 6.0D0 + kk * exp1a * tmp1a3 * 2.0D0 + kk * exp1b * tmp1b2 * 6.0D0 + kk * exp1b * tmp1b3 * 2.0D0 + kk * exp1a * tmp1a * 1.2D+1 + kk * exp1b * tmp1b * 1.2D+1 - 3.0D0 si = ( UN / h ) * si + add_expo3 ( 2 , deb , fin , alp , bet , gam , mu , si = 1._R8 ) si = si / lg si = sqrt ( si ) si3 = si ** 3 si4 = si ** 4 !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . sk = - 1.0D0 / si3 * ( kk * ( - 2.79D+2 / 8.0D0 ) - mu * ( 9.0D0 / 2.0D0 ) + exp3a / 3.0D0 - kk * mu * 3.6D+1 - exp2a * ( kk * ( 9.0D0 / 8.0D0 ) + mu * ( 3.0D0 / 2.0D0 ) + 3.0D0 / 2.0D0 ) + tmp1a * ( mu * 3.0D0 + mu2 * 3.0D0 + mu3 + 1.0D0 ) + ( kk3 * tmp1a10 ) / 1.0D+1 - kk2 * 2.16D+3 - mu2 * 3.0D0 + exp1a * ( kk * 3.6D+1 + mu * 6.0D0 + kk * mu * 3.6D+1 + kk2 * 2.16D+3 + mu2 * 3.0D0 + 3.0D0 ) - kk * exp2a * tmp1a2 * ( 9.0D0 / 4.0D0 ) - kk * exp2a * tmp1a3 * ( 3.0D0 / 2.0D0 ) + kk * tmp1a4 * ( mu + 1.0D0 ) ** 2 * ( 3.0D0 / 4.0D0 ) + kk2 * tmp1a7 * ( mu + 1.0D0 ) * ( 3.0D0 / 7.0D0 ) + kk2 * exp1a * tmp1a4 * 9.0D+1 + kk2 * exp1a * tmp1a5 * 1.8D+1 + kk2 * exp1a * tmp1a6 * 3.0D0 - kk * exp2a * tmp1a * ( 9.0D0 / 4.0D0 ) + kk * exp1a * tmp1a * ( kk * 6.0D+1 + mu + 1.0D0 ) * 3.6D+1 + kk * exp1a * tmp1a2 * ( kk * 6.0D+1 + mu + 1.0D0 ) * 1.8D+1 + kk * exp1a * tmp1a3 * ( kk * 6.0D+1 + mu + 1.0D0 ) * 6.0D0 - 1.1D+1 / 6.0D0 ) + 1.0D0 / si3 * ( kk * ( - 2.79D+2 / 8.0D0 ) + mu * ( 9.0D0 / 2.0D0 ) + exp3b / 3.0D0 + kk * mu * 3.6D+1 - exp2b * ( kk * ( 9.0D0 / 8.0D0 ) - mu * ( 3.0D0 / 2.0D0 ) + 3.0D0 / 2.0D0 ) - tmp1b * ( mu * 3.0D0 - mu2 * 3.0D0 + mu3 - 1.0D0 ) + ( kk3 * tmp1b10 ) / 1.0D+1 - kk2 * 2.16D+3 - mu2 * 3.0D0 + exp1b * ( kk * 3.6D+1 - mu * 6.0D0 - kk * mu * 3.6D+1 + kk2 * 2.16D+3 + mu2 * 3.0D0 + 3.0D0 ) - kk * exp2b * tmp1b2 * ( 9.0D0 / 4.0D0 ) - kk * exp2b * tmp1b3 * ( 3.0D0 / 2.0D0 ) + kk * tmp1b4 * ( mu - 1.0D0 ) ** 2 * ( 3.0D0 / 4.0D0 ) - kk2 * tmp1b7 * ( mu - 1.0D0 ) * ( 3.0D0 / 7.0D0 ) + kk2 * exp1b * tmp1b4 * 9.0D+1 + kk2 * exp1b * tmp1b5 * 1.8D+1 + kk2 * exp1b * tmp1b6 * 3.0D0 - kk * exp2b * tmp1b * ( 9.0D0 / 4.0D0 ) + kk * exp1b * tmp1b2 * ( kk * 6.0D+1 - mu + 1.0D0 ) * 1.8D+1 + kk * exp1b * tmp1b3 * ( kk * 6.0D+1 - mu + 1.0D0 ) * 6.0D0 + kk * exp1b * tmp1b * ( kk * 6.0D+1 - mu + 1.0D0 ) * 3.6D+1 - 1.1D+1 / 6.0D0 ) sk = ( UN / h ) * sk + add_expo3 ( 3 , deb , fin , alp , bet , gam , mu , si ) sk = sk / lg !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ku = 1.0D0 / si4 * ( kk * ( - 6.77962962962963D+1 ) - mu * ( 2.2D+1 / 3.0D0 ) - exp4a / 4.0D0 - kk * mu * ( 2.79D+2 / 2.0D0 ) + exp3a * ( kk * ( 8.0D0 / 2.7D+1 ) + mu * ( 4.0D0 / 3.0D0 ) + 4.0D0 / 3.0D0 ) + exp1a * ( kk * 7.2D+1 + mu * 1.2D+1 + kk * mu * 1.44D+2 + kk * mu2 * 7.2D+1 + kk2 * mu * 8.64D+3 + kk2 * 8.64D+3 + kk3 * 1.45152D+6 + mu2 * 1.2D+1 + mu3 * 4.0D0 + 4.0D0 ) - kk * mu2 * 7.2D+1 - kk2 * mu * 8.64D+3 + ( kk4 * tmp1a13 ) / 1.3D+1 - kk2 * 8.60625D+3 - kk3 * 1.45152D+6 - mu2 * 9.0D0 - mu3 * 4.0D0 - exp2a * ( kk * ( 9.0D0 / 2.0D0 ) + mu * 6.0D0 + kk * mu * ( 9.0D0 / 2.0D0 ) + kk2 * ( 1.35D+2 / 4.0D0 ) + mu2 * 3.0D0 + 3.0D0 ) + tmp1a * ( mu * 4.0D0 + mu2 * 6.0D0 + mu3 * 4.0D0 + mu4 + 1.0D0 ) + kk * exp3a * tmp1a2 * ( 4.0D0 / 3.0D0 ) + kk * exp3a * tmp1a3 * ( 4.0D0 / 3.0D0 ) + kk * tmp1a4 * ( mu + 1.0D0 ) ** 3 + kk3 * tmp1a10 * ( mu + 1.0D0 ) * ( 2.0D0 / 5.0D0 ) - kk2 * exp2a * tmp1a4 * ( 4.5D+1 / 2.0D0 ) - kk2 * exp2a * tmp1a5 * 9.0D0 - kk2 * exp2a * tmp1a6 * 3.0D0 + kk3 * exp1a * tmp1a7 * 2.88D+2 + kk3 * exp1a * tmp1a8 * 3.6D+1 + kk3 * exp1a * tmp1a9 * 4.0D0 + kk2 * tmp1a7 * ( mu + 1.0D0 ) ** 2 * ( 6.0D0 / 7.0D0 ) + kk * exp3a * tmp1a * ( 8.0D0 / 9.0D0 ) + kk * exp1a * tmp1a * ( kk * 1.2D+2 + mu * 2.0D0 + kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 7.2D+1 - kk * exp2a * tmp1a2 * ( kk * 1.5D+1 + mu * 2.0D0 + 2.0D0 ) * ( 9.0D0 / 2.0D0 ) - kk * exp2a * tmp1a3 * ( kk * 1.5D+1 + mu * 2.0D0 + 2.0D0 ) * 3.0D0 + kk2 * exp1a * tmp1a4 * ( kk * 1.68D+2 + mu + 1.0D0 ) * 3.6D+2 + kk2 * exp1a * tmp1a5 * ( kk * 1.68D+2 + mu + 1.0D0 ) * 7.2D+1 + kk2 * exp1a * tmp1a6 * ( kk * 1.68D+2 + mu + 1.0D0 ) * 1.2D+1 + kk * exp1a * tmp1a2 * ( kk * 1.2D+2 + mu * 2.0D0 + kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 3.6D+1 + kk * exp1a * tmp1a3 * ( kk * 1.2D+2 + mu * 2.0D0 + kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 1.2D+1 - kk * exp2a * tmp1a * ( kk * 1.5D+1 + mu * 2.0D0 + 2.0D0 ) * ( 9.0D0 / 2.0D0 ) - 2.5D+1 / 1.2D+1 ) + 1.0D0 / si4 * ( kk * ( - 6.77962962962963D+1 ) + mu * ( 2.2D+1 / 3.0D0 ) - exp4b / 4.0D0 + kk * mu * ( 2.79D+2 / 2.0D0 ) + exp3b * ( kk * ( 8.0D0 / 2.7D+1 ) - mu * ( 4.0D0 / 3.0D0 ) + 4.0D0 / 3.0D0 ) + exp1b * ( kk * 7.2D+1 - mu * 1.2D+1 - kk * mu * 1.44D+2 + kk * mu2 * 7.2D+1 - kk2 * mu * 8.64D+3 + kk2 * 8.64D+3 + kk3 * 1.45152D+6 + mu2 * 1.2D+1 - mu3 * 4.0D0 + 4.0D0 ) - kk * mu2 * 7.2D+1 + kk2 * mu * 8.64D+3 + ( kk4 * tmp1b13 ) / 1.3D+1 - kk2 * 8.60625D+3 - kk3 * 1.45152D+6 - mu2 * 9.0D0 + mu3 * 4.0D0 - exp2b * ( kk * ( 9.0D0 / 2.0D0 ) - mu * 6.0D0 - kk * mu * ( 9.0D0 / 2.0D0 ) + kk2 * ( 1.35D+2 / 4.0D0 ) + mu2 * 3.0D0 + 3.0D0 ) + tmp1b * ( mu * ( - 4.0D0 ) + mu2 * 6.0D0 - mu3 * 4.0D0 + mu4 + 1.0D0 ) + kk * exp3b * tmp1b2 * ( 4.0D0 / 3.0D0 ) + kk * exp3b * tmp1b3 * ( 4.0D0 / 3.0D0 ) - kk * tmp1b4 * ( mu - 1.0D0 ) ** 3 - kk3 * tmp1b10 * ( mu - 1.0D0 ) * ( 2.0D0 / 5.0D0 ) - kk2 * exp2b * tmp1b4 * ( 4.5D+1 / 2.0D0 ) - kk2 * exp2b * tmp1b5 * 9.0D0 - kk2 * exp2b * tmp1b6 * 3.0D0 + kk3 * exp1b * tmp1b7 * 2.88D+2 + kk3 * exp1b * tmp1b8 * 3.6D+1 + kk3 * exp1b * tmp1b9 * 4.0D0 + kk2 * tmp1b7 * ( mu - 1.0D0 ) ** 2 * ( 6.0D0 / 7.0D0 ) + kk * exp3b * tmp1b * ( 8.0D0 / 9.0D0 ) + kk * exp1b * tmp1b * ( kk * 1.2D+2 - mu * 2.0D0 - kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 7.2D+1 - kk * exp2b * tmp1b2 * ( kk * 1.5D+1 - mu * 2.0D0 + 2.0D0 ) * ( 9.0D0 / 2.0D0 ) - kk * exp2b * tmp1b3 * ( kk * 1.5D+1 - mu * 2.0D0 + 2.0D0 ) * 3.0D0 + kk * exp1b * tmp1b2 * ( kk * 1.2D+2 - mu * 2.0D0 - kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 3.6D+1 + kk * exp1b * tmp1b3 * ( kk * 1.2D+2 - mu * 2.0D0 - kk * mu * 1.2D+2 + kk2 * 2.016D+4 + mu2 + 1.0D0 ) * 1.2D+1 + kk2 * exp1b * tmp1b4 * ( kk * 1.68D+2 - mu + 1.0D0 ) * 3.6D+2 + kk2 * exp1b * tmp1b5 * ( kk * 1.68D+2 - mu + 1.0D0 ) * 7.2D+1 + kk2 * exp1b * tmp1b6 * ( kk * 1.68D+2 - mu + 1.0D0 ) * 1.2D+1 - kk * exp2b * tmp1b * ( kk * 1.5D+1 - mu * 2.0D0 + 2.0D0 ) * ( 9.0D0 / 2.0D0 ) - 2.5D+1 / 1.2D+1 ) ku = ( UN / h ) * ku + add_expo3 ( 4 , deb , fin , alp , bet , gam , mu , si ) ku = ku / lg ssk = sk sku = ku contains real ( kind = R8 ) function expo3 ( xi , n , alp , bet , gam , mu , si ) !================================================================================================ !<@note Profile function based on the exponential function !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: alp !! *offset so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: bet !! *reduction so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: gam !! ** real ( kind = R8 ), intent ( in ) :: mu !! *numerical mean* real ( kind = R8 ), intent ( in ) :: si !! *numerical standard deviation* real ( kind = R8 ), intent ( in ) :: xi !! *abscissa* integer ( kind = I4 ), intent ( in ) :: n !! *statistical moment degree, n=3 for sk and n=4 for ku* real ( kind = R8 ) :: tmp tmp = ( xi + alp ) / bet expo3 = ( ( sign ( UN , tmp ) * ( UN - exp ( - abs ( tmp ))) + gam * tmp ** 3 - mu ) / si ) ** n return endfunction expo3 real ( kind = R8 ) function add_expo3 ( n , deb , fin , alp , bet , gam , mu , si ) !================================================================================================ !<@note Function that adds to the series mean the border integrals as explained in the modules !< presentation. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: alp !! *offset so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: bet !! *reduction so that points are in [b1,b2]* real ( kind = R8 ), intent ( in ) :: gam !! ** real ( kind = R8 ), intent ( in ) :: mu !! *numerical mean* real ( kind = R8 ), intent ( in ) :: si !! *numerical standard deviation* integer ( kind = I4 ), intent ( in ) :: n !! *statistical moment degree, n=3 for sk and n=4 for ku* integer ( kind = I4 ), intent ( in ) :: fin !! *last integration point* integer ( kind = I4 ), intent ( in ) :: deb !! *first integration point* real ( kind = R8 ) :: xdeb , xfin xdeb = deb xfin = fin add_expo3 = ( UN / 12 ) * ( + 9 * ( expo3 ( xdeb + 0.0_R8 , n , alp , bet , gam , mu , si ) + expo3 ( xfin - 0.0_R8 , n , alp , bet , gam , mu , si )) & + 1 * ( expo3 ( xdeb + 1.0_R8 , n , alp , bet , gam , mu , si ) + expo3 ( xfin - 1.0_R8 , n , alp , bet , gam , mu , si )) & - 4 * ( expo3 ( xdeb + 0.5_R8 , n , alp , bet , gam , mu , si ) + expo3 ( xfin - 0.5_R8 , n , alp , bet , gam , mu , si )) ) return endfunction add_expo3 endsubroutine calculs_skku_exp3 subroutine profil_theo_trie_1D ( tab , lg , x , mx ) !================================================================================================ !<@note Function that generates the heights when the function limits have been determined. !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: lg !! *height vector size* real ( kind = R8 ), intent ( out ), dimension ( 1 : lg ) :: tab !! *height vector* real ( kind = R8 ), intent ( in ), dimension ( : ) :: x !! *unknowns: height function limits* type ( MOMENT_STAT ), intent ( out ) :: mx !! *resulting statistical moments* real ( kind = R8 ) :: b1 , b2 , alp , bet , tmp integer ( kind = I4 ) :: i select case ( PARAM % func_gen ) case ( FCT_TANG ) b1 = - PI_R8 / 2 * ( UN - x ( 1 )) b2 = + PI_R8 / 2 * ( UN - x ( 2 )) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) do i = 1 , lg tab ( i ) = tan ( ( i * UN + alp ) / bet ) enddo case ( FCT_EXPO ) b1 = - ( UN - x ( 1 )) / x ( 1 ) b2 = + ( UN - x ( 2 )) / x ( 2 ) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) do i = 1 , lg tmp = ( i * UN + alp ) / bet tmp = max ( - 0.9 * HIG_E8 , tmp ) tmp = min ( + 0.9 * HIG_E8 , tmp ) tab ( i ) = sign ( UN , tmp ) * ( UN - exp ( - abs ( tmp ))) + ( x ( 3 ) / ( b2 - b1 ) ** 3 ) * tmp ** 3 enddo endselect call std_array ( tab = tab ( 1 : lg ), mx = mx ) mx % mu = 0._R8 mx % si = 1._R8 return endsubroutine profil_theo_trie_1D endmodule skku_profiles","tags":"","loc":"sourcefile/mod_skku_profiles.f90.html"},{"title":"main.f90 – CREST","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~mod_crest_param.f90 mod_crest_param.f90 sourcefile~main.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_script.f90 mod_script.f90 sourcefile~main.f90->sourcefile~mod_script.f90 sourcefile~mod_script.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_analyses.f90 mod_analyses.f90 sourcefile~mod_script.f90->sourcefile~mod_analyses.f90 sourcefile~mod_func_acf.f90 mod_func_acf.f90 sourcefile~mod_script.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_skku_profiles.f90 mod_skku_profiles.f90 sourcefile~mod_script.f90->sourcefile~mod_skku_profiles.f90 sourcefile~mod_analyses.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_analyses.f90->sourcefile~mod_func_acf.f90 sourcefile~mod_func_acf.f90->sourcefile~mod_crest_param.f90 sourcefile~mod_skku_profiles.f90->sourcefile~mod_crest_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: october, 23 2024 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.2em;\"> !        **Main program** !  </span> program main !$ use omp_lib use script , only : read_job use crest_param use data_arch , only : I4 , R8 implicit none !~ call test_logistic() !~ stop call prg_surf contains subroutine prg_surf () !================================================================================================ !<@note Main function... ! ! - retrieve script (job) file ! - read script ! - run specific functions associated to a script keyword ! !<@endnote !------------------------------------------------------------------------------------------------ implicit none character ( len = 128 ) :: arg_prg character ( len = 512 ) :: job_file integer ( kind = I4 ) :: var_i ! String initialisation arg_prg = repeat ( ' ' , len ( arg_prg )) JOB_FILE = repeat ( ' ' , len ( JOB_FILE )) var_i = 1 call get_command_argument ( var_i , arg_prg ) ! argument one: argument string if ( len_trim ( arg_prg ) == 0 ) then ! if there is no job file, stop write ( TER , * ) 'no job file, stop' stop else job_file = trim ( arg_prg ) endif call read_job ( job_file ) ! the program executes 'prg_repeat' times write ( TER , * ) 'Program completed' return endsubroutine prg_surf endprogram main","tags":"","loc":"sourcefile/main.f90.html"}]}